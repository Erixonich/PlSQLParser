CREATE OR REPLACE PACKAGE BODY KK_ST_BARCODE AS
--SELECT SQ_MCIS_NODES_PROC_TYP.NEXTVAL FROM DUAL
--
--

                       UNIQUE_CONSTRAINT_EXCEPT EXCEPTION;
 PRAGMA EXCEPTION_INIT(UNIQUE_CONSTRAINT_EXCEPT , -1);

FUNCTION GETVERSION RETURN VARCHAR2 IS BEGIN

RETURN '1.0.0.93 2017.09.25 PREPARETOJOBDISMANTLED ДОБАВЛЕН ВЫВОД ИНФОРМАЦИИ О ПАЛЛЕТАХ. ТАРАБЦЕВ 39846';
RETURN '1.0.0.92 2017.09.13 INPUTINDOCPALLCODE ДОБАВИЛ ДОСТУП НА ПРИХОДОВАНИЕ НА ТОТ ЖЕ ПАЛЛЕТ BANNEDTOTAKEONSAMEPALL БОРОДА';
RETURN '1.0.0.91 2017.09.13 INITIALMOVESUBMIT ОТМЕНА ВИРТУАЛЬНОГО РЕЗЕРВА. ТАРАБЦЕВ 39728';
RETURN '1.0.0.90 2017.09.05 SUBMITDISMANTLEDJOB РАЗБОР СОБРАННОГО КАК ПЕРЕМЕЩЕНИЕ. ТАРАБЦЕВ 39640';
RETURN '1.0.0.89 2017.08.21 BAR_LOG ДОБАВЛЕН EMP_N. БОРОДА';
RETURN '1.0.0.88 2017.05.11 INPUTINDOCPALLCODE НЕЛЬЗЯ СТАВИТЬ НА ПИД КОТОРЫЙ ПРИНИМАЕМ , ЕСЛИ ОН В ДРУГОМ ПРИХОДЕ(ДАЖЕ С НУЛЕМ И ДОСТУПОМ) БОРОДА';
RETURN '1.0.0.87 2017.04.11 GETSTBARCODEJOB_DEF ДЛЯ 32 ТИПА АНАЛИЗИРУЕМ ПОМИМО 6 ТИПА 19 ТИП. ТАРАБЦЕВ. 37790';
RETURN '1.0.0.86 2017.03.23 ALLDIMENSIONSEXISTS РАЗМЕРЫ БЕРЁМ ИЗ ТАБЛИЦЫ, А НЕ ИЗ ПЕРЕМЕННЫХ. ТАРАБЦЕВ. 37746';
RETURN '1.0.0.85 2017.03.07 INPUTCNT ВЫДАЁМ ОШИБКУ, ЕСЛИ НЕ ВВЕЛИ КОЛИЧЕСТВО. ТАРАБЦЕВ. 37631';
RETURN '1.0.0.84 2017.01.23 STOCKNBYNOMUNITS ПРОЯВЛЯЕТСЯ БАГ ПРИ КОЛИЧЕСТВЕ КОНВЕРТАЦИЙ У НОМЕНКЛАТУРЫ БОЛЬШЕ 2. ИСПРАВЛЕНО ЗАМЕНЫ ЗАПРОСА НА НЕЯВНЫЙ КУРСОР';
RETURN '1.0.0.84 2017.01.23 INPUTINDOCNOMCNT ДОБАВЛЕН ВЫЗОВ ПОЛЬЗОВАТЕЛЬСКОЙ ПРОЦЕДУРЫ ПО КОНСТ INPUTINDOCNOMCNT.USERCHECK. ТАРАБЦЕВ. 37166';
RETURN '1.0.0.83 2017.01.23 GETNOMCURSORBYUSERPROC, GETNOMCURSORBYUSERPROC_DEF ДОБАВЛЕН ПАРАМЕТР PDOCTYP. ТАРАБЦЕВ. 37151';
RETURN '1.0.0.82 2016.11.23 GETNOMCURSORBYUSERPROC_DEF ОПТИМИЗАЦИЯ ЗАПРОСА. ТАРАБЦЕВ. 36742';
RETURN '1.0.0.81 2016.11.14 STDOCINCOMPLETEPALL ДОБАВЛЕН ВЫЗОВ ФУНКЦИИ ДЛЯ ПРОВЕРКИ СРОКА ГОДНОСТИ ЧЕРЕЗ ДОП. ПАРАМЕТР. РАДОСТИН. 36277';
RETURN '1.0.0.80 2016.10.26 STDOCINDETDIFF_DEF ИЗМЕНЕН ПОДСЧЕТ ИЗЛИШКА';
RETURN '1.0.0.79 2016.09.08 GETSTBARCODEJOB_DEF ВЫВОД ОШИБКИ ДЛЯ 17 ТИПА, ЕСЛИ ЕСТЬ ЗАДАНИЕ ДЛЯ ДРУГОЙ ПАЛЛЕТЫ. ТАРАБЦЕВ. 36210';
RETURN '1.0.0.78 2016.09.08 STDOCINCOMPLETEPALL ДОБАВЛЕНО ПОЛУЧЕНИЕ EXPIRE ИЗ НОМЕНКЛАТУРЫ. РАДОСТИН. 36199';
RETURN '1.0.0.77 2016.09.02 STDOCINCOMPLETEPALL ДОБАВЛЕНО КОПИРОВАНИЕ ПАРТИИ ПО КОНСТАНТЕ STDOCIN.COPYPARTFROMDOC. ТАРАБЦЕВ. 36145';
RETURN '1.0.0.76 2016.09.02 INPUTINDOCNOMLIST ИСПРАВЛЕНА ОШИБКА ДЛЯ СЛУЧАЯ СКАНИРОВАНИЯ НОМЕНКЛАТУРЫ ИЗ 5 / 6. ТАРАБЦЕВ. 36144';
RETURN '1.0.0.76 2016.08.26 STDOCOUTNEEDPALLWEIGHT, STDOCINNEEDPALLWEIGHT ДОБАВЛЕН АНАЛИЗ ЗНАЧЕНИЯ CONTRAGENT.NOMWEIGHT.NOMGRP.NOREQUESTWEIGHT = 0. ТАРАБЦЕВ. 36036';
RETURN '1.0.0.75 2016.08.18 CHECKPRODDATE ДОБАВЛЕНА ПРОВЕРКА ДАТ С УЧЕТОМ ЗНАЧЕНИЙ ПОЛЯ EXPIRE В НОМЕНКЛАТУРЕ. РАДОСТИН. 35982';
RETURN '1.0.0.75 2016.08.15 CHECKINPUTCELLADDRESS ПРИ ПРОВЕРКЕ СВОБОДНОГО МЕСТА В ПАРАМЕТРЕ CEILCELL УЧИТЫВАТЬ КОНСТ STDOCMOVE.MOVEONLYTOEMPTYCELL . ТАРАБЦЕВ. 35952';
RETURN '1.0.0.74 2016.07.28 CHECKNEEDINPUTPID СОЗДАНИЕ. ТАРАБЦЕВ. 35753';
RETURN '1.0.0.73 2016.07.11 CELLEXISTSANDCANGET_DEF ОБРАБОТКА КОНСТАНТЫ STDOCOUT.FINEPICK.TO6MENU. ТАРАБЦЕВ. 35570';
RETURN '1.0.0.72 2016.06.27 PREPARETOJOBDISMANTLED, CHECKNOMINDISMANTLED_SHOWADDR, CHECKCNTINDISMANTLED_SHOWJOB, SUBMITDISMANTLEDJOB - СОЗДАНИЕ. ТАРАБЦЕВ. 35404';
RETURN '1.0.0.71 2016.06.19 CHECKNEEDINPUTTEAMEMPS, SHOWTEAMEMPS, INPUTTEAMEMP, CLEARTEAMEMPS, SUBMITTEAMEMPS - СОЗДАНИЕ. ТАРАБЦЕВ. 35405';
RETURN '1.0.0.70 2016.06.03 INPUTMOVECNTCHECK - ПРИ РАСЧЁТЕ КОЛ-ВО УЧИТЫВАЕМ ИЕРАРХИЮ. ТАРАБЦЕВ 35253';
RETURN '1.0.0.69 2016.05.10 INPUTMOVECNTCHECK - УЧИТЫВАЕМ ВАРИАНТ, КОГДА ВЗЯЛИ МЕНЬШУ. ТАРАБЦЕВ 35049';
RETURN '1.0.0.68 2016.05.10 GETSTBARCODEJOB_DEF - ВЫВОД НОМЕНКЛАТУРЫ УЧИТЫВАЕТ КОНСТАНТУ . ТАРАБЦЕВ 35049';
RETURN '1.0.0.67 2016.04.20 BAR_LOG - СОЗДАНИЕ, PROC3 - ДОБАВЛЕНО ЛОГИРОВАНИЕ. ТАРАБЦЕВ 34929';
RETURN '1.0.0.66 2016.04.04 INPUTINDOCNUM_DEF ПРОВЕРКА РАЗРЕШЕНИЯ РУЧНОГО ВВОДА ДОКУМЕНТА ПО ДОСТУПУ STBARCODEMANUALINPUTINDOCNUM. ТАРАБЦЕВ 34760';
RETURN '1.0.0.65 2016.03.24 STDOCINCOMPLETEPALL ОЧИСТКА ПЕРЕМЕННЫХ СЕССИИ ПО ГРАДАЦИИ БРАКА И ВИНОВНОГО В БРАКЕ. ГОРОЖАНКИН 34704';
RETURN '1.0.0.64 2016.02.23 CHECKFORNEEDINPUTCONDTYPE СОЗДАНИЕ ФУНКЦИИ. ТАРАБЦЕВ 34487';
RETURN '1.0.0.63 2016.02.02 CELLEXISTSANDCANGET_DEF ЗАДАНИЯ ЗАКРЫВАЕМ ТОЛЬКО ЕСЛИ ОНИ НЕ В СТАТУСЕ 3 ДЛЯ 12 ТИПА ОПЕРАЦИЙ. ТАРАБЦЕВ 34302';
RETURN '1.0.0.62 2015.12.22 INVENTORYSUBMITPALL ДОБАВЛЕМ ЗАПИСЬ ВЕСА. ТАРАБЦЕВ. 33779';
RETURN '1.0.0.61 2015.11.23 CHECKINPUTCELLADDRESS ДОБАВЛЕН ДОСТУП ALLOWPUTONSTOREPLACEMIXPALL. ТАРАБЦЕВ. 33779';
RETURN '1.0.0.60 2015.11.20 INPUTCELLADDRESS УБРАНО ROWNUM=1 , ЕСЛИ ЯЧЕЕК НЕСКОЛЬКО - НАДО СРАЗУ РВАТЬ ОШИБКОЙ. ТАРАБЦЕВ';
RETURN '1.0.0.59 2015.11.18 WHATONCELLADDRESS ИСПРАВЛЕНА ОШИБКА.33781. ТАРАБЦЕВ';
RETURN '1.0.0.58 2015.10.11 INITIALMOVESUBMIT ВЫЗОВ ПРОЦЕДУРЫ ПО КОНСТАНТЕ STDOC.PALLJOBCOMPLETE.USERPROC ПЕРЕНЕСЁН ПОСЛЕ ST_MOVE2. БОЕВ';
RETURN '1.0.0.57 2015.10.06 GETNOMCURSORBYUSERPROC_DEF ОГРАНИЧЕНИЕ ИСПОЛЬЗУЕМЫХ МАСОК ПО КОНТРАГЕНТАМ. БОЕВ';
RETURN '1.0.0.56 2015.10.01 GETNOMCURSORBYUSERPROC_DEF ОПТИМИЗАЦИЯ ЗАПРОСОВ ПОИСКА НОМЕНКЛАТУРЫ. ТАРАБЦЕВ';
RETURN '1.0.0.55 2015.09.22 INPUTCELLADDRESS ИСПРАВЛЕНА ОШИБКА ОПРЕДЕЛЕНИЕ ПУСТОГО ВВОДА. ТАРАБЦЕВ';
RETURN '1.0.0.54 2015.09.08 SHOWSTBARCODEJOB ОЧИЩАЕМ ПЕРЕМЕННУЮ "JOB_NUM" (СБРАСЫВАЕМ ПОРЯДОК ЗАДАНИЙ). ТАРАБЦЕВ';
RETURN '1.0.0.53 2015.09.04 INPUTPALLCODE ДОБАВЛЕН АНАЛИЗ КОНСТАНТЫ ALLOWPID0. ТАРАБЦЕВ';
RETURN '1.0.0.52 2015.08.31 GETSTBARCODEJOB_DEF ДЛЯ 32 ТИПА АДРЕС ОТКУДА БЕРЁМ ИЗ VAL2. ТАРАБЦЕВ';
RETURN '1.0.0.51 2015.08.31 CELLEXISTSANDCANGET_DEF COMPLETEJOB ВЫЗЫВАЕТСЯ ДЛЯ 3 И ДЛЯ 32 ТИПА (ДЛЯ СОЗДАНИЯ ЗАДАНИЯ С ТРАНЗИТА). ТАРАБЦЕВ';
RETURN '1.0.0.50 2015.08.10 PROC3 ДОБАВЛЕН ВЫЗОВ КОНЦЕВИКА ПО КОНСТАНТЕ MCIS.AFTERSELECTNODE. ТАРАБЦЕВ';
RETURN '1.0.0.49 2015.08.06 CELLEXISTSANDCANGET_DEF ПРИ ПЕРЕМЕЩЕНИИ НА ЯЧЕЙКУ КОНСОЛИДАЦИЮ ОБНОВЛЯЕМ АДРЕС В ПОДБОРЕ ST_DOC_OUT_PICK. ТАРАБЦЕВ';
RETURN '1.0.0.48 2015.08.05 STDOCINNEEDEXPIRE ВЫЗОВ ПРОЦЕДУРЫ ПО КОНСТАНТЕ STDOCINNEEDEXPIRE.PROCFORNOM. ТАРАБЦЕВ';
RETURN '1.0.0.47 2015.05.12 INPUTSIMPLEDATE. СОХРАНЯЕМ ВВЕДЁННУЮ ДАТУ В "DATE". ТАРАБЦЕВ';
RETURN '1.0.0.46 2015.04.07 INPUTCONDTYPE ОЧИСТКА ПЕРЕМЕННЫХ КОНДИЦИИ NOM_SUB_TYP, NOM_TYP_RESPONSE. ТАРАБЦЕВ';
RETURN '1.0.0.45 2015.03.17 INPUTPALLN ДОБАВЛЕНА ВОЗМОЖНОСТЬ ВЫЗОВА ПОЛЬЗОВАТЕЛЬСКОЙ ФУНКЦИИ CHANGEJOBRESERVE  ПО КОНСТАНТЕ CHANGEJOBRESERVE.USERPROC. ТАРАБЦЕВ';
RETURN '1.0.0.44 2015.03.06 STDOCININBOUNDNEEDINPUTEXPIRE ПРОВЕРКА НЕОБХОДИМОСТИ ВВОДА СРОКА ГОДНОСТИ ПРИ ПОШТУЧНОЙ ПРИЕМКЕ';
RETURN '1.0.0.43 2015.02.27 CELLEXISTSANDCANGET_DEF. ПРИ ИЕРАРХИИ ЗАДАНИЙ УБРАНО ОГРАНИЧЕНИЕ ПО TD(НЕ ПОПАДАЮТ ДОЧЕРНИЕ ЗАДАНИЯ). ТАРАБЦЕВ';
RETURN '1.0.0.42 2015.02.20 WHATONPALL. ДОБАВЛЕНА ИНФОРМАЦИЯ О ЗАКАЗЕ. ТАРАБЦЕВ';
RETURN '1.0.0.41 20150112 CHECKNEEDINPUTMOVECNT, INPUTMOVECNTCHECK. СОЗДАНИЕ ПРОЦЕДУР. ТАРАБЦЕВ';
RETURN '1.0.0.40 20150112 WHATONCELLADDRESS. ЕСЛИ АДРЕС РАВЕН, ТО ПО ПОДОБНОМУ НЕ ИЩЕМ. ТАРАБЦЕВ';
RETURN '1.0.0.39 20150109 INVENTORYWHATONPALL. ЕСЛИ ИНВ НЕ ПО АКТИВНОМУ СТОКУ, ТО ВЕРШИНЫ ОПРЕДЕЛЯЕМ ПО ИЕРАРХИИ (А НЕ MAX(FD)). ТАРАБЦЕВ';
RETURN '1.0.0.38 20141225 CHECKNEEDINPUTPART. ОБНУЛЯЕМ ПЕРЕМЕННУЮ PART.N. ТАРАБЦЕВ';
RETURN '1.0.0.37 20141210 INPUTNOMUNIT - СОХРАНЯЕМ НАИМЕНОВАНИЕ ЕД. ИЗМ. "NOMENKLATURA.UNIT_TYP.TERM". ТАРАБЦЕВ';
RETURN '1.0.0.36 20141118 STDOCINNEEDEXPIRE - ДОБАВЛЕНА ВОЗМОЖНОСТЬ АВТОМТИЧЕСКИ ДАТУ ПРОИЗВОДСТВА БРАТЬ КАК SYSDATE. КОНСТАНТА SYSDATEASPRODDATE. ТАРАБЦЕВ';
RETURN '1.0.0.35 20141113 INVENTORYWHATONPALL - ДОБАВЛЕНА ПРОВЕРА НА КОНТРАГЕНТА. ТАРАБЦЕВ';
RETURN '1.0.0.34 20141112 CHECKNEEDINPUTPART - АНАЛИЗИРУЕМ СОСКАНИРОВАННУЮ ПАРТИЮ ИЗ ШК. ТАРАБЦЕВ. ЗАДАЧА 30532';
RETURN '1.0.0.33 20141106 CELLEXISTSANDCANGET_DEF - РАЗМЕР ПРОВЕРЯЕТСЯ ЕСЛИ НЕТ СУПЕРДОСТУПА CHECKINPUTCELLADDRESS. ТАРАБЦЕВ. ЗАДАЧА 30532';
RETURN '1.0.0.32 20140929 CELLEXISTSANDCANGET_DEF - ПРИ ПРОВЕРКЕ РАЗМЕРА ЯЧЕЙКИ УЧИТВАЕМ ДОКУМЕНТ ПЕРЕМЕЩЕНИЯ. ТАРАБЦЕВ';
RETURN '1.0.0.31 20140929 PROC3 - СОХРАНЯЕМ В КОНТЕКСТ PROBJN KK_ST_CTX.ASSIGN(''PROBJN'', PROBJN). ТАРАБЦЕВ';
RETURN '1.0.0.30 20140917 WHATONPALL - ПРИ ВЫВОДЕ ИНФ О НЕ РАССТАВЛЕННОЙ ПАЛЛЕТЕ ПРОВЕРЯЕТСЯ ЕЁ НАЛИЧИЕ В СТОКЕ . ТАРАБЦЕВ';
RETURN '1.0.0.29 20140904 1.НОВАЯ CHECKNEEDINPUTNOM-ПРОВЕРКА НЕОБХОДИМОСТИ ВВОДА НОМЕНКЛАТУРЫ  2.CHEQUEFORNOMONADDR - ДОБАВЛЕНА ПРОВЕРКА НА СООТВЕТСТВИЕ НОМЕНКЛАТУРЫ . ТАРАБЦЕВ';
RETURN '1.0.0.28 20140827 INITIALMOVESUBMIT - ВМЕСТО CREATEJOBONEMP ВСТАВЛЯЕМ НАПРЯМУЮ (В ЭТОЙ ПРОЦЕДУРЕ НЕ ВСЕ ДАННЫЕ ПЕРЕДАЮТСЯ). ТАРАБЦЕВ';
RETURN '1.0.0.27 20140827 INITIALMOVESUBMIT - ПРИ СОЗДАНИИ JOB DOCTYP ДОЛЖЕН БЫТЬ 3 А НЕ 13. ТАРАБЦЕВ';
RETURN '1.0.0.26 20140807 INPUTBRAKTYPE, SHOWBRAKTYPE - ОТОБРАЖЕНИЕ И ВВОД ГРАДАЦИИ ПРОХОДИТ СОГЛАСНО ПЕРЕМЕННОЙ "NOM_TYP". ТАРАБЦЕВ';
RETURN '1.0.0.25 20140806 STDOCOUTNEEDPALLWEIGHT - ДОБАВЛЕНА ВОЗМОЖНОСТЬ ВВОДА ВЕСА ПО ОСТАТКУ. ТАРАБЦЕВ';
RETURN '1.0.0.24 20140708 INPUTBRAKTYPE - ВВОД ПОДТИПА ДОПУСКАЕТИСЯ ТОЛЬКО СОГЛАСНО КОНСТАНТЕ. ТАРАБЦЕВ';
RETURN '1.0.0.23 ДОБАВЛЕН ДОСТУП В CHECKINPUTCELLADDRESS ЧТО В ПОДБОРКУ МОЖНО БЫЛО ПЕРЕМЕЩАТЬ В ЯЧЕЙКУ ТОЛЬКО ТОТ ТОВАР, КОТОРЫЙ ПРИПИСАН';
RETURN '1.0.0.22 20140618 GETSTBARCODEJOB_DEF -  АДРЕС ОТКУДА БЕРЁТСЯ ИЗ VAL2, INPUTPALLN - СОХРАНЯЕМ PID';
RETURN '1.0.0.21 ИЗМЕНЕНЫ ФУНКЦИИ INPUTSIMPLENOMUNIT, SHOWSIMPLENOMUNIT( ПРИ RETURN 2 НИКУДА НЕ ПОПАДАЛ.ТЕПЕРЬ ЕСТЬ ТОЛЬКО RETURN 1 И НОВАЯ ПЕРЕМЕННАЯ СЕССИИ NOMENKLATURA.NOM_UNIT_SEL ) 06.05.14 ДМИТРИЕВ';
RETURN '1.0.0.20 20140423 ИЗМЕНЕНА ФУНКЦИЯ STDOCINNEEDPALLWEIGHT2. ДОБАВЛЕН АНАЛИЗ КОНСТАНТЫ USE.DEFAULT.PALLET.WEIGHT. ТАРАБЦЕВ';
RETURN '1.0.0.19 20140423 ИЗМЕНЕНА ФУНКЦИЯ STDOCINCOMPLETEPALL. ДОБАВЛЕНА ОЧИСТКА ПЕРЕМЕННЫХ ЦИКЛИЧЕСКОГО ВВОДА ПАРТИИ ПОСЛЕ ИНСЕРТА В ТАБЛИЦУ. БОЕВ';
RETURN '1.0.0.19 20140421 ИЗМЕНЕНА ФУНКЦИЯ INPUTNOMBARCODE. ДОБАВЛЕНА ПРОВЕРКА НА ДОСТУП РУЧЧНОГО ВВОДА. ТАРАБЦЕВ';
RETURN '1.0.0.18 20140324 СОЗДАНА ФУНКЦИЯ ALLDIMENSIONSEXISTS. ТАРАБЦЕВ';
RETURN '1.0.0.17 20140321 ИЗМЕНЕНЫ ФУНКЦИЯ INPUTNOMBARCODE, INPUTINDOCNOMCODE - ВЫБИРАЛАСЬ НОМ. ДВАЖДЫ';
RETURN '1.0.0.16 20140305 ИЗМЕНЕНА ФУНКЦИЯ INPUTDATE ДЛЯ СКАНИРОВАНИЯ ДАТЫ ПРИ ПРИЕМКЕ';

--RETURN '1.0.0.15 20140121 В ФУНКЦИЮ INPUTNOMUNIT ДОБАВЛЕНА ПРОВЕРКА НА НАЛИЧИЕ ИЗМЕРЕНИЙ У ВВЕДЕННОЙ ЕДИНИЦЫ КОНВЕРТАЦИИ. ЗАДАЧА=24819';
--RETURN '1.0.0.14 20131107 В ФУНКЦИЮ STDOCINCLOSEDOC ДОБАВЛЕН ВЫЗОВ ПРОЦЕДУРЫ ДЛЯ ФОРМИРОВАНИЯ КЛИЕНТСКОГО СООБЩЕНИЯ О РАСХОЖДЕНИИ. ЗАДАЧА=23616';
--RETURN '1.0.0.13 20131028 НОВЫЕ ФУНКЦИИ SHOWNOMUNIT2ALL INPUTNOMUNITCNT. ЗАДАЧА=23483';
--RETURN '1.0.0.12 2007.12.12 GETVERSION';
--RETURN '1.0.0.1 20061017'; -- ПАКЕТ ДЛЯ РАБОТЫ С ТЕХНОЛОГИЕЙ ШТРИХКОДИРОВАНИЯ
--RETURN '1.0.0.1 20061019 -- ИСПРАВЛЕНА ОШИБКА В WHATONCELLADDRESS НЕБЫЛО ПРОВЕРКИ СТОКА НА SYSDATE';
--   RETURN '1.0.0.2 20061023 -- ПРИ ВВОДЕ ПАЛЛЕТ ID МОЖНО ЕГО ВВОДИТЬ И РУКАМИ!!!';
--   RETURN '1.0.0.3 20061023 -- ИСПРАВЛЕНА ОШИБКА ПРИ ПЕРЕМЕЩЕНИИ ПАЛЛЕТ С ТЕРМИНАЛА ТЕРЯЛСЯ ПАЛЛЕТ ID';
--RETURN '1.0.0.4 20061101 ДОРАБОТКА ПРОЦЕДУРЫ PROC2 27 НЕ ЗАРЕЗЕРВИРОВАНННАЯ КНОПОЧКА';
--RETURN '1.0.0.5 20061105 ВО ВСЕ ПРОЦЕДУРЫ ДОБАВЛЕН ПАРАМЕТР PROBJN, НОВЫЕ ПРОЦЕДУРЫ  SESSIONVARGET SESSIONVARSET';
--RETURN '1.0.0.6 20061107 ИСПРАВЛЕНА ОШИБКА НЕ ЗАПОЛНЕНИЯ  CONTRAGENT_N ПРИ РЕГИСТРАЦИИ ЗАДАНИЯ О ПРИХОДОВАНИИ.';
--RETURN '1.0.0.7 20061108 КОНТРАГЕНТА ЗАПОМИНАЕМ В ПЕРЕМЕННУЮ KK_ST_BARCODE.SESSIONVARSET(PROBJN,CONTRAGENT_N НЕ НЕ С СЕССИЮ';
--RETURN '1.0.0.8 20061109 ДОРАБОТАНА ПРОЦЕДУРА FUNCTION PROC2 БЫЛА МАЛЕНЬКАЯ НЕДОРАБОТКА В ЧАСТИ ОБНУЛЕНИЯ PPROCN';
--RETURN '1.0.0.9 20061127 ВВОД НОМЕРА ПАРТИИ СО СКАНЕРА';
--RETURN '1.0.0.10 20070117 ДОБАВЛЕНА ФУНКЦИЯ GETNOMBYBARCODEX ДЛЯ ОПРЕДЕЛЕНИЯ НОМЕНКЛАТУРЫ ПО ШТРИХКОДУ';
RETURN '1.0.0.11 20071005 ИЗМЕНЕНА ФУНКЦИЯ STDOCINPUTONSTOREJOB ДЛЯ ВЫХОДА В ВЕТКУ АВТОПОПОЛНЕНИЯ ПОДБОРКИ ПРИ РАССТАНОВКЕ ПРИХОДА';

END;

FUNCTION SESSIONVARGET(PROBJN INTEGER,PVARNAME VARCHAR2)RETURN VARCHAR IS
PVARVALUE ST_BARCODE_VARIABLES.VAR_VALUE%TYPE;
BEGIN


SELECT/*+ INDEX_DESC(V ST_BARCODE_VARIABLES_OBJ_TD)*/
   V.VAR_VALUE INTO PVARVALUE
 FROM ST_BARCODE_VARIABLES V
   WHERE V.R_OBJ_N = PROBJN
    AND V.TD = KK_COMMON.GETTD
    AND LOWER(V.VAR_NAME) = LOWER(PVARNAME)
    AND ROWNUM <=1 ;

   RETURN PVARVALUE ;

   EXCEPTION
  WHEN NO_DATA_FOUND THEN

    RETURN NULL;

END SESSIONVARGET;

FUNCTION SESSIONVARSET(PROBJN INTEGER,PVARNAME VARCHAR2,PVARVALUE VARCHAR2)RETURN INTEGER IS
VRET INTEGER;
VRD ROWID;
VDATE DATE := SYSDATE ;
VOLDVALUE ST_BARCODE_VARIABLES.VAR_VALUE%TYPE;
BEGIN

VRET := PROBJN;

IF PROBJN =0 THEN
  INSERT INTO ST_BARCODE_VARIABLES
    (R_OBJ_N , VAR_NAME , VAR_VALUE , FD , TD )
    VALUES
    (SQ_ST_BAR_JOBS_OBJ.NEXTVAL,PVARNAME,PVARVALUE,VDATE,KK_COMMON.GETTD)
    RETURNING R_OBJ_N
    INTO VRET;
ELSE
  BEGIN
    SELECT/*+ INDEX_DESC(V ST_BARCODE_VARIABLES_OBJ_TD)*/
          V.ROWID, V.VAR_VALUE
      INTO VRD, VOLDVALUE
      FROM ST_BARCODE_VARIABLES V
      WHERE V.R_OBJ_N = PROBJN
        AND V.TD = KK_COMMON.GETTD
        AND LOWER(V.VAR_NAME) = LOWER(PVARNAME) ;
    IF   VOLDVALUE IS NULL     AND  PVARVALUE IS NOT NULL
      OR VOLDVALUE IS NOT NULL AND  PVARVALUE IS NULL
      OR VOLDVALUE !=  PVARVALUE
    THEN
      UPDATE ST_BARCODE_VARIABLES
      SET TD = VDATE - 1/86400
        WHERE ROWID = VRD ;
      IF PVARVALUE IS NOT NULL THEN
        INSERT INTO ST_BARCODE_VARIABLES
          (R_OBJ_N , VAR_NAME , VAR_VALUE , FD , TD )
          VALUES
          (PROBJN,PVARNAME,PVARVALUE,VDATE,KK_COMMON.GETTD);
      END IF;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      INSERT INTO ST_BARCODE_VARIABLES
       (R_OBJ_N , VAR_NAME , VAR_VALUE , FD , TD ) VALUES
       (PROBJN,PVARNAME,SUBSTR(PVARVALUE,1,2500),VDATE,KK_COMMON.GETTD);
  END;
END IF;--IF PROBJN IS NULL THEN

RETURN VRET;

END SESSIONVARSET;

PROCEDURE SESSIONVARCLOSE(PROBJN INTEGER,PVARNAME VARCHAR2) IS
BEGIN

UPDATE/*+ INDEX_DESC(V ST_BARCODE_VARIABLES_OBJ_TD_FD)*/
    ST_BARCODE_VARIABLES V
   SET V.TD = SYSDATE
   WHERE V.R_OBJ_N = PROBJN
    AND V.TD = KK_COMMON.GETTD
    AND LOWER(V.VAR_NAME) = LOWER(PVARNAME) ;


END SESSIONVARCLOSE;

FUNCTION  STDOCININBOUNDNEEDINPUTEXPIRE (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VEXPIRE DATE;
    VNEEDINPUTEXPIRE NUMBER;
    VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
BEGIN
-- PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);

PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'BARCODE.INBOUND.EXPIRE',NULL);

SELECT KK_CONST.GETCONSTN('STDOCIN.INBOUND.NEEDINPUTEXPIRE',SYSDATE,VCONTRAGENTN)
    INTO VNEEDINPUTEXPIRE FROM DUAL;

--RAISE_APPLICATION_ERROR(-20001,VNEEDINPUTEXPIRE);
    IF NVL(VNEEDINPUTEXPIRE,0) = 1 THEN RETURN 1; END IF;
    RETURN -1;
EXCEPTION
    WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR(-20001,SQLERRM);
END STDOCININBOUNDNEEDINPUTEXPIRE;

FUNCTION  STDOCININBOUNDINPUTEXPIRE (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VEXPIRE DATE;
BEGIN
    SELECT DECODE(PKEYCODE,'0',KK_COMMON.GETTD,TO_DATE(PKEYCODE,'DDMMYY')) INTO VEXPIRE  FROM DUAL ;

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'BARCODE.INBOUND.EXPIRE', TO_CHAR(VEXPIRE,'DDMMYYYY'));

    RETURN 1;
EXCEPTION
    WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR(-20000, '<ERR>НЕПРАВИЛЬНО ВВЕДЕНА ДАТА! ФОРМАТ DDMMYY ПРИМЕР 260310</ERR>' ||SQLERRM);
END STDOCININBOUNDINPUTEXPIRE;

FUNCTION  STDOCININBOUNDNEEDINPUTMAKE (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VMAKE DATE;
    VNEEDINPUTMAKE NUMBER;
    VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
    VDOCN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
    VNOMN INTEGER :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
    VNOMTYP INTEGER:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
    VNOMSUBTYP INTEGER:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_SUB_TYP');
    VNOMTYPRESPONSE INTEGER:=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP_RESPONSE');
    VUNITCNT INTEGER:= NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_UNIT.UNIT_CNT'),1);
    VPARTNUM INTEGER:=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PART.N');
    VEXPIREDATE DATE:= TO_DATE(KK_ST_BARCODE  .SESSIONVARGET  (PROBJN,'BARCODE.INBOUND.EXPIRE'),'DD.MM.YYYY HH24:MI:SS');
    VPALLN INTEGER:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');
    VEXPIRE INTEGER;
BEGIN

PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'BARCODE.INBOUND.MAKE',NULL);

SELECT KK_CONST.GETCONSTN('STDOCIN.INBOUND.NEEDINPUTMAKE',SYSDATE,VCONTRAGENTN)
  INTO VNEEDINPUTMAKE FROM DUAL;

  SELECT NVL(N.EXPIRE,0) INTO VEXPIRE
    FROM NOMENKLATURA N
  WHERE N.N=VNOMN
    AND N.TD=KK_COMMON.GETTD;

--RAISE_APPLICATION_ERROR(-20001,VEXPIREDATE||'|'||VUNITCNT);
  IF NVL(VNEEDINPUTMAKE,0) = 1 AND NVL(VEXPIRE,0)>0 THEN
      BEGIN
        SELECT NVL(D.MAKE_DATE,KK_COMMON.GETTD)
          INTO VMAKE
        FROM ST_DOC_IN_DET D
        LEFT JOIN ST_NOM_TYP_DET NTD ON (NTD.ST_DOC_TYP = 1 AND NTD.ST_DOC_N = D.N AND NTD.TD = KK_COMMON.GETTD)
        WHERE D.SQ_ST_DOC_IN_N = VDOCN
          AND SYSDATE BETWEEN D.FD AND D.TD
          AND D.TYP = 1
          AND D.NOMENKLATURA_N = VNOMN
          AND D.NOM_TYP = VNOMTYP
          AND NVL(NTD.SUB_NOM_TYP, 0) = NVL(VNOMSUBTYP,0)
          AND NVL(NTD.RESPONSE, 0) = NVL(VNOMTYPRESPONSE,0)
          AND D.PALL_N = VPALLN
          AND D.ST_PART_N = NVL(VPARTNUM,0)
          AND NVL(D.EXPIRE_DATE,KK_COMMON.GETTD) = NVL(VEXPIREDATE,KK_COMMON.GETTD)
          AND NVL(D.UNIT_CNT,1) = VUNITCNT
          AND ROWNUM<2;

        IF VMAKE!=KK_COMMON.GETTD THEN
           RETURN -1;
        ELSE
           RETURN 1;
        END IF;

      EXCEPTION WHEN NO_DATA_FOUND THEN
          RETURN 1;
      END;
  END IF;


    RETURN -1;
EXCEPTION
    WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR(-20001,SQLERRM);
END STDOCININBOUNDNEEDINPUTMAKE;

FUNCTION  STDOCININBOUNDINPUTMAKE (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VMAKE DATE;
BEGIN
    SELECT DECODE(PKEYCODE,'0',KK_COMMON.GETTD,TO_DATE(PKEYCODE,'DDMMYY')) INTO VMAKE  FROM DUAL ;
    IF VMAKE>=SYSDATE THEN
       RAISE_APPLICATION_ERROR(-20000,'ДАТА ПРОИЗВОДСТВА ДОЛЖНА БЫТЬ МЕНЬШЕ ТЕКУЩЕЙ!!!');
    END IF;

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'BARCODE.INBOUND.MAKE', TO_CHAR(VMAKE,'DDMMYYYY'));

    RETURN 1;
EXCEPTION
    WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR(-20000, '<ERR>НЕПРАВИЛЬНО ВВЕДЕНА ДАТА! ФОРМАТ DDMMYY ПРИМЕР 260310</ERR>' ||SQLERRM);
END STDOCININBOUNDINPUTMAKE;



FUNCTION  STDOCININBOUNDQUANTUMCHECK(PNOMN IN INTEGER,PWEIGHT IN NUMBER, PCNT IN INTEGER, PMSG IN OUT VARCHAR2)RETURN INTEGER IS
    VRET INTEGER := -1;
    VWEIGHT_PCT NUMBER;
    VWEIGHT_NETTO NUMBER;
    VIN_WEIGHT NUMBER;
    VPERCENT NUMBER;
BEGIN
 BEGIN
    SELECT
     DECODE(NVL(NU.WEIGHT_NETTO,0),0,1
        ,( GREATEST(NVL(NU.WEIGHT_NETTO,0),(PWEIGHT/ PCNT )) /
          LEAST(NVL(NU.WEIGHT_NETTO,0),(PWEIGHT/ PCNT ))
          - 1)  * 100  )                            AS WEIGHT_PCT
      , NU.WEIGHT_NETTO
      , ROUND(PWEIGHT/ PCNT,2) AS IN_WEIGHT
      , KK_CONST.GETCONSTN('WARNINGPERCENTPALL',SYSDATE, N.CONTRAGENT_N)
      INTO VWEIGHT_PCT,VWEIGHT_NETTO,VIN_WEIGHT, VPERCENT
       FROM NOMENKLATURA N
           LEFT OUTER JOIN NOM_UNIT NU ON (NU.NOMENKLATURA_N = N.N AND  KK_CONST.GETCONSTV('CONTRAGENT.USEWEIGHT.NOMUNIT',SYSDATE,N.CONTRAGENT_N) LIKE '%,'||NU.UNIT_TYP ||',%'  AND SYSDATE BETWEEN NU.FD AND NU.TD )
     WHERE
        N.N = PNOMN
        AND SYSDATE BETWEEN N.FD AND N.TD;
  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20000,'НЕ НАЙДЕНА ЕД КОНВЕРТАЦИИ НОМЕНКЛАТУРЫ  '||PNOMN ||
                            ' КОНВ ИЗ КОНСТАНТЫ CONTRAGENT.USEWEIGHT.NOMUNIT'
                            ||PWEIGHT||' '||PCNT||' '||SQLERRM);
  END;

    IF ABS(VWEIGHT_PCT) >= VPERCENT
       -- AND NVL(KK_PROP_ITEMS.GETITEMVALUEBYALIAS(PITEMN => 0,POBJN => J.DOCDETN,PDATE => SYSDATE ,PALIASNAME => 'STDOCINDET.QUANTUMWEIGHTDIFF',PTYP => 16),'0') = '0'
    THEN
      VRET:= 3;
      PMSG := PMSG||'ВВЕДЁН ВЕС='||PWEIGHT||'; ВЕС ПО КВАНТУ='||PCNT*VWEIGHT_NETTO||'; ПРОЦЕНТ РАСХОЖДЕНИЯ='||ROUND(VWEIGHT_PCT, 2);
    ELSE VRET := 0;
    END IF;
    --RAISE_APPLICATION_ERROR(-20001,VRET);
    RETURN VRET;
END STDOCININBOUNDQUANTUMCHECK;

FUNCTION  STDOCININBOUNDQUANTUMCOMPLITE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER) RETURN INTEGER IS
NOREQUESTWEIGHT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOREQUESTWEIGHT');
VWEIGHT_NETTO NUMBER;
VWEIGHT_BRUTTO NUMBER;
VRET INTEGER;
BEGIN

    IF NOREQUESTWEIGHT = 1 AND (VWEIGHT_NETTO <= 0 AND  VWEIGHT_BRUTTO <= 0 ) THEN
    VRET := 2;
     ELSE VRET:=1;
    END IF;

    RETURN VRET;
END STDOCININBOUNDQUANTUMCOMPLITE;




FUNCTION CLEARNULLTERMINATEDSTRING(PSTR VARCHAR2) RETURN VARCHAR2 IS
VRET VARCHAR2(2000);
BEGIN

SELECT DECODE(INSTR(PSTR, CHR(0)),0,PSTR,SUBSTR(PSTR,1,INSTR(PSTR, CHR(0))-1))
 INTO VRET FROM DUAL;

RETURN VRET;

END;

FUNCTION GETPALLTYPE(PWHO INTEGER,PTYP INTEGER ,PX INTEGER ,PY INTEGER ,PZ INTEGER,PBASETYPE INTEGER DEFAULT 0 ) RETURN INTEGER IS
VN INTEGER;

FUNCTION CREATEPALLTYPE  RETURN INTEGER IS
VRET INTEGER;
 BEGIN

BEGIN
SELECT N INTO VRET
 FROM PALL_TYPE
 WHERE TYP = PTYP
  AND  NVL(X,0) = NVL(PX,0)
  AND  NVL(Y,0) = NVL(PY,0)
  AND  NVL(Z,0) = NVL(PZ,0)
  AND  BASE = PBASETYPE ;

 EXCEPTION
  WHEN NO_DATA_FOUND THEN
    INSERT INTO PALL_TYPE
        (N, FD, TYP, X, Y, Z, BASE)
     VALUES
       (SQ_PALL_TYPE.NEXTVAL, SYSDATE, PTYP, NVL(PX,0), NVL(PY,0), NVL(PZ,0),PBASETYPE)
       RETURNING N INTO  VRET;

       KK_COMMON.ACTION(PWHO,'PALL_TYPE',VRET,1,SYSDATE) ;

  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    KK_COMMON.ERR_LOG('CREATEPALLTYPE',SQLCODE,PTYP||' '||NVL(PX,0)||' '||NVL(PY,0)||' '||NVL(PZ,0)||' '||PBASETYPE||' '|| SQLERRM);
  RAISE;

 END;

 RETURN VRET;

 END CREATEPALLTYPE;
BEGIN

BEGIN


 SELECT  N INTO VN
  FROM PALL_TYPE
 WHERE TYP = PTYP
   AND (   (    X = NVL (PX, 0)
            AND Y = NVL (PY, 0)
            AND Z = NVL (PZ, 0)
            AND (NVL (PX, 0) > 0 OR NVL (PY, 0) > 0 OR NVL (PZ, 0) > 0)
           )
        OR (    NVL (PX, 0) = 0
            AND NVL (PY, 0) = 0
            AND NVL (PZ, 0) = 0
            AND BASE = 1
           )
       )
   AND SYSDATE BETWEEN FD AND TD
   AND ROWNUM <2;


 EXCEPTION
    WHEN NO_DATA_FOUND THEN

    IF   PBASETYPE = 1  THEN
     BEGIN
           SELECT N INTO VN  FROM PALL_TYPE
              WHERE  TYP = PTYP
                  AND BASE = PBASETYPE
                  AND SYSDATE BETWEEN FD AND TD;

        EXCEPTION
         WHEN NO_DATA_FOUND THEN
                VN :=CREATEPALLTYPE;
     END;
    ELSE
     VN :=CREATEPALLTYPE;
    END IF;


END;

RETURN VN;
END;

FUNCTION OF39SRC(VSTR VARCHAR2) RETURN VARCHAR2 IS
VSRC INTEGER := 0;
VRET VARCHAR2(50);
BEGIN

  FOR J IN 1..LENGTH(VSTR) LOOP

CASE WHEN SUBSTR(VSTR,J,1) ='0' THEN VSRC := VSRC + 0;
     WHEN SUBSTR(VSTR,J,1) ='1' THEN VSRC := VSRC + 1;
     WHEN SUBSTR(VSTR,J,1) ='2' THEN VSRC := VSRC + 2;
     WHEN SUBSTR(VSTR,J,1) ='3' THEN VSRC := VSRC + 3;
     WHEN SUBSTR(VSTR,J,1) ='4' THEN VSRC := VSRC + 4;
     WHEN SUBSTR(VSTR,J,1) ='5' THEN VSRC := VSRC + 5;
     WHEN SUBSTR(VSTR,J,1) ='6' THEN VSRC := VSRC + 6;
     WHEN SUBSTR(VSTR,J,1) ='7' THEN VSRC := VSRC + 7;
     WHEN SUBSTR(VSTR,J,1) ='8' THEN VSRC := VSRC + 8;
     WHEN SUBSTR(VSTR,J,1) ='9' THEN VSRC := VSRC + 9;
     WHEN SUBSTR(VSTR,J,1) ='A' THEN VSRC := VSRC + 10;
     WHEN SUBSTR(VSTR,J,1) ='B' THEN VSRC := VSRC + 11;
     WHEN SUBSTR(VSTR,J,1) ='C' THEN VSRC := VSRC + 12;
     WHEN SUBSTR(VSTR,J,1) ='D' THEN VSRC := VSRC + 13;
     WHEN SUBSTR(VSTR,J,1) ='E' THEN VSRC := VSRC + 14;
     WHEN SUBSTR(VSTR,J,1) ='F' THEN VSRC := VSRC + 15;
     WHEN SUBSTR(VSTR,J,1) ='G' THEN VSRC := VSRC + 16;
     WHEN SUBSTR(VSTR,J,1) ='H' THEN VSRC := VSRC + 17;
     WHEN SUBSTR(VSTR,J,1) ='I' THEN VSRC := VSRC + 18;
     WHEN SUBSTR(VSTR,J,1) ='J' THEN VSRC := VSRC + 19;
     WHEN SUBSTR(VSTR,J,1) ='K' THEN VSRC := VSRC + 20;
     WHEN SUBSTR(VSTR,J,1) ='L' THEN VSRC := VSRC + 21;
     WHEN SUBSTR(VSTR,J,1) ='M' THEN VSRC := VSRC + 22;
     WHEN SUBSTR(VSTR,J,1) ='N' THEN VSRC := VSRC + 23;
     WHEN SUBSTR(VSTR,J,1) ='O' THEN VSRC := VSRC + 24;
     WHEN SUBSTR(VSTR,J,1) ='P' THEN VSRC := VSRC + 25;


     WHEN SUBSTR(VSTR,J,1) ='Q' THEN VSRC := VSRC + 26;
     WHEN SUBSTR(VSTR,J,1) ='R' THEN VSRC := VSRC + 27;
     WHEN SUBSTR(VSTR,J,1) ='S' THEN VSRC := VSRC + 28;
     WHEN SUBSTR(VSTR,J,1) ='T' THEN VSRC := VSRC + 29;
     WHEN SUBSTR(VSTR,J,1) ='U' THEN VSRC := VSRC + 30;
     WHEN SUBSTR(VSTR,J,1) ='V' THEN VSRC := VSRC + 31;
     WHEN SUBSTR(VSTR,J,1) ='W' THEN VSRC := VSRC + 32;
     WHEN SUBSTR(VSTR,J,1) ='X' THEN VSRC := VSRC + 33;
     WHEN SUBSTR(VSTR,J,1) ='Y' THEN VSRC := VSRC + 34;
     WHEN SUBSTR(VSTR,J,1) ='Z' THEN VSRC := VSRC + 35;
     WHEN SUBSTR(VSTR,J,1) ='-' THEN VSRC := VSRC + 36;
     WHEN SUBSTR(VSTR,J,1) ='.' THEN VSRC := VSRC + 37;
     WHEN SUBSTR(VSTR,J,1) =' ' THEN VSRC := VSRC + 38;
     WHEN SUBSTR(VSTR,J,1) ='$' THEN VSRC := VSRC + 39;
     WHEN SUBSTR(VSTR,J,1) ='/' THEN VSRC := VSRC + 40;
     WHEN SUBSTR(VSTR,J,1) ='+' THEN VSRC := VSRC + 41;
     WHEN SUBSTR(VSTR,J,1) ='%' THEN VSRC := VSRC + 42;
     ELSE                            VSRC := VSRC + 0 ;
   END CASE;

  END LOOP; --  FOR J IN 1..LENGTH(VSTR) LOOP

  VSRC := MOD(VSRC,43);

  CASE
WHEN VSRC =0 THEN VRET := VSTR || '0' ;
WHEN VSRC =1 THEN VRET := VSTR || '1' ;
WHEN VSRC =2 THEN VRET := VSTR || '2' ;
WHEN VSRC =3 THEN VRET := VSTR || '3' ;
WHEN VSRC =4 THEN VRET := VSTR || '4' ;
WHEN VSRC =5 THEN VRET := VSTR || '5' ;
WHEN VSRC =6 THEN VRET := VSTR || '6' ;
WHEN VSRC =7 THEN VRET := VSTR || '7' ;
WHEN VSRC =8 THEN VRET := VSTR || '8' ;
WHEN VSRC =9 THEN VRET := VSTR || '9' ;
WHEN VSRC =10 THEN VRET := VSTR || 'A' ;
WHEN VSRC =11 THEN VRET := VSTR || 'B' ;
WHEN VSRC =12 THEN VRET := VSTR || 'C' ;
WHEN VSRC =13 THEN VRET := VSTR || 'D' ;
WHEN VSRC =14 THEN VRET := VSTR || 'E' ;
WHEN VSRC =15 THEN VRET := VSTR || 'F' ;
WHEN VSRC =16 THEN VRET := VSTR || 'G' ;
WHEN VSRC =17 THEN VRET := VSTR || 'H' ;
WHEN VSRC =18 THEN VRET := VSTR || 'I' ;
WHEN VSRC =19 THEN VRET := VSTR || 'J' ;
WHEN VSRC =20 THEN VRET := VSTR || 'K' ;
WHEN VSRC =21 THEN VRET := VSTR || 'L' ;
WHEN VSRC =22 THEN VRET := VSTR || 'M' ;
WHEN VSRC =23 THEN VRET := VSTR || 'N' ;
WHEN VSRC =24 THEN VRET := VSTR || 'O' ;
WHEN VSRC =25 THEN VRET := VSTR || 'P' ;
WHEN VSRC =26 THEN VRET := VSTR || 'Q' ;
WHEN VSRC =27 THEN VRET := VSTR || 'R' ;
WHEN VSRC =28 THEN VRET := VSTR || 'S' ;
WHEN VSRC =29 THEN VRET := VSTR || 'T' ;
WHEN VSRC =30 THEN VRET := VSTR || 'U' ;
WHEN VSRC =31 THEN VRET := VSTR || 'V' ;
WHEN VSRC =32 THEN VRET := VSTR || 'W' ;
WHEN VSRC =33 THEN VRET := VSTR || 'X' ;
WHEN VSRC =34 THEN VRET := VSTR || 'Y' ;
WHEN VSRC =35 THEN VRET := VSTR || 'Z' ;
WHEN VSRC =36 THEN VRET := VSTR || '-' ;
WHEN VSRC =37 THEN VRET := VSTR || '.' ;
WHEN VSRC =38 THEN VRET := VSTR || ' ' ;
WHEN VSRC =39 THEN VRET := VSTR || '$' ;
WHEN VSRC =40 THEN VRET := VSTR || '/' ;
WHEN VSRC =41 THEN VRET := VSTR || '+' ;
WHEN VSRC =42 THEN VRET := VSTR || '%' ;
  END CASE;




 RETURN VRET;

END;

FUNCTION EAN13SRC(VSTR VARCHAR2) RETURN INTEGER IS
VSRC INTEGER := 0;
VSRC1 INTEGER := 0;
BEGIN

 VSRC := TO_NUMBER(SUBSTR(VSTR,2,1)) +
         TO_NUMBER(SUBSTR(VSTR,4,1)) +
         TO_NUMBER(SUBSTR(VSTR,6,1)) +
         TO_NUMBER(SUBSTR(VSTR,8,1)) +
         TO_NUMBER(SUBSTR(VSTR,10,1)) +
         TO_NUMBER(SUBSTR(VSTR,12,1));

 VSRC := VSRC * 3;

 VSRC1 := TO_NUMBER(SUBSTR(VSTR,1,1)) +
          TO_NUMBER(SUBSTR(VSTR,3,1)) +
          TO_NUMBER(SUBSTR(VSTR,5,1)) +
          TO_NUMBER(SUBSTR(VSTR,7,1)) +
          TO_NUMBER(SUBSTR(VSTR,9,1)) +
          TO_NUMBER(SUBSTR(VSTR,11,1));

  SELECT DECODE(VSRC+VSRC1 ,0 ,0, 10 - MOD(VSRC+VSRC1,10) ) INTO VSRC FROM DUAL ;
   SELECT DECODE(VSRC ,0 ,0, 10,0 , VSRC ) INTO VSRC FROM DUAL ;
 RETURN VSRC;


END EAN13SRC;


FUNCTION STRINGTOBARCODE13(VSTR VARCHAR2) RETURN VARCHAR2 IS
 TYPE VARRAY_TYPE IS VARRAY(12) OF INTEGER;
 VBARLEN INTEGER := 12;
 VPOS INTEGER := 0;
 VCODE VARRAY_TYPE;
 VCODEX VARCHAR2(12) := '';
BEGIN


    VCODE := VARRAY_TYPE(0,0,0,0,0,0,0,0,0,0,0,0);

    FOR J IN 1..LENGTH(VSTR) LOOP
       SELECT DECODE (MOD(VPOS+1,12),0,1,MOD(VPOS+1,12)) INTO VPOS FROM DUAL ;
       VCODE(VPOS) :=  MOD(ASCII(SUBSTR(VSTR,J,1)) + TO_NUMBER(VCODE(VPOS)),10);

    END LOOP;



  FOR J IN 1..12 LOOP
     VCODEX := VCODEX || TO_CHAR(VCODE(J));
  END LOOP;


 RETURN VCODEX || EAN13SRC(VCODEX);


END;

  FUNCTION DOUBLESTRING(PIN VARCHAR2) RETURN VARCHAR2 IS
   BEGIN
    RETURN  RPAD(PIN,LENGTH(PIN)*2,' ');
   END;


FUNCTION  EMPLOGON(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER;
VNAME VARCHAR2(255);
VEMPN INTEGER;
VTERMINALN INTEGER;
VIP VARCHAR2(50) :=  SYS_CONTEXT('USERENV','IP_ADDRESS');
VCNT INTEGER;
VOPTION VARCHAR2(255);
VUSERNAME VARCHAR2(255);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
SELECT TO_NUMBER(REPLACE(PSTR,'E-','') ) INTO  VEMPN FROM DUAL;


    SELECT/*+ INDEX(A CIS_LOGON_LOG_S)*/
     MIN(S.USERNAME),  SUM(DECODE(A.AUDSID ,NULL,0,1)) INTO VUSERNAME, VCNT
      FROM
   V$SESSION S
    JOIN V$PROCESS P ON (S.PADDR = P.ADDR )
   LEFT OUTER JOIN  CIS_LOGON_LOG A ON (  A.AUDSID = S.AUDSID  AND A.SESSIONID = S.SID AND A.SERIAL = S.SERIAL# )
  WHERE A.WHO = 1
  AND  S.AUDSID != SYS_CONTEXT('USERENV', 'SESSIONID')
  AND S.STATUS != 'KILLED'
  AND LOWER(S.TERMINAL) = 'MOBILE';

  IF VCNT > 0 THEN
  RAISE_APPLICATION_ERROR(-20000,'ВХОД В СИСТЕМУ ПОД ПОЛЬЗОВАТЕЛЕМ "'||PSTR||'" УЖЕ ПРОИЗВЕДЕН!');
  END IF;

SELECT   NAME INTO PMSG
  FROM PRM_USERS WHERE
         N = VEMPN
     AND BAR_PWD =PKEYCODE
     AND SYSDATE BETWEEN FD AND TD ;

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'EMP_N',VEMPN);




   VTERMINALN := 0;


   PMSG := PMSG    ||  ' E-' ||VEMPN|| V1310 ||VUSERNAME
   || V1310 ||VIP
   ;

--   KK_COMMON.ACTION(VEMPN,'LOGON',0,1,SYSDATE);
   KK_TRACE.LOGON(VEMPN);

  IF KK_PERMIT.EXISTSPERMIT(VEMPN,'STBARCODENODEAFTERLOGON',SYSDATE,VOPTION ) =3 THEN
   BEGIN
      PNEXTNODE :=  NVL(VOPTION,18) ;
     RETURN 0;
   EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   RETURN 1;
   END;
  END IF;

RETURN 1;

EXCEPTION
    WHEN OTHERS THEN
     KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN,'EMP_N');
    PMSG :=  '<ERR>ВЫ НЕ ИДЕНТИФИЦИРОВАНЫ!!! ' ||  PSTR  ||  ' '
     || PKEYCODE||  V1310
     ||VIP|| V1310
     || VUSERNAME||'</ERR>'||SQLERRM ;

    RETURN -1;
END EMPLOGON;


FUNCTION STDOCINCLOSEDOC2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER;
VDOC INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VSTATUS INTEGER;
VRD ROWID;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
BEGIN


BEGIN
          SELECT STATUS,ROWID INTO VSTATUS,VRD
              FROM ST_DOC_IN
            WHERE
                 N = VDOC
             AND SYSDATE BETWEEN FD AND TD
             FOR UPDATE NOWAIT;


             IF VSTATUS NOT IN (1,2,3)/*DIC 366 SUBMITED*/ THEN
                 PMSG := 'ДОКУМЕНТ ДОЛЖЕН БЫТЬ В СТАТУСЕ: ЧЕРНОВИК, ПРИНЯТ, ПОДТВЕРЖДЕН!366';
                 VRET := -1;
              ELSE
                  UPDATE ST_DOC_IN
                 SET STATUS = 5
                  WHERE ROWID = VRD;

                  KK_ST_STATUS_CHANGE.STDOCIN(VDOC,VSTATUS,5,VEMPN);
                 KK_COMMON.ACTION(VEMPN,'ST_DOC_IN',VDOC,3,SYSDATE, 'STDOCINCLOSEDOC2 СТАТУС =5');

                 PPROCN :=0;
                 VRET := 1;
              END IF;




EXCEPTION
   WHEN NO_DATA_FOUND THEN
         PMSG :='АКТ НЕ НАЙДЕН! PPROCN=' ||PPROCN;
      VRET := -1;
END;


RETURN VRET;

END;

FUNCTION STDOCINCLOSEDOC(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER;
VDOC INTEGER;
VSTATUS INTEGER;
VRD ROWID;
VDOCTYP INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VCONTRAGENTN INTEGER;
VMSGPROC VARCHAR2(255);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

BEGIN

  SELECT VAL1 INTO VDOC FROM (
    SELECT VAL1, MIN(LEVEL) OVER () AS MIN_LEVEL, LEVEL AS LEVEL_
                  FROM MCIS_NODES_PROC P
                  WHERE TYP = 2
                    CONNECT BY PRIOR P.UP = P.N
                      START WITH N = PPROCN)
  WHERE MIN_LEVEL = LEVEL_;

         BEGIN

          SELECT STATUS,ROWID INTO VSTATUS,VRD
              FROM ST_DOC_IN
            WHERE
                 N = VDOC
             AND SYSDATE BETWEEN FD AND TD
             FOR UPDATE NOWAIT;


             IF VSTATUS NOT IN (1,2,3)/*DIC 366 SUBMITED*/ THEN
                 PMSG := 'ДОКУМЕНТ ДОЛЖЕН БЫТЬ В СТАТУСЕ: ЧЕРНОВИК, ПРИНЯТ, ПОДТВЕРЖДЕН!366';
                 VRET := -1;
              ELSE



        SELECT SUBSTR(STRAGG_SEP(T_STR_SEP(CODE || ' '|| ST_PALL_N,CHR(13)||CHR(10))),1,2000) , COUNT(DIFF) AS DIFF
          INTO PMSG , VDOCTYP
         FROM (
            SELECT D.NOMENKLATURA_N , N.CODE ,                 CASE WHEN SUM(DECODE(D.TYP,1,NVL(D.CNT_IN,0)+NVL(D.CNT_BRAK,0),0)) !=
                              SUM(DECODE(D.TYP,0,NVL(D.CNT_IN,0)+NVL(D.CNT_BRAK,0),0)) THEN 1 ELSE 0 END AS DIFF
                   ,  STRAGG(  DECODE(D.TYP,1,'P-'||D.PALL_N,NULL)  ) AS ST_PALL_N
                   FROM ST_DOC_IN_DET D
                     JOIN NOMENKLATURA N ON (N.N = D.NOMENKLATURA_N AND SYSDATE BETWEEN N.FD AND N.TD)
                WHERE 1=1
                AND  D.SQ_ST_DOC_IN_N = VDOC
                        AND SYSDATE BETWEEN D.FD AND D.TD
                    GROUP BY D.NOMENKLATURA_N , N.CODE
              ) WHERE DIFF = 1       ;

                 IF VDOCTYP > 0 THEN
                    BEGIN
                        SELECT CONTRAGENT_N INTO VCONTRAGENTN FROM ST_DOC_IN WHERE SYSDATE BETWEEN FD AND TD AND N = VDOC;
                        VMSGPROC := KK_CONST.GETCONSTV('STDOCINDIFFCLOSEMSGPROC',SYSDATE,VCONTRAGENTN,0);
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                         VMSGPROC := '_';
                     END;
                    IF VMSGPROC != '_' THEN
                        EXECUTE IMMEDIATE 'BEGIN '||VMSGPROC||'('||VDOC||',:PMSG);END;'
                         USING IN OUT PMSG;
                    ELSE
                        PMSG := 'ЕСТЬ РАСХОЖДЕНИЯ!!'||V1310 || PMSG;
                    END IF;
                    VRET := 2;
                 ELSE

                  UPDATE ST_DOC_IN
                 SET STATUS = 5
                  WHERE ROWID = VRD;

                  KK_ST_STATUS_CHANGE.STDOCIN(VDOC,VSTATUS,5,VEMPN);
                 KK_COMMON.ACTION(VEMPN,'ST_DOC_IN',VDOC,121,SYSDATE, 'STDOCINCLOSEDOC СТАТУС =5');

                 PPROCN :=0;
                 VRET := 1;

                  END IF;



              END IF;



          EXCEPTION
             WHEN NO_DATA_FOUND THEN
                 PMSG := 'АКТ НЕ НАЙДЕН! VDOC=' ||VDOC;
                VRET := -1;
          END;


EXCEPTION
   WHEN NO_DATA_FOUND THEN
         PMSG :='АКТ НЕ НАЙДЕН! PPROCN=' ||PPROCN;
      VRET := -1;
END;


RETURN VRET;

END;



FUNCTION  INPUTINDOCNUM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
 VINPUTINDOCNUMPROC VARCHAR2(255);
 VRET INTEGER;
BEGIN

 VINPUTINDOCNUMPROC:= NVL(KK_CONST.GETCONSTV('INPUTINDOCNUM.USERPROC',SYSDATE, NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0)),'_');
  IF NVL(VINPUTINDOCNUMPROC, '_') = '_'  THEN
        VRET := KK_ST_BARCODE.INPUTINDOCNUM_DEF(PKEYCODE,PSTR, PMSG,PNEXTNODE,PPROCN,PROBJN);
     ELSE
        EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VINPUTINDOCNUMPROC||'(:PKEYCODE,:PSTR ,:PMSG ,:PNEXTNODE,:PPROCN,:PROBJN);  END;'
  USING OUT VRET, IN PKEYCODE, IN PSTR, IN OUT PMSG, IN OUT PNEXTNODE,IN OUT PPROCN,IN OUT PROBJN;
     END IF;

RETURN VRET;

END;

FUNCTION  INPUTINDOCNUM_DEF(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VCONTRAGENTN INTEGER;
VRET INTEGER;
VSTATUS INTEGER;
VSTOREN INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VACCESSSTATUSLIST PRM_CORRS.OPTIONS%TYPE :=KK_PERMIT.EXISTSPERMIT(VEMPN,'STDOCINCHANGEONOTHERSTATUS',SYSDATE);
VACCESSADDSTATUSLIST PRM_CORRS.OPTIONS%TYPE :=KK_PERMIT.EXISTSPERMIT(VEMPN,'STDOCINADDONOTHERSTATUS',SYSDATE);
VUNLOAD_END DATE;
BEGIN
  IF PSTR IS NULL AND PKEYCODE != '0' AND NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN, 'STBARCODEMANUALINPUTINDOCNUM',SYSDATE), -1) !=3 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>СКАНИРУЙТЕ ДОКУМЕНТ, РУЧНОЙ ВВОД ЗАПРЕЩЕН!</ERR>');
  END IF;


--RAISE_APPLICATION_ERROR(-20000,'PSTR='||PSTR||', PKEYCODE='||PKEYCODE);

FOR J IN (

 SELECT * FROM
 (
 SELECT/*+ ORDERED*/ 'АКТ №' || D.NUM_ACT ||' КЛИЕНТ ' ||C.BRIEF  AS NUM
     , D.N
     ,D.CONTRAGENT_N
     ,D.STATUS
     ,S.STORE_N
     ,NVL(D.EMP_N,0)  AS EMP_N
     ,COUNT(1) OVER () AS CNT
     ,ROW_NUMBER() OVER (ORDER BY NVL(D.EMP_N,0) DESC /*СПЕРВА НАЗНАЧЕННЫЕ*/, NVL(D.PRIORITY,0) DESC,D.FD,D.N) AS RN
      FROM
       ST_DOC_IN D
        JOIN CONTRAGENT C ON ( SYSDATE BETWEEN C.FD AND C.TD AND D.CONTRAGENT_N = C.N)
        JOIN ST_DOC_OUT_STORE S ON (S.N = D.TYP AND SYSDATE BETWEEN S.FD AND S.TD)
      WHERE 1=1
       AND ( D.N = TO_NUMBER(NVL(PSTR,PKEYCODE))
            OR (D.NUM_ACT = TO_CHAR(TO_NUMBER(NVL(PSTR,PKEYCODE))) AND PKEYCODE != '0')
            OR PKEYCODE = '0'  AND NVL(D.EMP_N,0) = NVL(VEMPN,0)
            OR PKEYCODE = '0'  AND NVL(D.EMP_N,0) = 0 AND D.FD >= SYSDATE - 10
            )
       AND SYSDATE BETWEEN D.FD AND D.TD
       AND D.STATUS != 4 -- ПРИХОДОВАН
       AND (INSTR(','||VACCESSSTATUSLIST||',',','||D.STATUS||',') > 0 OR VACCESSSTATUSLIST = '0' )
  )
  WHERE RN = 1

       ) LOOP


     --  IF J.CNT > 1 THEN
     --   RAISE_APPLICATION_ERROR(-20000,'ПО НОМЕРУ "'||TO_CHAR(TO_NUMBER(NVL(PSTR,PKEYCODE)))||'" НАЙДЕНО БОЛЕЕ ОДНОГО ДОКУМЕНТА! УТОЧНИТЕ ПОЖАЛУЙСТА!');
     --  END IF;

       PMSG  := J.NUM ;
       VN := J.N ;
       VCONTRAGENTN := J.CONTRAGENT_N ;
       VSTATUS := J.STATUS ;
       VSTOREN := J.STORE_N ;

       IF J.EMP_N = 0 THEN

        SELECT N INTO VN
         FROM ST_DOC_IN
          WHERE N = J.N
          AND SYSDATE BETWEEN FD AND TD
          FOR UPDATE NOWAIT;

        UPDATE ST_DOC_IN
         SET EMP_N= VEMPN
          WHERE N = J.N
          AND SYSDATE BETWEEN FD AND TD;
          KK_COMMON.ACTION(VEMPN,'ST_DOC_IN',J.N,120,SYSDATE,'ЗАКРЕПИЛ ДОКУМЕНТ ЗА СОБОЙ INPUTINDOCNUM');
       END IF;

       IF J.STATUS = 1 THEN
        UPDATE ST_DOC_IN
         SET STATUS = 2
          WHERE N = J.N
          AND SYSDATE BETWEEN FD AND TD;
          KK_COMMON.ACTION(VEMPN,'ST_DOC_IN',J.N,3,SYSDATE,'STATUS=2');

       END IF;

      EXIT WHEN TRUE;

END LOOP;

 IF NVL(VN,0) = 0 THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ДОКУМЕНТ В ПОДХОДЯЩЕМ СТАТУСЕ НЕ НАЙДЕН *' ||  PSTR  ||  '* *' || PKEYCODE||  '* ИЛИ
   НЕ НАСТРОЕН ДОСТУП STDOCINCHANGEONOTHERSTATUS="'||VACCESSSTATUSLIST||'"</ERR>' );
 END IF;

DECLARE
 VPROC LIST_CONST.VAL%TYPE;
BEGIN

 SELECT KK_CONST.GETCONSTV('STDOCINCHEQUE.USERPROC',SYSDATE,VCONTRAGENTN)  INTO VPROC
  FROM ST_DOC_IN
   WHERE N = VN
    AND SYSDATE BETWEEN FD AND TD
    AND ROWNUM = 1;

IF NVL(VPROC,'_') != '_' THEN
 EXECUTE IMMEDIATE 'BEGIN '||VPROC||'(:VN); END;'
  USING IN VN;
END IF;


END;

PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);
PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STORE_N',VSTOREN);
PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_IN.N',VN);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP,VAL4 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,2/*ЗАПОМНИЛИ НОМЕР АКТА*/,VN,VCONTRAGENTN,VSTOREN,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ ПРИХОДНЫЙ АКТ INPUTINDOCNUM',0,PMSG)
   RETURNING N INTO PPROCN;
/*
366 1                                       ЧЕРНОВИК
366 2                                       ПРИНЯТ
366 3                                       ПОДТВЕРЖДЕН
366 4                                       ПРИХОДОВАН НА СКЛАД
366 5                                       ПРИНЯТ ПО ФАКТУ
366 6                                       РАЗМЕЩЕНИЕ ПО АДРЕСАМ
*/
IF (VACCESSADDSTATUSLIST LIKE '%,'||VSTATUS||',%') OR  (NVL(VACCESSADDSTATUSLIST, 0) ='0') THEN
  VRET := 1;
  ELSE
  PMSG := 'СТАТУС АКТА НЕ ПОЗВОЛЯЕТ ЕГО РЕДАКТИРОВАТЬ! АКТ ДОЛЖЕН БЫТЬ В СТАТУСЕ "ЧЕРНОВИК" ИЛИ "ПРИНЯТ" ' || PMSG;
  VRET := 2;
END IF;


RETURN VRET;

/*EXCEPTION
 -- WHEN NO_DATA_FOUND THEN
 --       PMSG :=  '<ERR>ДОКУМЕНТ НЕ НАЙДЕН *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>' ||SQLERRM;
 --       RETURN -1;
    WHEN OTHERS THEN
        PMSG :=  '<ERR>ОШИБКА INPUTINDOCNUM *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>' ||SQLERRM;
    RETURN -1;*/
END;

FUNCTION  STDOCINACTPRINTOUT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VSTOREN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'STORE_N');
VDOCN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VPRINTERN INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VREPMODULE VARCHAR2(255);
BEGIN

BEGIN
  SELECT CASE WHEN INSTR(LOWER(PSTR),'PR-') = 1 THEN TO_NUMBER(SUBSTR(PSTR,4)) ELSE 0 END INTO VPRINTERN FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    VPRINTERN := 0;
END;



IF NVL(VPRINTERN,0) = 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПРИНТЕР!</ERR>');
END IF;

BEGIN
 SELECT N INTO VPRINTERN
  FROM R_PRINTERS
   WHERE N = VPRINTERN
    AND SYSDATE BETWEEN FD AND TD;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ПРИНТЕР НЕ ЗАРЕГИСТРИРОВАН В СИСТЕМЕ! PR-'||VPRINTERN||'</ERR>');
END;

 VREPMODULE := KK_CONST.GETCONSTV('STDOCINACTREPMODULENAME',SYSDATE,VCONTRAGENTN);

    KK_R.BUILDPRINTJOBTYP(VEMPN,VPRINTERN,1/*:PDOCTYP*/,0/*PLOCAL*/,VDOCN,VREPMODULE||'.DLL','PDOCN='||VDOCN||';COPIES=1;PCONTRAGENTN='||VCONTRAGENTN||';PNOMENKLATURAN=0;PWHO='||VEMPN);
   PMSG := '<ERR>ВОЗЬМИТЕ ОТЧЕТ НА ПРИНТЕРЕ!</ERR>';


 RETURN 1;
END STDOCINACTPRINTOUT;

FUNCTION  INPUTPALLCODE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
VCNT INTEGER;
VKEYCODE VARCHAR2(50);
VOPT VARCHAR2(50);
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VSTBARCODEMANUALPIDINPUT INTEGER := KK_PERMIT.EXISTSPERMIT(VEMPN,'STBARCODEMANUALPIDINPUT',SYSDATE);
VALLOWPID0 INTEGER := KK_CONST.GETCONSTN('ALLOWPID0',SYSDATE);
VCHECKPROC VARCHAR2(100) := '_';
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
BEGIN

-- ПРОВЕРКА ДОСТУПА (В ЗАГОЛОВКЕ ВЫБИРАЕТСЯ OPTIONS)
VSTBARCODEMANUALPIDINPUT :=KK_PERMIT.EXISTSPERMIT(VEMPN,'STBARCODEMANUALPIDINPUT',SYSDATE,VOPT);

--RAISE_APPLICATION_ERROR(-20001,PSTR||'-'||PKEYCODE);
IF VSTBARCODEMANUALPIDINPUT != 3 THEN
     IF PSTR IS NULL AND PKEYCODE != '0' THEN
      RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ PID, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
     ELSE
        IF PKEYCODE = '0'
            THEN    VKEYCODE := PKEYCODE;
            ELSE    VKEYCODE := NULL;
        END IF;
     END IF;
ELSE
     VKEYCODE := PKEYCODE;
END IF;

SELECT CASE WHEN INSTR(
 DECODE(VKEYCODE,NULL,PSTR, 'P-'||VKEYCODE)
 ,'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(
  DECODE(VKEYCODE,NULL,PSTR, 'P-'||VKEYCODE)

 ,'P-','') ) INTO  VPALLN FROM DUAL;

IF NVL(VKEYCODE,'_') != '0' THEN
SELECT COUNT(1) INTO VCNT
 FROM
 PALL P
  WHERE P.N =VPALLN
   AND SYSDATE BETWEEN P.FD AND P.TD ;

IF VCNT != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>PID В СИСТЕМЕ НЕ ЗАРЕГИСТРИРОВАН!'|| VPALLN||'</ERR>');
END IF;

END IF; --IF NVL(VKEYCODE,'_') != '0' THEN

IF VPALLN = 0 AND VALLOWPID0 != 1  THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>PID = 0 НЕ ДОПУСТИМ!'|| VPALLN||'</ERR>');
END IF;

BEGIN
  VCHECKPROC  :=  KK_CONST.GETCONSTV('PIDINPUTCHECKPROC',SYSDATE,VCONTRAGENTN);
  IF NVL(VCHECKPROC,'_')!= '_' THEN
    EXECUTE IMMEDIATE 'BEGIN '||VCHECKPROC||'(:PIDN,:PROBJN);  END;'
    USING IN VPALLN,IN OUT PROBJN;
  END IF;
EXCEPTION
    WHEN OTHERS THEN NULL;
END;




INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,26/*ЗАПОМНИЛИ БАР КОД ПАЛЛЕТЫ*/,VPALLN,VPALLN,PSTR,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОЙ ПАЛЛЕТЫ',PPROCN)
   RETURNING N INTO PPROCN;
  PROBJN:= KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PID',VPALLN);
  PMSG := 'P-'||VPALLN||'.';
 --RAISE_APPLICATION_ERROR(-20000,PMSG);
   RETURN 1;
END INPUTPALLCODE;

FUNCTION  INPUTPALLCODE2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
VCNT INTEGER;
VKEYCODE VARCHAR2(50);
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VSTBARCODEMANUALPIDINPUT INTEGER := KK_PERMIT.EXISTSPERMIT(VEMPN,'STBARCODEMANUALPIDINPUT',SYSDATE);
BEGIN



IF VSTBARCODEMANUALPIDINPUT != 3 THEN
 IF PSTR IS NULL THEN
  RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ PID, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
 ELSE
  VKEYCODE := NULL;
 END IF;

ELSE
 VKEYCODE := PKEYCODE;
END IF;

SELECT CASE WHEN INSTR(NVL(PSTR,'P-'||VKEYCODE),'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(NVL(PSTR,VKEYCODE),'P-','') ) INTO  VPALLN FROM DUAL;

IF NVL(VKEYCODE,'_') != '0' THEN
SELECT COUNT(1) INTO VCNT
 FROM
 PALL P
  WHERE P.N =VPALLN
   AND SYSDATE BETWEEN P.FD AND P.TD ;

IF VCNT != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>PID В СИСТЕМЕ НЕ ЗАРЕГИСТРИРОВАН!'|| VPALLN||'</ERR>');
END IF;

END IF; --IF NVL(VKEYCODE,'_') != '0' THEN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,26/*ЗАПОМНИЛИ БАР КОД ПАЛЛЕТЫ*/,VPALLN,VPALLN,PSTR,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОЙ ПАЛЛЕТЫ',PPROCN)
   RETURNING N INTO PPROCN;
  PROBJN:= KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PID2',VPALLN);
  PMSG := 'P-'||VPALLN||'.';
 --RAISE_APPLICATION_ERROR(-20000,'QWEQWEQWE__'|| KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_BAR_JOBS.N')||'____'||PROBJN);
   RETURN 1;
END INPUTPALLCODE2;



FUNCTION  INPUTINDOCPALLCODE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
VCNT INTEGER;
VCNT2 INTEGER;
VDOCN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VNEEDINPUTPALLDIM LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCIN.NEEDINPUTPALLDIMENSIONS',SYSDATE,VCONTRAGENTN);
BEGIN
 PMSG := NULL;

SELECT CASE WHEN INSTR(PSTR,'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(PSTR,'P-','') ) INTO  VPALLN FROM DUAL;

SELECT COUNT(1) INTO VCNT
 FROM
 PALL P
  WHERE P.N =VPALLN
   AND SYSDATE BETWEEN P.FD AND P.TD ;

IF VCNT != 1    THEN
 IF NVL(PKEYCODE,'_') != '0' THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА В СИСТЕМЕ НЕ ЗАРЕГИСТРИРОВАНА!</ERR>');
  ELSE
   PMSG :=   '<ERR>ПАЛЛЕТА В СИСТЕМЕ НЕ ЗАРЕГИСТРИРОВАНА!</ERR>';
  END IF;
END IF;

IF NVL(PKEYCODE,'_') = '0' AND  KK_PERMIT.EXISTSPERMITACCESS(
                                                  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'),
                                                  'BANNEDTOTAKEONSAMEPALL',
                                                   SYSDATE)!=0
                                                   THEN
    --ЕСЛИ ПИД ЕСТЬ В ДРУГОМ ПРИХОДЕ НЕ ПУСКАЕМ ДАЖЕ ЕСЛИ PKEYCODE = '0'
    SELECT/*+ INDEX_DESC(D ST_DOC_IN_DET_PALL_N)*/
    COUNT(1) INTO VCNT
    FROM ST_DOC_IN_DET D
    WHERE D.PALL_N = VPALLN
    AND D.SQ_ST_DOC_IN_N != VDOCN
    AND SYSDATE BETWEEN D.FD AND D.TD ;

ELSE
    SELECT/*+ INDEX_DESC(D ST_DOC_IN_DET_PALL_N)*/
    COUNT(1) INTO VCNT
    FROM ST_DOC_IN_DET D
    WHERE D.PALL_N = VPALLN
    AND SYSDATE BETWEEN D.FD AND D.TD ;
END IF;

IF VCNT = 0 /*OR  NVL(PKEYCODE,'_') = '0'*/ THEN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP , VAL4 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,3/*ЗАПОМНИЛИ БАР КОД ПАЛЛЕТЫ*/,VPALLN,VPALLN,PSTR,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОЙ ПАЛЛЕТЫ',PPROCN,PKEYCODE)
   RETURNING N INTO PPROCN;

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PID',VPALLN);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'OP_FD',TO_CHAR(SYSDATE,'DD.MM.YYYY HH24:MI:SS'));

ELSE
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА УЖЕ ЗАРЕГИСТРИРОВАНА!!!!</ERR>');
END IF;

IF VNEEDINPUTPALLDIM=1 THEN
   RETURN 2;
ELSE
   RETURN 1;
END IF;

END;




FUNCTION GETTERMLIST(PDIC INTEGER,POWER_R_N INTEGER DEFAULT NULL,PR_N INTEGER DEFAULT NULL) RETURN VARCHAR2 IS
PMSG VARCHAR2(2000);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
FOR J IN ( SELECT CODE,TERM FROM DIC_DATA WHERE UP=PDIC
                AND  SYSDATE BETWEEN FD AND TD
                 AND (BITAND(POWER_R_N,POWER(2,NVL(R_N,0))) = POWER(2,NVL(R_N,0)) OR POWER_R_N IS NULL)
                 AND ((R_N = PR_N OR NVL(R_N,0) = 0) AND PR_N IS NOT NULL OR PR_N IS NULL)
                 ORDER BY CODE
                 ) LOOP
       PMSG :=  PMSG || J.CODE ||' '|| J.TERM || V1310;

END LOOP;


RETURN PMSG;

END;

FUNCTION  INPUTINDOCNOMCNT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VUNITOPCNTX VARCHAR2(50):= 0; --KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.UNIT_CNT' );
                            -- НЕ ПОНЯТНО ГДЕ СЕТИТСЯ 'BARCODE.UNIT_CNT' - МЕШАЕТ ПРИ ВВОДЕ КОЛ-ВА ПБЛ
VUNITOPCNT NUMBER;
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VCHECKINPUTPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('INPUTINDOCNOMCNT.USERCHECK',SYSDATE,VCONTRAGENTN);
BEGIN
--RAISE_APPLICATION_ERROR(-20000,';'||PSTR||';');
  IF VCHECKINPUTPROC != '_' THEN
    EXECUTE IMMEDIATE 'DECLARE PRET INTEGER; BEGIN PRET :='||VCHECKINPUTPROC||'(:PKEYCODE, :PSTR, :PMSG, :PNEXTNODE, :PPROCN, :PROBJN); END;'
    USING  IN PKEYCODE, IN PSTR, IN OUT PMSG, IN OUT PNEXTNODE, IN OUT PPROCN, IN OUT PROBJN;
  END IF;

 IF PSTR IS NOT NULL THEN -- СКАНИРОВАТЬ КАЖДУЮ ШТУКУ ОТДЕЛЬНО

-- RAISE_APPLICATION_ERROR(-20000,'PSTR='||PSTR);
   RETURN -1;

 ELSE

 BEGIN
  SELECT NVL(TO_NUMBER(VUNITOPCNTX,'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0) INTO VUNITOPCNT FROM DUAL;
   EXCEPTION
    WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
        VUNITOPCNT := 0;
 END;


-- RAISE_APPLICATION_ERROR(-20000,VUNITOPCNTX);

IF VUNITOPCNT = 0 THEN
   IF PKEYCODE IS NULL THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>КОЛИЧЕСТВО НЕ МОЖЕТ БЫТЬ ПУСТЫМ!</ERR>');
   END IF; --IF TO_NUMBER(PKEYCODE) <= 0 THEN

  BEGIN
   VUNITOPCNT := TO_NUMBER(REPLACE(PKEYCODE,'.',','));
   EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VUNITOPCNT := TO_NUMBER(REPLACE(PKEYCODE,',','.'));
  END;



   IF VUNITOPCNT < 0 THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>КОЛИЧЕСТВО НЕ МОЖЕТ БЫТ МЕНЕЕ 0 !!!</ERR>');
   END IF; --IF TO_NUMBER(PKEYCODE) <= 0 THEN


END IF;


--НЕЛЬЗА ТК УЧАСТВУЕТ В ПОДБОРЕ
--IF NVL(VUNITOPCNT,0) = 0 THEN
--RAISE_APPLICATION_ERROR(-20000,'<ERR>ВВЕДЕННОЕ КОЛ-ВО ДОЛЖНО БЫТЬ БОЛЬШЕ НУЛЯ!');
--END IF;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,5/*ЗАПОМНИЛИ КОЛИЧЕСТВО*/,VUNITOPCNT,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ КОЛИЧЕСТВО',PPROCN)
   RETURNING N INTO PPROCN;

     PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CNT',VUNITOPCNT);

   RETURN 1;

 END IF;-- IF PSTR IS NOT NULL THEN -- СКАНИРОВАТЬ КАЖДУЮ ШТУКУ ОТДЕЛЬНО


END;

FUNCTION  INPUTSHOWPALLTYPE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VMSG VARCHAR2(2000);
VNOMENKLATURAN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VPALLTYPESLIST LIST_CONST.VAL%TYPE :=  KK_CONST.GETCONSTV('CONTRAGENT.PALLTYPESLIST.INBOUND',SYSDATE,VCONTRAGENTN);
VPALLTYPENOMLIST LIST_CONST.VAL%TYPE :=  KK_CONST.GETCONSTN('CONTRAGENT.PALLTYPENOMLIST.INBOUND',SYSDATE,VCONTRAGENTN);
VCNT INTEGER := 0;
VBLCK INTEGER;
VCODE  INTEGER;
VDEFPALLTYPE INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_PALL_TYPE'),0);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);

BEGIN

-- RAISE_APPLICATION_ERROR(-20000,'<ERR>TEST</ERR>');
--
-- PMSG :=  PMSG || KK_ST_BARCODE.GETTERMLIST(359);
PMSG:= NULL;

--RAISE_APPLICATION_ERROR(-20000,'VNOMENKLATURAN: '||VNOMENKLATURAN);


/* ЗАПРОС ПЕРЕПИСАН ДЛЯ ВЫЗОВА В ПОШТУЧНОЙ ПРИЕМКЕ, ГДЕ НОМЕНКЛАТУРА СКАНИРУЕТСЯ ПОСЛЕ ПИД*/
FOR J IN (
        SELECT DD.CODE,DD.TERM, NVL(NB.BLCK, -1) AS BLCK
        FROM DIC_DATA DD
         LEFT OUTER JOIN NOM_BLCK NB ON (DD.CODE = NB.PALL_TYPE
                       AND NB.NOMENKLATURA_N = VNOMENKLATURAN
                       AND SYSDATE BETWEEN NB.FD AND NB.TD )
        WHERE DD.UP= 359
           AND  SYSDATE BETWEEN DD.FD AND DD.TD
           AND (VPALLTYPESLIST LIKE '%,'|| DD.CODE ||',%' OR VPALLTYPESLIST = '0')
           AND (VPALLTYPENOMLIST = 0 OR VPALLTYPENOMLIST =1 AND NB.ROWID IS NOT NULL)
           AND NVL(VNOMENKLATURAN,0) != 0
           AND (DD.CODE = VDEFPALLTYPE OR VDEFPALLTYPE = 0)
        UNION ALL

        SELECT DD.CODE,DD.TERM, NULL AS BLCK
                FROM DIC_DATA DD
                WHERE DD.UP= 359
                   AND  SYSDATE BETWEEN DD.FD AND DD.TD
                   AND NVL(VNOMENKLATURAN,0)=0
                   AND (VPALLTYPESLIST LIKE '%,'|| DD.CODE ||',%' OR VPALLTYPESLIST = '0')
                   AND (DD.CODE = VDEFPALLTYPE OR VDEFPALLTYPE = 0)
         ORDER BY CODE
        ) LOOP
/*----------------*/
       PMSG :=  PMSG || J.CODE ||' '|| J.TERM ||'('||J.BLCK||' У.Е.)' || V1310;
VCNT := VCNT +1;
VBLCK := J.BLCK;
VCODE := J.CODE;
END LOOP;

 IF VCNT = 0 THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТЕЗАЦИЯ У НОМЕНКЛАТУРЫ НЕОПРЕДЕЛЕНА!</ERR>');
 END IF ;

------------------------------------------
-- ВВОД ДАННЫХ ИЗ ВВЕДЕННЫХ ПОУМОЛЧАНИЮ --
   IF VDEFPALLTYPE != 0 THEN

    INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP )  VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,6/*ЗАПОМНИЛИ ТИП ПАЛЛЕТА*/,VBLCK,VDEFPALLTYPE,VDEFPALLTYPE,PMSG,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ТИП ПАЛЛЕТА',PPROCN)
       RETURNING N INTO PPROCN;
       PROBJN :=KK_ST_BARCODE. SESSIONVARSET(PROBJN,'STDOCIN.BLCK',VBLCK);
       PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN.PALL_TYPE',VDEFPALLTYPE);

      RETURN 4;
   END IF;  --    IF VPALLTYPE != 0 THEN
-- ВВОД ДАННЫХ ИЗ ВВЕДЕННЫХ ПОУМОЛЧАНИЮ --
------------------------------------------



 IF VCNT = 1 THEN
     IF VBLCK = -1 THEN --НУЖНО ВВОДИТЬ ПАЛЛЕТЕЗАЦИЮ С ТЕРМИНАЛА
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PALL_TYPE',VCODE);
      RETURN 3;
     END IF;

    INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP )  VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,6/*ЗАПОМНИЛИ ТИП ПАЛЛЕТА*/,VBLCK,VCODE,VCODE,PMSG,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ТИП ПАЛЛЕТА',PPROCN)
       RETURNING N INTO PPROCN;
       PROBJN :=KK_ST_BARCODE. SESSIONVARSET(PROBJN,'STDOCIN.BLCK',VBLCK);
       PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN.PALL_TYPE',TO_NUMBER(VCODE));

      RETURN 2;
 ELSE
      RETURN 1;
 END IF ; -- IF VCNT = 1 THEN

END INPUTSHOWPALLTYPE;


FUNCTION  STDOCINNEEDEXPIRE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VDOCN INTEGER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
  VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
  VEXPIRE VARCHAR2(50) := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.EXPIRE');
  VPRODDATE VARCHAR2(50) := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.PROD_DATE');
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  --BARCODE.EXPIRE    21-06-2008 00.00.00
  VKIND LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUT',SYSDATE,VCONTRAGENTN);
  VDEFAULTYEARSEXPIRE INTEGER :=KK_CONST.GETCONSTN('CONTRAGENT.DEFAULTYEARSEXPIRE',SYSDATE,VCONTRAGENTN);
  VSYSDATEASPRODDATE INTEGER := KK_CONST.GETCONSTN('SYSDATEASPRODDATE', SYSDATE, VCONTRAGENTN);
  VPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCINNEEDEXPIRE.PROCFORNOM',SYSDATE,VCONTRAGENTN);
  VRET INTEGER;
  VCNT INTEGER;
  VKEY INTEGER;
  VNEEDMAKEDATE LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NEEDINPUTMAKEDATE',SYSDATE,VCONTRAGENTN);
  V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
  PMSG := NULL;
  BEGIN
    IF VEXPIRE IS NOT NULL THEN
      SELECT TO_CHAR(TO_DATE(VEXPIRE,'DD.MM.YYYY HH24:MI:SS'),'DDMMYYYY')
        INTO VEXPIRE
        FROM DUAL ;
      VRET := 1;
    ELSIF VPRODDATE IS NOT NULL THEN
      SELECT TO_CHAR(TO_DATE(VPRODDATE,'DD.MM.YYYY HH24:MI:SS') + NVL(N.EXPIRE,0),'DDMMYYYY')
        INTO VEXPIRE
        FROM NOMENKLATURA N
        WHERE N.N = VNOMN
          AND SYSDATE BETWEEN N.FD AND N.TD;
      VRET := 1;
    ELSE
      RAISE_APPLICATION_ERROR(-20000,'0');
    END IF;
  EXCEPTION
    WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
      IF VPROC = '_' THEN
        SELECT
              CASE
                WHEN VSYSDATEASPRODDATE = 1 AND VDEFAULTYEARSEXPIRE > 0 THEN 1
                WHEN VSYSDATEASPRODDATE =0 AND N.EXPIRE IS NULL THEN 2
                WHEN VSYSDATEASPRODDATE =0 AND N.EXPIRE = 0 AND INSTR(VKIND,',0,') >0 THEN 1
                ELSE 2
              END ,
              CASE
                WHEN VSYSDATEASPRODDATE = 1 AND VDEFAULTYEARSEXPIRE > 0 THEN TO_CHAR(ADD_MONTHS(SYSDATE, VDEFAULTYEARSEXPIRE*12), 'DDMMYYYY')
                WHEN VSYSDATEASPRODDATE = 1 AND NVL(VDEFAULTYEARSEXPIRE, 0) = 0 AND N.EXPIRE > 0 THEN TO_CHAR(SYSDATE+N.EXPIRE, 'DDMMYYYY')
                ELSE '01013000'
              END
          INTO  VRET ,
                VEXPIRE
          FROM NOMENKLATURA N
          WHERE N.N = VNOMN
            AND SYSDATE BETWEEN N.FD AND N.TD;
      ELSE
        EXECUTE IMMEDIATE 'BEGIN :PRET := '||VPROC||'(:PNOMN, :PEXPIRE); END;'
          USING OUT VRET, IN VNOMN, IN OUT VEXPIRE;
      END IF;
  END;

--
-- ДЛЯ СЧИТЫВАНИЯ ТИПА ДАТЫ СО ШК, ПРИ ВВОДЕ НОМЕНКЛАТУРЫ
SELECT
MIN(RECIPIENT) INTO VKEY
 FROM
TABLE(KK_SMS.CREATETABLE(KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUT',SYSDATE,VCONTRAGENTN)));
--

--RAISE_APPLICATION_ERROR(-20000,VEXPIRE||' '||VRET);
  IF VRET = 1 THEN
    INSERT INTO MCIS_NODES_PROC
      (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
      VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЗАПОМНИЛИ ДАТА СРОК ДО*/,VKEY,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
      RETURNING N
      INTO PPROCN;
    INSERT INTO MCIS_NODES_PROC
      (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
      VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,11/*ЗАПОМНИЛИ ДАТА СРОК ДО*/,NULL,NULL,VEXPIRE,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
      RETURNING N
      INTO PPROCN;
  ELSE
    IF ','||VKIND||',' LIKE '%,11,%' THEN
      FOR REC IN (
        SELECT *
          FROM ST_DOC_IN_DET D
          WHERE D.SQ_ST_DOC_IN_N = VDOCN
            AND TYP = 0
            AND NOMENKLATURA_N = VNOMN
            AND TD = KK_COMMON.GETTD
            AND EXPIRE_DATE != KK_COMMON.GETTD
      )
      LOOP
        PMSG := 'ПРИНЯТЬ СРОК ГОДНОСТИ ПО ДОКУМЕНТУ='||TO_CHAR(REC.EXPIRE_DATE, 'DD.MM.YYYY')||CHR(13)||CHR(10);
        VEXPIRE := TO_CHAR(REC.EXPIRE_DATE, 'DDMMYYYY');
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'EXPIRE', VEXPIRE);
        EXIT;
      END LOOP;
    END IF;
    SELECT DECODE(PMSG, NULL, NULL, '11-'||PMSG||V1310)||
          STRAGG_SEP(T_STR_SEP(
          DECODE(RECIPIENT,1,'1-ГОДЕН ДО'
          ,9,'9-ДАТА ИЗГОТОВЛ.'
          ,10,'10-ЛЕТ ОТ ДАТЫ ПРИЁМКИ: '||VDEFAULTYEARSEXPIRE
          ,0,'0-БЕЗ. ОГРАНИЧ СРОКА')
          ,V1310)), COUNT(1)+ DECODE(PMSG, NULL, 0, 1), MIN(RECIPIENT)
      INTO PMSG ,VCNT , VKEY
      FROM TABLE(KK_SMS.CREATETABLE(',1,9,10,0,',','))
      WHERE VKIND LIKE '%,'||RECIPIENT||',%';
    IF VCNT = 1 THEN
      INSERT INTO MCIS_NODES_PROC
        (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
        VALUES
        (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЧТО ЗА ДАТА*/,VKEY,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЧТО ЗА ДАТУ ВВЕЛИ',PPROCN)
        RETURNING N
        INTO PPROCN;
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN_PRIEMKA_DATE_TYPE',VKEY);
      VRET := 3;
    END IF;
  END IF;
  RETURN VRET ;
END STDOCINNEEDEXPIRE;

FUNCTION  STDOCINNEEDMAKE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VKIND LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUTMAKE',SYSDATE,VCONTRAGENTN);
VRET INTEGER;
VCNT INTEGER;
VKEY INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

 PMSG := NULL;

/*
 BEGIN

 IF VEXPIRE IS NOT NULL THEN
  SELECT TO_CHAR(TO_DATE(VEXPIRE,'DD.MM.YYYY HH24:MI:SS'),'DDMMYYYY') INTO VEXPIRE
    FROM DUAL ;

    VRET := 1;
 ELSIF VPRODDATE IS NOT NULL THEN


  SELECT TO_CHAR(TO_DATE(VPRODDATE,'DD.MM.YYYY HH24:MI:SS') + NVL(N.EXPIRE,0),'DDMMYYYY') INTO VEXPIRE
    FROM NOMENKLATURA N
     WHERE N.N = VNOMN
   AND SYSDATE BETWEEN N.FD AND N.TD;


    VRET := 1;

 ELSE
   RAISE_APPLICATION_ERROR(-20000,'0');
 END IF;


 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    IF VPROC = '_' THEN
      SELECT
              CASE
                WHEN VSYSDATEASPRODDATE = 1 AND VDEFAULTYEARSEXPIRE > 0 THEN 1
                WHEN VSYSDATEASPRODDATE =0 AND N.EXPIRE IS NULL THEN 2
                WHEN VSYSDATEASPRODDATE =0 AND N.EXPIRE = 0 AND INSTR(VKIND,',0,') >0 THEN 1
                ELSE 2
              END ,
              CASE
                WHEN VSYSDATEASPRODDATE = 1 AND VDEFAULTYEARSEXPIRE > 0 THEN TO_CHAR(ADD_MONTHS(SYSDATE, VDEFAULTYEARSEXPIRE*12), 'DDMMYYYY')
                WHEN VSYSDATEASPRODDATE = 1 AND NVL(VDEFAULTYEARSEXPIRE, 0) = 0 AND N.EXPIRE > 0 THEN TO_CHAR(SYSDATE+N.EXPIRE, 'DDMMYYYY')
                ELSE '01013000'
              END
        INTO  VRET ,
              VEXPIRE
        FROM NOMENKLATURA N
        WHERE N.N = VNOMN
          AND SYSDATE BETWEEN N.FD AND N.TD;
    ELSE
      EXECUTE IMMEDIATE 'BEGIN :PRET := '||VPROC||'(:PNOMN, :PEXPIRE); END;'
        USING OUT VRET, IN VNOMN, IN OUT VEXPIRE;
    END IF;
 END;

*/
--RAISE_APPLICATION_ERROR(-20000,VEXPIRE||' '||VRET);

--IF VRET = 1 THEN

--  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
--    (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЗАПОМНИЛИ ДАТА СРОК ДО*/,1,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
--       RETURNING N INTO PPROCN;


--  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
--    (SQ_MCIS_NODES_PROC.NEXTVAL,11/*ЗАПОМНИЛИ ДАТА СРОК ДО*/,NULL,NULL,VEXPIRE,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
--       RETURNING N INTO PPROCN;


--ELSE
SELECT
STRAGG_SEP(T_STR_SEP(
DECODE(RECIPIENT,9,'9-ДАТА ПРОИЗВОДСТВА'
,0,'0-БЕЗ ДАТЫ ПРОИЗВОДСТВА')
,V1310)), COUNT(1) , MIN(RECIPIENT)
 INTO PMSG ,VCNT , VKEY
 FROM
TABLE(KK_SMS.CREATETABLE(',9,0,',','))
WHERE VKIND LIKE '%,'||RECIPIENT||',%';

IF VCNT = 9 THEN

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN_PRIEMKA_MAKE_DATE_TYPE',VKEY);

  VRET := 3;
END IF;

--END IF;

RETURN VRET ;


END STDOCINNEEDMAKE;

FUNCTION  STDOCINUNINOMPALL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,22/*СБОРНЫЙ ПАЛЛЕТ ДОБАВИТЬ*/,TO_NUMBER(PKEYCODE),NULL,NULL,SYSDATE,KK_COMMON.GETTD,'СБОРНЫЙ ПАЛЛЕТ ДОБАВИТЬ',PPROCN)
   RETURNING N INTO PPROCN;

   RETURN 1;

END;

FUNCTION STDOCINCOMPLETEPALL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
 VSTDOCINCOMPLETEPALLPROC VARCHAR2(255);
 VRET INTEGER;
BEGIN

 VSTDOCINCOMPLETEPALLPROC:= NVL(KK_CONST.GETCONSTV('STDOCINCOMPLETEPALL.USERPROC',SYSDATE, NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0)),'_');
  IF NVL(VSTDOCINCOMPLETEPALLPROC, '_') = '_'  THEN
        VRET := KK_ST_BARCODE.STDOCINCOMPLETEPALL_DEF(PKEYCODE,PSTR, PMSG,PNEXTNODE,PPROCN,PROBJN);
     ELSE
        EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VSTDOCINCOMPLETEPALLPROC||'(:PKEYCODE,:PSTR ,:PMSG ,:PNEXTNODE,:PPROCN,:PROBJN);  END;'
  USING OUT VRET, IN PKEYCODE, IN PSTR, IN OUT PMSG, IN OUT PNEXTNODE,IN OUT PPROCN,IN OUT PROBJN;
     END IF;

RETURN VRET;

END STDOCINCOMPLETEPALL;



FUNCTION  STDOCINCOMPLETEPALL_DEF(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := -1;
VCONTRAGENT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VPDOCN INTEGER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VPALL VARCHAR2(100);
VPALLN INTEGER;
VNOMN INTEGER;
VNOMBARCODE VARCHAR2(100);
V6PALLTYP INTEGER;
V6PALLTYPN INTEGER;
V7PALLHEIGHT INTEGER;
V8PALLWIDTH INTEGER;
V9PALLDEEP INTEGER;
V10EXPIRE INTEGER;
VEXPIRE INTEGER;
V11BEGIN DATE;
V12NOMTYP INTEGER :=   KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
VNOMFD DATE;
VNOMTD DATE;
VPART INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PART.N');
VN INTEGER;
VCNT NUMBER;
VWASUNIPALL INTEGER := 0 ;-- БЫЛ ЛИ ПОСЛЕДНИЙ СБОРНЫМ ПАЛЛЕТ!
VBRAK_TYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_SUB_TYP');
VRESPONSE INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP_RESPONSE');
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VUNITCNT NUMBER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_CNT'),1);
VUNIT_DSC_N INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP');
VWEIGHT NUMBER;
VWEIGHT2 NUMBER;
VKINDWEIGHT INTEGER;
--VCONTRAGENTN INTEGER;
VEXPIRE_DATE DATE ;
VOP_FD DATE;
VQUANTCNT INTEGER := NVL(SYS_CONTEXT('CTX_REP','QUANTUM.CNT'),0);


VMSG VARCHAR2(500);
VPCT NUMBER;
VPALLCNT NUMBER;
VMORE INTEGER;
VWEIGHTN NUMBER;
VMANUFACTUREN NUMBER := 0;
VIMPORTERN NUMBER := 0;
VDEFAULTYEARSEXPIRE INTEGER:=KK_CONST.GETCONSTV('CONTRAGENT.DEFAULTYEARSEXPIRE',SYSDATE,VCONTRAGENT);
VMAKEDATE DATE:=TRUNC(TO_DATE(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'MAKE_DATE')));
VNEEDINPUTPALLDIM INTEGER:=KK_CONST.GETCONSTV('STDOCIN.NEEDINPUTPALLDIMENSIONS',SYSDATE,VCONTRAGENT);
VNEEDINBOUNDINPUTPROPITEMS LIST_CONST.VAL%TYPE;
VGRP NUMBER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'STDOCIN.PROPITEMS.GRP');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
VPROC LIST_CONST.VAL%TYPE;
BEGIN

-- ЕСЛИ ВВЕЛИ ВЛОЖЕННОСТЬ В ТЕРМИНАЛЕ
    IF NVL(VQUANTCNT,0) > 0 THEN
        VUNITCNT := VQUANTCNT;
    END IF;
-------------------


-- ПРИНЯЛИ ПАЛЛЕТУ
INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,21,TO_NUMBER(PKEYCODE),NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ПРИНЯЛИ ПАЛЛЕТУ',PPROCN)
   RETURNING N INTO PPROCN;


FOR J IN (

SELECT LEVEL,P.ROWID AS RD ,P.* , LAG(TYP) OVER (PARTITION BY 1 ORDER BY LEVEL DESC) AS PREV
  FROM MCIS_NODES_PROC P
    CONNECT BY PRIOR P.UP = P.N --AND SYSDATE BETWEEN P.FD AND P.TD
      START WITH N = PPROCN --AND SYSDATE BETWEEN P.FD AND P.TD
 ORDER BY LEVEL

) LOOP

/*
BEGIN
IF (VPREVN = 0) AND (J.TYP = 2 )  THEN--DOC
   VPDOCN := J.VAL1 ;
   VCONTRAGENT := J.VAL2 ;
END IF;
EXCEPTION
    WHEN OTHERS THEN RAISE_APPLICATION_ERROR(-20000,2||' ' ||SQLERRM);
END;
*/



  IF  (J.TYP = 61 ) AND VMANUFACTUREN =0 AND SYSDATE BETWEEN J.FD AND J.TD THEN--ПРОИЗВОДИТЕЛЬ
    VMANUFACTUREN  := J.VAL2 ;
  END IF;

  IF  (J.TYP = 63 ) AND VIMPORTERN =0 AND SYSDATE BETWEEN J.FD AND J.TD THEN--ИМПОРТЕР
    VIMPORTERN  := J.VAL3 ;
  END IF;


  IF  (J.TYP = 3 ) AND VPALLN IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
    VPALL  := J.VAL3 ;
    VPALLN := J.VAL2;

    IF V6PALLTYPN IS NULL THEN
      V6PALLTYPN := GETPALLTYPE(0,V6PALLTYP ,0,0,0, 1 );
    END IF;

    IF VCNT IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ЕДИНИЦА ИЗМЕРЕНИЯ ПУСТА!! ПРОВЕРЬТЕ СПРАВОЧНИК НОМЕНКЛАТУР</ERR>');
    END IF;

    IF ROUND(VCNT * VUNITCNT) <= 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ОШИБКА КОЛИЧЕСТВА VCNT='|| VCNT ||'; VUNITCNT='||VUNITCNT||'</ERR>');
    END IF;

    VCNT := ROUND(VCNT * VUNITCNT);

    IF V10EXPIRE = 9 AND V11BEGIN > SYSDATE THEN
      RAISE_APPLICATION_ERROR(-20000,'ВВЕДЕННАЯ ДАТА ПРОИЗВОДСТВА БОЛЬШЕ ТЕКУЩЕЙ ДАТЫ '||V11BEGIN);
    END IF;

    IF V10EXPIRE = 9 AND NVL(VEXPIRE,0)=0 THEN
       SELECT N.EXPIRE
       INTO VEXPIRE
       FROM NOMENKLATURA N
        WHERE N.N = VNOMN
        AND SYSDATE BETWEEN N.FD AND N.TD ;
    END IF;

    IF VKINDWEIGHT = 0 THEN
      SELECT NVL(VWEIGHT,0) -NVL(VWEIGHT2,0) - VCNT * (NVL(NU.WEIGHT,0) - NVL(NU.WEIGHT_NETTO,0))
       INTO VWEIGHTN
       FROM NOMENKLATURA N
        JOIN NOM_UNIT NU ON (NU.NOMENKLATURA_N = N.N AND SYSDATE BETWEEN NU.FD AND NU.TD
                              AND NU.UNIT_TYP = N.UNIT )
        WHERE N.N = VNOMN
        AND SYSDATE BETWEEN N.FD AND N.TD ;
    ELSE
      VWEIGHTN := NVL(VWEIGHT,0);
    END IF;

  IF NVL(VPART,0) = 0 AND KK_CONST.GETCONSTV('STDOCIN.COPYPARTFROMDOC',SYSDATE,VCONTRAGENT)=1 THEN
    BEGIN
      SELECT D.ST_PART_N
        INTO VPART
        FROM ST_DOC_IN_DET D
        WHERE D.SQ_ST_DOC_IN_N=VPDOCN
          AND D.NOMENKLATURA_N=VNOMN
          AND D.TD=KK_COMMON.GETTD
          AND D.TYP=0
          --AND D.CNT_DOC>=VCNT
          /*AND D.CNT_DOC>
            (SELECT NVL (SUM(D1.CNT_IN),0)
                   FROM ST_DOC_IN_DET D1
                   WHERE D1.SQ_ST_DOC_IN_N=VPDOCN
                   AND D1.NOMENKLATURA_N=VNOMN
                   AND D1.TD=KK_COMMON.GETTD
                   AND D1.TYP=1
                   AND D.ST_PART_N =D1.ST_PART_N)*/
          AND ROWNUM=1;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        NULL;
    END;
  END IF;

INSERT INTO ST_DOC_IN_DET
( N,SQ_ST_DOC_IN_N,NOMENKLATURA_N,NUM_SER,NUM_ADD,EXPIRE_DATE,CNT_DOC,CNT_BRAK,CNT_IN,DSC,FD,TD
,NOM_CODE,NOM_NAME,PALL_TYPE_N,TYP,PALL_N ,NOM_TYP,PALL_TYPE,ST_PART_N,DISTRIB_ON_CELL
,PRM_USERS_N,WEIGHT,UNIT_DSC_N,MANUFACTURER,IMPORTER,UNIT_CNT,MAKE_DATE)
VALUES (SQ_ST_DOC_DET.NEXTVAL,VPDOCN,VNOMN,VNOMBARCODE,NULL
          ,DECODE(V10EXPIRE,1,V11BEGIN   --EXPIRE_DATE
                           ,9,V11BEGIN + NVL(VEXPIRE,0)/*ADD_MONTHS(V11BEGIN,NVL(VEXPIRE,0))*/
                           ,10,TRUNC(ADD_MONTHS(SYSDATE,12*VDEFAULTYEARSEXPIRE))
                           ,0,KK_COMMON.GETTD)/*EXPIRE*/
             ,VCNT,DECODE(V12NOMTYP,3,VCNT,0),DECODE(V12NOMTYP,3,0,VCNT),NULL,SYSDATE,KK_COMMON.GETTD,NULL,NULL --DILVISH 04.05.2012
              ,V6PALLTYPN
      ,1/*BY BARCODE TECHNOLOGY*/,VPALLN,V12NOMTYP,V6PALLTYP,VPART,1
      ,VEMPN,NVL(VWEIGHTN,0),VUNIT_DSC_N,VMANUFACTUREN,VIMPORTERN,VUNITCNT,NVL(VMAKEDATE,V11BEGIN-NVL(VEXPIRE,0)))
RETURNING N,EXPIRE_DATE INTO VN,VEXPIRE_DATE ;

IF NVL(VQUANTCNT,0) != 0 THEN
    KK_COMMON.ACTION(0,'ST_DOC_IN_DET',VN,3,SYSDATE,'ПРИНЯТА ВЛОЖЕННОСТЬ:'||VQUANTCNT );
END IF;

-----------------------------
--ДОБАВЛЯЕМ ВВЕДЕННЫЕ ДОП.ПАРАМЕТРЫ
   SELECT KK_CONST.GETCONSTV('STDOCIN.NEEDINBOUNDINPUTPROPITEMS',SYSDATE,D.CONTRAGENT_N,D.TYP)
      INTO VNEEDINBOUNDINPUTPROPITEMS
    FROM ST_DOC_IN D WHERE D.N = VPDOCN AND D.TD = KK_COMMON.GETTD;

SELECT KK_CONST.GETCONSTV('STDOCIN.NEEDINBOUNDINPUTPROPITEMS',SYSDATE,D.CONTRAGENT_N,D.TYP)
      INTO VNEEDINBOUNDINPUTPROPITEMS
    FROM ST_DOC_IN D WHERE D.N = VPDOCN AND D.TD = KK_COMMON.GETTD;
IF NVL(VNEEDINBOUNDINPUTPROPITEMS,'_') != '_' THEN
FOR J IN (SELECT T.VAL,T.VAL3 FROM CLIENT_PROP_ITEMS_TMP T
              WHERE T.GRP = VGRP AND T.VAL4 = 2 /*ВВЕДЕНЫ*/
          )LOOP
                KK_PROP_ITEMS.SETITEMVALUE(VEMPN,J.VAL,16,VN,J.VAL3);
          END LOOP;
    DELETE CLIENT_PROP_ITEMS_TMP T WHERE T.GRP = VGRP;
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN.PROPITEMS.SUBMIT',0);
END IF;
-----------------------------

KK_ST_NOM_TYP.SETVALUES(PSTDOCTYP => 1, PSTDOCN => VN, PSUBNOMTYP => VBRAK_TYP, PRESPONSE => VRESPONSE );
KK_ST_STATUS_CHANGE.STDOCINDET_USERCHEQUEPROC(PROBJN  , VEMPN, VPDOCN, VN,VNOMN,VMSG,1/*ПРИЕМКА*/);

--( PWHO INTEGER , PDOCINN INTEGER, PDOCDETN INTEGER, PNOMN INTEGER, PMSG IN OUT VARCHAR2) IS
KK_BARCODE_MASK.CLEARBARCODEVAR(PROBJN);

-- ОЧИЩАЕМ ПЕРЕМЕННЫЕ ДЛЯ ЦИКЛИЧЕСКОГО ВВОДА ПАРТИЙ
  FOR REC IN (
              SELECT 'PART.TYP'||D.CODE AS VAR_NAME
              FROM DIC_DATA D
              WHERE D.UP = 307
              AND D.TD = KK_COMMON.GETTD
  )
  LOOP
      PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,REC.VAR_NAME,'');
  END LOOP;


IF VKINDWEIGHT = 1 THEN  -- ЗАЧЕМ ПЕРЕСЧИТЫВАЕМ ВЕС НЕТТО ДЛЯ ЕГО УВЕЛИЧЕНИЯ ?????
 SELECT VWEIGHT + VCNT * (NVL(NU.WEIGHT,0) - NVL(NU.WEIGHT_NETTO,0))
    INTO VWEIGHT
    FROM NOMENKLATURA N
      JOIN NOM_UNIT NU ON (NU.NOMENKLATURA_N = N.N AND SYSDATE BETWEEN NU.FD AND NU.TD
                           AND NU.UNIT_TYP = N.UNIT )
  WHERE N.N = VNOMN
  AND SYSDATE BETWEEN N.FD AND N.TD ;
  VKINDWEIGHT := 0 ; -- СДЕЛАЕМ ИЗ НЕГО БРУТТО

END IF; --IF VKINDWEIGHT = 1 THEN


UPDATE PALL
 SET
   WEIGHT = NVL(WEIGHT,0) + NVL(VWEIGHT,0), -- ДЛЯ МИКСОВАННЫХ НУЖНО СУМИРОВАТЬ
  WEIGHT2 = NVL(VWEIGHT2,0),
  KIND_WEIGHT = VKINDWEIGHT
  WHERE N=   VPALLN
  AND SYSDATE BETWEEN FD AND TD;

 SELECT NVL( TO_DATE(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'OP_FD'),'DD.MM.YYYY HH24:MI:SS' ) , SYSDATE)
   INTO VOP_FD FROM DUAL ;

KK_ST_BARCODE5. CHECK4INBOUNDONPALL(VPDOCN ,VPALLN,VCONTRAGENT);


/*ВЫПОЛНЕНОЕ ЗАДАНИЕ НА ПРИХОДОВАНИЕ ПАЛЛЕТЫ*/
KK_ST_BAR_JOBS.CREATEJOBONEMP(PROBJN ,VN,1,1,1,VPALLN,3/*СТАТУС ЗАДАНИЯ ВЫПОЛНЕНО*/,SYSDATE,0/*VCONTRAGENT*/,VNOMN,VPDOCN,VOP_FD);
--CREATEJOBONEMP(PROBJN,PDOCN,PDOCTYP,PTYP,PPRIORITY,PVAL1,PSTATUS,PTD,PCONTRAGENTN,PNOMENCLATURAN,PBASEDOCN,PFD);

KK_COMMON.ACTION( VEMPN,'ST_DOC_IN_DET',VN,1,SYSDATE,VPALLN);

EXIT WHEN J.PREV != 22 ; -- 22 СБОРНЫЙ


VPALL := NULL;
VPALLN := NULL;
VNOMN := NULL;
VNOMBARCODE := NULL;
V6PALLTYP := NULL;
V6PALLTYPN := NULL;
V7PALLHEIGHT := NULL;
V8PALLWIDTH := NULL;
V9PALLDEEP := NULL;
V10EXPIRE := NULL;
VEXPIRE := NULL;
V11BEGIN := NULL;

VNOMFD := NULL;
VNOMTD := NULL;

VN := NULL;
VCNT := NULL;
VWASUNIPALL  := 0 ;-- БЫЛ ЛИ ПОСЛЕДНИЙ СБОРНЫМ ПАЛЛЕТ!
VBRAK_TYP := 0;
VUNITCNT := 1;
VWEIGHT2 := NULL;
VWEIGHT := NULL;
VKINDWEIGHT := NULL;
END IF;



IF  (J.TYP = 6 ) AND V6PALLTYP IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
  V6PALLTYP    := J.VAL2 ;
END IF;



IF  (J.TYP = 7 ) AND V7PALLHEIGHT IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
   V7PALLHEIGHT   := J.VAL2 ;
   V6PALLTYPN := KK_ST_BARCODE.GETPALLTYPE(VEMPN,V6PALLTYP ,V7PALLHEIGHT ,V8PALLWIDTH ,V9PALLDEEP );

UPDATE/*+ INDEX(P PALL_N_FD_TD)*/ PALL P
 SET
 PALL_TYPE_N  =VPALLN
  WHERE  N= VPALLN
   AND SYSDATE BETWEEN FD AND TD ;

END IF;

IF (J.TYP = 8 ) AND V8PALLWIDTH IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
    V8PALLWIDTH  := J.VAL2 ;
END IF;



IF  (J.TYP = 9 ) AND V9PALLDEEP IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
    V9PALLDEEP  := J.VAL2 ;
END IF;


IF (J.TYP = 10 ) AND V10EXPIRE IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
     V10EXPIRE := J.VAL1 ;
END IF;


IF  (J.TYP = 11 ) AND V11BEGIN IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
    V11BEGIN  := TO_DATE(J.VAL3,'DDMMYYYY') ;
END IF;


/*IF (J.TYP = 12 ) AND V12NOMTYP IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--PALLET
    V12NOMTYP  := J.VAL1 ;
END IF;*/



IF (J.TYP = 4 ) AND VNOMN IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--NOM
VNOMN := J.VAL1;
VNOMBARCODE := J.VAL3;
VEXPIRE := J.VAL5;
END IF;



IF (J.TYP = 5 ) AND VCNT IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--NOM CNT
VCNT := J.VAL1;
END IF;



IF (J.TYP = 191 ) AND VWEIGHT IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--NOM CNT
VWEIGHT := J.VAL1;
END IF;

IF (J.TYP = 231 ) AND VKINDWEIGHT IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--NOM CNT
VKINDWEIGHT := J.VAL1;
END IF;

IF (J.TYP = 212 ) AND VWEIGHT IS NULL AND SYSDATE BETWEEN J.FD AND J.TD THEN--NOM CNT
VWEIGHT2 := J.VAL1;
END IF;

IF (J.TYP IN (21,22) ) AND VWASUNIPALL =0 AND SYSDATE BETWEEN J.FD AND J.TD THEN--NOM CNT

IF J.TYP = 22 AND VWASUNIPALL = 0 THEN
VWASUNIPALL := 1;
END IF;

IF VWASUNIPALL >0 THEN
 VRET := 1;  -- ;--ЕСЛИ  ПОСЛЕДНИЙ БЫЛ СБОРНЫЙ ТО
ELSE
 VRET := 1;    -- 111;--ЕСЛИ  ПОСЛЕДНИЙ БЫЛ МОНО ТО
END IF;

END IF;

    UPDATE MCIS_NODES_PROC
      SET TD = SYSDATE
       WHERE ROWID = J.RD;



END LOOP;

DECLARE
VCHECKSAFETYEXPIRE INTEGER := KK_ST_DOC.STDOCIN_CHECKSAFETYEXPIRE(VNOMN,VEXPIRE_DATE) ;
VCHECKSAFETYEXPIREACC INTEGER := KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCIN.CHECKSAFETYEXPIRE.PASS',SYSDATE);
--VCHECKSAFETYEXPIREBYCOMM INTEGER := NVL(KK_PROP_ITEMS.GETITEMVALUEBYCOMM(VEMPN,0,VPDOCN,SYSDATE,'ALIAS_BSM'),0);
VCHECKSAFETYEXPIRECOMM CLIENT_PROP_VALUES.VAL_STR%TYPE := NVL(KK_PROP_ITEMS.GETITEMVALUEBYALIAS(0,VPDOCN,SYSDATE,'ALIAS_BSM'),'0');
BEGIN
-- ПРОВЕРКА БЕЗОПАСНОГО ОКНА СРОКА ГОДНОСТИ ПРИ ПРИЕМКЕ
 IF 1 != VCHECKSAFETYEXPIRE AND (VCHECKSAFETYEXPIREACC = 3 OR VCHECKSAFETYEXPIRECOMM ='0')  THEN
  PMSG := '<ERR>УКАЗАННЫЙ СРОК ГОДНОСТИ ВЫХОДИТ ЗА ПРЕДЕЛЫ БЕЗОПАСНОГО СРОКА ДЛЯ НОМЕНКЛАТУРЫ!</ERR>'||VNOMN||'_'||TO_CHAR(VEXPIRE_DATE,'DD.MM.YYYY');
 ELSIF 1 != VCHECKSAFETYEXPIRE AND VCHECKSAFETYEXPIREACC != 3 AND VCHECKSAFETYEXPIRECOMM ='0'  THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>УКАЗАННЫЙ СРОК ГОДНОСТИ ВЫХОДИТ ЗА ПРЕДЕЛЫ БЕЗОПАСНОГО СРОКА ДЛЯ НОМЕНКЛАТУРЫ!</ERR>'||VNOMN||'_'||TO_CHAR(VEXPIRE_DATE,'DD.MM.YYYY'));
 END IF;

END; --DECLARE

VPROC := KK_CONST.GETCONSTV('STDOCINCOMPLETEPALL.MSG.PROCNAME',SYSDATE, KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N' ) );

--RAISE_APPLICATION_ERROR(-20000,VPROC||'; '||KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N' ));

 IF NVL(VPROC,'_') = '_' THEN


    SELECT
    ROUND((
    D1.CNT  / DECODE(D0.CNT,0,-1,D0.CNT )
    ) * 100,2) ,
    PALL_N ,
    D1.NOM_CNT  - D0.NOM_CNT
     INTO VPCT,VPALLCNT , VMORE

     FROM (
        SELECT SUM(NVL(D0.CNT_IN,0)+NVL(D0.CNT_BRAK,0))   AS CNT
        ,SUM(DECODE(D0.NOMENKLATURA_N,VNOMN,NVL(D0.CNT_IN,0)+NVL(D0.CNT_BRAK,0),0)) AS NOM_CNT
         FROM ST_DOC_IN_DET  D0
         WHERE
         D0.SQ_ST_DOC_IN_N = VPDOCN
        AND SYSDATE BETWEEN D0.FD AND D0.TD
        AND D0.TYP = 0
      ) D0
      FULL OUTER JOIN
    (
        SELECT SUM(NVL(D0.CNT_IN,0)+NVL(D0.CNT_BRAK,0))  AS CNT
        ,SUM(DECODE(D0.NOMENKLATURA_N,VNOMN,NVL(D0.CNT_IN,0)+NVL(D0.CNT_BRAK,0),0)) AS NOM_CNT
        , COUNT(DISTINCT PALL_N)   AS PALL_N
         FROM ST_DOC_IN_DET  D0
         WHERE
         D0.SQ_ST_DOC_IN_N = VPDOCN
        AND SYSDATE BETWEEN D0.FD AND D0.TD
        AND D0.TYP = 1
      ) D1   ON (1=1) ;

 SELECT   VPCT||'% ('||VCNT||')'||V1310 ||
     DECODE(SIGN(VMORE),1,'ИЗЛИШЕК: '||VMORE,'НУЖНО: '||ABS(VMORE))||V1310 ||
  'ПАЛЛЕТ-'||VPALLCNT||V1310 ||
     'PID-'||VPALLN  ||V1310 ||'КОД '|| V1310|| PMSG
        INTO PMSG
       FROM DUAL ;



 ELSE

    EXECUTE IMMEDIATE 'BEGIN :PMSG:='||VPROC||'(:PDOCN, :PNOMN, :PPALLN); END;'
    USING OUT PMSG , IN VPDOCN , IN VNOMN, IN VPALLN ;

 END IF;

SELECT DECODE(SIGN(VMORE),1,'<ERR>' || PMSG ||'</ERR>' , PMSG ) INTO PMSG FROM DUAL;


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,20/*ЗАПОМНИЛИ ЗАПИСЬ ПРИ*/,VN,VPALLN,VPDOCN,SYSDATE,KK_COMMON.GETTD,'ПОСЛДЕНЮЮ ПРИХОДОВАНЮП ПАЛЛЕТУ',PPROCN)
   RETURNING N INTO PPROCN;

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INBOUND.UNIT.GETTED' , NULL );

-- ЗАПОЛНЯЕМ ГАБАРИТЫ ПАЛЕТЫ, ЗАДАННЫЕ ПРИ ПРИЁМКЕ
IF VNEEDINPUTPALLDIM=1 THEN
    UPDATE PALL
    SET DIMENSION_L=NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PALL_L'),0),
        DIMENSION_W=NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PALL_W'),0),
        DIMENSION_H=NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PALL_H'),0)
    WHERE N=VPALLN
      AND TD=KK_COMMON.GETTD;
END IF;
--ОЧИЩАЕМ ПЕРЕМЕННЫЕ ГРАДАЦИИ БРАКА И ВИНОВНОГО В БРАКЕ.

KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN,'NOM_SUB_TYP');
KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN,'NOM_TYP_RESPONSE');

   RETURN VRET;
--EXCEPTION
--  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
--  KK_COMMON.ERR_LOG('STDOCINCOMPLETEPALL',VPDOCN,SQLERRM);
--  RAISE_APPLICATION_ERROR(-20000,    DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);


END STDOCINCOMPLETEPALL_DEF;

FUNCTION DEFINENOMBYCODE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VNOMN INTEGER;
--VDOCN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
BEGIN

 IF PKEYCODE IS NULL THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ВВЕДИТЕ КОД ИЛИ ШТРИХ КОД ВРУЧНУЮ</ERR>');
 END IF; --IF PKEYCODE IS NULL THEN


BEGIN
SELECT N , SUBSTR(CODE || ' ' || NAME,1,200) INTO VNOMN , PMSG
 FROM
 (
 SELECT/*+ ORDERED*/  N.N, N.CODE , N.NAME
     FROM NOM_BARCODE B
        JOIN NOMENKLATURA N ON (  B.NOMENKLATURA_N = N.N  AND SYSDATE BETWEEN N.FD AND N.TD )
   WHERE LOWER(TRIM(B.BAR_CODE)) = LOWER(TRIM(PKEYCODE))
      AND SYSDATE BETWEEN B.FD AND B.TD
      AND B.CONTRAGENT_N = VCONTRAGENTN
     UNION
  SELECT N.N, N.CODE , N.NAME
     FROM  NOMENKLATURA N
      WHERE  SYSDATE BETWEEN N.FD AND N.TD
         AND LOWER(N.CODE) = LOWER(PKEYCODE)
         AND N.CONTRAGENT_N = VCONTRAGENTN
   ) ;

EXCEPTION
  WHEN OTHERS THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ВВЕДИТЕ КОД ИЛИ ШТРИХ КОД ВРУЧНУЮ "'||PKEYCODE||'" VCONTRAGENTN="'||VCONTRAGENTN||'"</ERR>'||SQLERRM);
END;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);

RETURN 1;
END DEFINENOMBYCODE;

FUNCTION  PRINTINDOCNOMSTICKER(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VNOMN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
--VDOCN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VPRINTERN    INTEGER;
VEMPN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VREPMODULE VARCHAR2(255);
BEGIN

BEGIN
  SELECT CASE WHEN INSTR(LOWER(PSTR),'PR-') = 1 THEN TO_NUMBER(SUBSTR(PSTR,4)) ELSE 0 END INTO VPRINTERN FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    VPRINTERN := 0;
END;

IF NVL(VPRINTERN,0) = 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПРИНТЕР!</ERR>');
END IF;

BEGIN
 SELECT N INTO VPRINTERN
  FROM R_PRINTERS
   WHERE N = VPRINTERN
    AND SYSDATE BETWEEN FD AND TD;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ПРИНТЕР НЕ ЗАРЕГИСТРИРОВАН В СИСТЕМЕ! PR-'||VPRINTERN||'</ERR>');
END;


 IF TO_NUMBER(NVL(PKEYCODE,0)) NOT BETWEEN 1 AND 50 THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>УКАЖИТЕ КОЛИЧЕСТВО В ИНТЕРВАЛЕ ОТ 1 ДО 50 КОПИЙ</ERR>');
 END IF;



 VREPMODULE := KK_CONST.GETCONSTV('CONTRAGENT.NOMSTICKER.MODULE',SYSDATE,VCONTRAGENTN);

  --  KK_R.BUILDPRINTJOBTYP(VEMPN,VPRINTERN,1/*:PDOCTYP*/,0/*PLOCAL*/,VNOMN,VREPMODULE||'.DLL','PDOCN='||VDOCN||';COPIES='||TO_NUMBER(PKEYCODE)||';PCONTRAGENTN='||VCONTRAGENTN||';PNOMN='||VNOMN||';PWHO='||VEMPN||';PTARIFGRP=-17'||';PRINTFROM=-13');
  --  KK_R.BUILDPRINTJOBTYP(VEMPN,VPRINTERN,1/*:PDOCTYP*/,0/*PLOCAL*/,VNOMN,VREPMODULE||'.DLL','PDOCN='||VDOCN||';COPIES='||TO_NUMBER(PKEYCODE)||';PCONTRAGENTN='||VCONTRAGENTN||';PNOMN='||VNOMN||';PWHO='||VEMPN||';PTARIFGRP=-17'||';PRINTFROM=-13');
      KK_R.BUILDPRINTJOBTYP(VEMPN ,VPRINTERN,2/*:PDOCTYP*/,0/*PLOCAL*/,VNOMN,VREPMODULE||'.DLL',
 'PDOCN=0;PPALLN=0;COPIES='||TO_NUMBER(PKEYCODE)||';PCONTRAGENTN='||VCONTRAGENTN||';PNOMENKLATURAN='||VNOMN||';PWHO='||VEMPN||';PTARIFGRP=-17;PRINTFROM=-14');



    PMSG := '<ERR>ВОЗЬМИТЕ ЭТИКЕТКИ НА ПРИНТЕРЕ!</ERR>';


 RETURN 1;
END PRINTINDOCNOMSTICKER;


FUNCTION NOMCHECKDIMENTEXISTS(PNOMN INTEGER,PNOMUNIT INTEGER,PROBJN INTEGER,PNOMDIMENT OUT VARCHAR2,PNOMUNITCNT OUT INTEGER,PNOMUNITN INTEGER DEFAULT 0)RETURN INTEGER IS
VRET INTEGER;
VUNITN INTEGER:= NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.UNITN'),0);
VNOMCHECKDIMENTEXISTSPROC VARCHAR2(255);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
  VNOMCHECKDIMENTEXISTSPROC:= NVL(KK_CONST.GETCONSTV('NOMCHECKDIMENTEXISTS.USERPROC',SYSDATE, NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0)),'_');
  IF NVL(VNOMCHECKDIMENTEXISTSPROC, '_') != '_'  THEN
        EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VNOMCHECKDIMENTEXISTSPROC||'(:PNOMN,:PNOMUNIT,:PROBJN,:PNOMDIMENT,:PNOMUNITCNT);  END;'
  USING OUT VRET, IN PNOMN, IN PNOMUNIT, IN PROBJN, OUT PNOMDIMENT, OUT PNOMUNITCNT;

  ELSE

  BEGIN
  SELECT
  'Д: '|| DECODE(NVL(NU.DIMENSION_L,0) , 0 , '_' , NU.DIMENSION_L )  ||
 ' Ш: '|| DECODE(NVL(NU.DIMENSION_W,0) , 0 , '_' , NU.DIMENSION_W  ) ||
 ' В: '|| DECODE(NVL(NU.DIMENSION_H,0) , 0 , '_' , NU.DIMENSION_H ) ||  V1310 ||
 'ВЕС: '|| DECODE(NVL(NU.WEIGHT,0) , 0 , '_' , NU.WEIGHT    )
 , CASE
    WHEN NVL(NU.DIMENSION_L,0) = 0
       OR NVL(NU.DIMENSION_W,0) =0
       OR NVL(NU.DIMENSION_H,0) =0
       OR (NVL(NU.WEIGHT,0) =0 AND KK_CONST.GETCONSTV('NOMCHECKDIMENTEXISTS.WEIGHTCANBEMISSED', SYSDATE, N.CONTRAGENT_N) != 1)
    THEN 1
    ELSE 0 END , NU.UNIT_CNT
    INTO  PNOMDIMENT , VRET , PNOMUNITCNT
     FROM NOM_UNIT NU
     JOIN NOMENKLATURA N ON (NU.NOMENKLATURA_N = N.N AND N.TD = KK_COMMON.GETTD)
      WHERE NU.NOMENKLATURA_N =  PNOMN
   AND (NU.UNIT_TYP = PNOMUNIT AND VUNITN = 0 OR NU.UNIT_TYP = VUNITN)
   AND (NU.N= PNOMUNITN OR PNOMUNITN = 0 /*ДЛЯ ОДНОЗНАЧНОЙ ИДЕНТИФИКАЦИИ ЕСЛИ ЕСТЬ КОРОБ20 И КОРОБ35*/)
   AND SYSDATE BETWEEN NU.FD AND NU.TD;

  EXCEPTION
   WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>У НОМЕНКЛАТУРЫ НЕТ ВЫБРАНОЙ ЕД КОНВЕРТАЦИИ ВЫБЕРИТЕ ДРУГУЮ! VUNITN='||VUNITN||'; VNOMUNIT='||PNOMUNIT||'</ERR>');
  END;
 END IF;

 RETURN VRET;


END NOMCHECKDIMENTEXISTS;


FUNCTION GETNOMCURSORBYUSERPROC(PCONTRN INTEGER,PKEYCODE VARCHAR2 , PSTR VARCHAR2, PDOCTYP INTEGER DEFAULT 0 ) RETURN TCWMS_TABLE IS
VRET TCWMS_TABLE;
VINPUTNOMCODEUSERPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('INPUTNOMCODE.USERCHECKPROC',SYSDATE,PCONTRN, PDOCTYP);
I INTEGER := 0;
BEGIN

 VRET:= TCWMS_TABLE();

IF VINPUTNOMCODEUSERPROC = '_' THEN
    VRET := KK_ST_BARCODE.GETNOMCURSORBYUSERPROC_DEF(PCONTRN ,PKEYCODE  , PSTR );

ELSE

EXECUTE IMMEDIATE 'BEGIN :PRET := '||VINPUTNOMCODEUSERPROC||'(:PCONTRN ,  :PKEYCODE,  :PSTR); END;'
                USING OUT VRET                            , IN PCONTRN ,IN PKEYCODE,IN PSTR ;

/*FOR J IN (
 SELECT 0 AS N
   FROM DUAL
) LOOP
    I := I + 1;
    VRET.EXTEND(1);
           VRET(I) := TCWMS_REC(J.N) ;
END LOOP;
*/

END IF; --IF VINPUTNOMCODEUSERPROC != '_' THEN


RETURN VRET;

END GETNOMCURSORBYUSERPROC;


FUNCTION GETNOMCURSORBYUSERPROC_DEF(PCONTRN INTEGER,PKEYCODE VARCHAR2 , PSTR VARCHAR2, PDOCTYP INTEGER DEFAULT 0) RETURN TCWMS_TABLE IS
VREC INTEGER := 0 ;
VRETVAL TCWMS_TABLE;
VRN INTEGER;
VSTR VARCHAR2(128);

VRETVALFINAL TCWMS_TABLE;
VMASKLIST LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('INPUTNOMCODE.BARCODEMASK.ACCESSLIST',SYSDATE,PCONTRN);
BEGIN

--PPARAMS := NULL;


VRETVAL := TCWMS_TABLE();

-- ПРЯМОЙ СКАН

FOR REC_NOM IN (
    SELECT NOMENKLATURA_N
      FROM NOM_BARCODE BC
      JOIN NOMENKLATURA N ON (N.N = BC.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
      WHERE BC.CONTRAGENT_N = PCONTRN
        AND LOWER(BC.BAR_CODE) = LOWER(PSTR)
        AND BC.TD = KK_COMMON.GETTD
    UNION
    SELECT N AS NOMENKLATURA_N
      FROM NOMENKLATURA
      WHERE CONTRAGENT_N = PCONTRN
        AND UPPER(TRIM(CODE)) = UPPER(PSTR)
        AND TD = KK_COMMON.GETTD
)
LOOP
    VRETVAL.EXTEND(1);
    VREC := VREC + 1;
    VRETVAL(VREC) := TCWMS_REC(REC_NOM.NOMENKLATURA_N,NULL) ;



END LOOP;

-- ПО МАСКЕ




SELECT REPLACE( REPLACE(PSTR,'(',''),')','') INTO VSTR FROM DUAL;
SELECT  TRANSLATE(VSTR,'~'||CHR(0)||CHR(1)||CHR(2)||CHR(3)||CHR(4)||CHR(5)||CHR(6)||CHR(7)||CHR(8)||CHR(9)||CHR(10)||CHR(11)||CHR(12)||CHR(13)||CHR(14)||CHR(15)||CHR(16)||CHR(17)||CHR(18)||CHR(19)||CHR(20)||CHR(21)||CHR(22)||CHR(23)||CHR(24)||CHR(25)||CHR(26)||CHR(27)||CHR(28)||CHR(29)||CHR(30)||CHR(31),'~')
 INTO VSTR  FROM DUAL;



              FOR J IN (SELECT N,MASK  FROM ST_BARCODE_MASK
                           WHERE SYSDATE BETWEEN FD AND TD
                           AND N != 0
                           AND ((VMASKLIST = '0') OR (VMASKLIST LIKE '%,'||N||',%'))
                           AND (LENGTH(VSTR) = LEN  OR NVL(LEN,0) = 0 )
                               ORDER BY ORD) LOOP


BEGIN




SELECT J.N INTO VRN
 FROM (/*1*/
SELECT RECIPIENT
,DECODE(INSTR(RECIPIENT,'ANCHOR:'),1,SUBSTR(RECIPIENT,INSTR(RECIPIENT,'/',-1)+1,INSTR(RECIPIENT,'|',-1)-INSTR(RECIPIENT,'/',-1)-1) , NULL ) AS FR
,DECODE(INSTR(RECIPIENT,'ANCHOR:'),1,SUBSTR(RECIPIENT,INSTR(RECIPIENT,'|',-1)+1 ) , NULL) AS LEN
,CASE WHEN INSTR(RECIPIENT,'ANCHOR:')>0 THEN
  REGEXP_SUBSTR(VSTR, SUBSTR(RECIPIENT,INSTR(RECIPIENT,':')+1,INSTR(RECIPIENT,'+',-1)- INSTR(RECIPIENT,':') -1))
     ELSE NULL
   END  AS VAL
,CASE WHEN INSTR(RECIPIENT,'ANCHOR:')>0
  THEN
    CASE WHEN SUBSTR(RECIPIENT,INSTR(RECIPIENT,':')+1,INSTR(RECIPIENT,'+',-1)- INSTR(RECIPIENT,':') -1) IS NULL THEN 999/*ЗАГЛУШКА ДЛЯ ПУСТОЙ МАСКИ*/
    ELSE     REGEXP_INSTR(VSTR, SUBSTR(RECIPIENT,INSTR(RECIPIENT,':')+1,INSTR(RECIPIENT,'+',-1)- INSTR(RECIPIENT,':') -1),
     SUBSTR(RECIPIENT,INSTR(RECIPIENT,'+',-1)+1,INSTR(RECIPIENT,'/',-1)- INSTR(RECIPIENT,'+') -1)
     )  END
     ELSE NULL
   END  AS INST
 ,SUBSTR(RECIPIENT,INSTR(RECIPIENT,'+',-1)+1,INSTR(RECIPIENT,'/',-1)- INSTR(RECIPIENT,'+') -1) AS ANCH_FR
 ,ROWNUM AS RN
 FROM TABLE( CAST( KK_SMS.CREATETABLE( J.MASK  ,';') AS TRECIPIENTTABLE))
 WHERE 1=1
 )/*1*/
HAVING  SUM(CASE WHEN DECODE(INST,999,ANCH_FR,INST) = ANCH_FR THEN 1 ELSE 0 END) =
        SUM(CASE WHEN ANCH_FR  >0  THEN 1 ELSE 0 END) ;




     FOR K IN ( SELECT
     UPPER(DECODE(INSTR(KEY_NAME,'ANCHOR:'),1,VAL,KEY_NAME)) AS NAME,
     CASE
       WHEN TYP = 'CHAR' THEN KEY_VAL
       WHEN TYP = 'INT'  THEN
       TO_CHAR(
         TO_NUMBER(KEY_VAL) / POWER(10,NVL(PR,0/*NVL*/ ))
    --     ,SUBSTR(FORMAT,1,DECODE(INSTR(FORMAT,'/'),0,LENGTH(FORMAT),NULL,LENGTH(FORMAT),INSTR(FORMAT,'/')-1))
            ,'999999D9999' , 'NLS_NUMERIC_CHARACTERS ='', '''  )
       WHEN TYP = 'DATE' THEN TO_CHAR(TO_DATE(KEY_VAL,FORMAT),'DD.MM.YYYY HH24:MI:SS')

       END AS KEY_VAL
     FROM (
    SELECT RECIPIENT,VAL,
    LAG_,LEAD_
    , SUBSTR(VSTR, FR , LEN ) AS KEY_VAL
    , SUBSTR(RECIPIENT,INSTR(RECIPIENT,':')+1,INSTR(RECIPIENT,'|',-1 ) - (INSTR(RECIPIENT,':')+1))  AS TYP
    , SUBSTR(RECIPIENT,INSTR(RECIPIENT,'|')+1,INSTR(RECIPIENT,'/',-1 ) - (INSTR(RECIPIENT,'|')+1))  AS FORMAT
    , SUBSTR(RECIPIENT,INSTR(RECIPIENT,'/')+1,INSTR(RECIPIENT,'+',-1 ) - (INSTR(RECIPIENT,'/')+1))  AS PR
    , SUBSTR(RECIPIENT,INSTR(RECIPIENT,'+',-1)+1) AS KEY_NAME
    ,RN
     FROM (
    SELECT RECIPIENT ,VAL
    , LAG(VAL) OVER (PARTITION BY 1 ORDER BY RN) AS LAG_
    ,LEAD(VAL) OVER (PARTITION BY 1 ORDER BY RN) AS LEAD_
    , LAG(FR)  OVER (PARTITION BY 1 ORDER BY RN) AS FR
    , LAG(LEN)  OVER (PARTITION BY 1 ORDER BY RN) AS  LEN
    ,MAX(RN)OVER (PARTITION BY 1) AS RN
     FROM (
    SELECT RECIPIENT
    ,DECODE(INSTR(RECIPIENT,'ANCHOR:'),1,SUBSTR(RECIPIENT,INSTR(RECIPIENT,'/',-1)+1,INSTR(RECIPIENT,'|',-1)-INSTR(RECIPIENT,'/',-1)-1) , NULL ) AS FR
    ,DECODE(INSTR(RECIPIENT,'ANCHOR:'),1,SUBSTR(RECIPIENT,INSTR(RECIPIENT,'|',-1)+1 ) , NULL) AS LEN
    ,CASE WHEN INSTR(RECIPIENT,'ANCHOR:')>0 THEN REGEXP_SUBSTR(VSTR, SUBSTR(RECIPIENT,INSTR(RECIPIENT,':')+1,INSTR(RECIPIENT,'+',-1)- INSTR(RECIPIENT,':') -1))
         ELSE NULL
       END  AS VAL
    ,CASE WHEN INSTR(RECIPIENT,'ANCHOR:')>0
      THEN REGEXP_INSTR(VSTR, SUBSTR(RECIPIENT,INSTR(RECIPIENT,':')+1,INSTR(RECIPIENT,'+',-1)- INSTR(RECIPIENT,':') -1),
         SUBSTR(RECIPIENT,INSTR(RECIPIENT,'+',-1)+1,INSTR(RECIPIENT,'/',-1)- INSTR(RECIPIENT,'+') -1)
         )
         ELSE NULL
       END  AS INST
     ,SUBSTR(RECIPIENT,INSTR(RECIPIENT,'+',-1)+1,INSTR(RECIPIENT,'/',-1)- INSTR(RECIPIENT,'+') -1) AS ANCH_FR
     ,ROWNUM AS RN
     FROM TABLE( CAST( KK_SMS.CREATETABLE( J.MASK  ,';') AS TRECIPIENTTABLE))
     WHERE 1=1
      )
    ) /*SELECT RECIPIENT,VAL,*/
    )
    WHERE  RECIPIENT  LIKE 'KEY:%'
       ) LOOP

      IF K.NAME = 'CODE' THEN
        DBMS_OUTPUT.PUT_LINE(K.KEY_VAL);

        FOR REC_NOM IN (
          SELECT NOMENKLATURA_N
            FROM NOM_BARCODE BC
            JOIN NOMENKLATURA N ON (N.N = BC.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
            WHERE BC.CONTRAGENT_N = PCONTRN
              AND LOWER(BC.BAR_CODE) = LOWER(K.KEY_VAL)
              AND BC.TD = KK_COMMON.GETTD
          UNION
          SELECT N AS NOMENKLATURA_N
            FROM NOMENKLATURA
            WHERE CONTRAGENT_N = PCONTRN
              AND LOWER(CODE) = LOWER(K.KEY_VAL)
              AND TD = KK_COMMON.GETTD
        )
        LOOP
            VRETVAL.EXTEND(1);
            VREC := VREC + 1;
            VRETVAL(VREC) := TCWMS_REC(REC_NOM.NOMENKLATURA_N,NULL) ;
        END LOOP;

      END IF;


    END LOOP; -- FOR K IN ( SELECT

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
               NULL;
      WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
     NULL;
    END;

 END LOOP; --FOR J IN (SELECT MASK  FROM ST_BARCODE_MASK

VRETVALFINAL := TCWMS_TABLE();
VREC := 0;

    FOR REC IN (
        SELECT DISTINCT N1
        FROM TABLE( CAST(VRETVAL AS TCWMS_TABLE))
    )
    LOOP
            VRETVALFINAL.EXTEND(1);
            VREC := VREC + 1;
            VRETVALFINAL(VREC) := TCWMS_REC(REC.N1,NULL) ;
    END LOOP;

    --RAISE_APPLICATION_ERROR(-20000,'VREC='||VREC);

 RETURN VRETVALFINAL;
END GETNOMCURSORBYUSERPROC_DEF;



FUNCTION  INPUTINDOCNOMCODE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
VEXPIRE DATE;
VRET INTEGER;
VRET_1 INTEGER;
VCONTRAGENTN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VDOCN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VNOMDOCCNT INTEGER;
VNOMFD DATE ;
VNOMTD DATE;
VBARCODE VARCHAR2(255) := NULL;
VNAME VARCHAR2(1000); --N.CODE ||' '||N.NAME HERE!
VCNT INTEGER;
VEXPDAYS INTEGER := 0;
VSTR VARCHAR2(2500);
VPARCEBARCODE INTEGER;
VDIM  VARCHAR2(500);
VDIMEXISTS INTEGER;
VNOMUNITCNT INTEGER;
VNOMUNIT INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VONLYSCANNOMCONTRAGENTS VARCHAR2(32767):= KK_CONST.GETCONSTV('ONLYSCANNOM.CONTRAGENTS',SYSDATE);
VSTRICTCODE INTEGER := KK_CONST.GETCONSTV('INPUTNOMBARCODE.STRICTCODE',SYSDATE,VCONTRAGENTN);
VINBOUNDNOMUSERPROC VARCHAR2(255);
BEGIN
 IF (PSTR IS NULL) AND (PKEYCODE IS NULL) THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА НЕ СОСКАНИРОВАНА</ERR>');
 END IF;

/*DVE KPD !!!*/
 IF (PSTR IS NOT NULL) AND (PKEYCODE IS NOT NULL) AND (PKEYCODE !='00') THEN --ДМИТРИЕВ 06.02.2015
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ЗАПОЛНЕНО ДОЛЖНО БЫТЬ ТОЛЬКО 1 ПОЛЕ!!!</ERR>');
 END IF;


  IF PSTR IS NULL AND PKEYCODE IS NOT NULL AND NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN, 'STBARCODEMANUALNOMCODEINPUT',SYSDATE), -1) !=3 THEN
    RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ НОМЕНКЛАТУРУ, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
  END IF;

 --
 IF VCONTRAGENTN IS NULL THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>КОНТРАГЕНТ НЕ ОПРЕДЕЛЕН!!!!</ERR>');
 ELSE

  IF (PSTR IS NULL ) AND ( PKEYCODE != '0') AND (
      NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN, 'STBARCODEMANUALNOMCODEINPUT',SYSDATE), -1) !=3 AND PNEXTNODE!=763
      OR (NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN, 'STBARCODEMANUALNOMCODEINPUT2',SYSDATE), -1) !=3 AND PNEXTNODE=763)
      ) THEN
    RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ НОМЕНКЛАТУРУ, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
  END IF;


  -- DBOEV TEST
  --RAISE_APPLICATION_ERROR(-20000,'PKEYCODE=!'||PKEYCODE||', PSTR='||PSTR);
  -- DBOEV TEST

 --...............................................................................
 IF PKEYCODE = '00' THEN
 VCNT := 0;
 ELSE --IF PKEYCODE = '00' THEN


     KK_BARCODE_MASK.CLEARBARCODEVAR(PROBJN,'');

    VPARCEBARCODE :=  KK_BARCODE_MASK.PARCEBARCODE(PROBJN ,PSTR,VSTR) ;

 IF (PSTR IS NOT NULL) AND VPARCEBARCODE != 0 THEN

  VBARCODE := KK_ST_BARCODE  .SESSIONVARGET  (PROBJN,'BARCODE.CODE' );
           --   KK_BARCODE_MASK.CLEARBARCODEVAR(PROBJN,'BARCODE.CODE;BARCODE.EXPIRE;BARCODE.PROD_DATE');
 END IF;

 IF VBARCODE IS NULL THEN
  --SELECT CASE WHEN LENGTH(NVL(PKEYCODE,'.'))>=3 THEN LOWER(PKEYCODE) ELSE PSTR END INTO  VBARCODE   FROM DUAL ;
  SELECT NVL(LOWER(PKEYCODE), PSTR) INTO VBARCODE  FROM DUAL ;
 END IF;


VCNT := 0;



--RAISE_APPLICATION_ERROR(-20000,'VCONTRAGENTN='||VCONTRAGENTN||'; PKEYCODE='||PKEYCODE||'; VBARCODE='||VBARCODE||'; PSTR='||PSTR||'; VPARCEBARCODE='||VPARCEBARCODE);




FOR J IN (
WITH TNOM AS
(
 SELECT/*+ ORDERED*/  N.N,N.CODE,N.CODE ||' ' ||N.NAME AS NAME ,N.EXPIRE ,B.CONTRAGENT_N , B.BAR_CODE AS BARCODE , N.UNIT, 1 AS ORD
     FROM NOM_BARCODE B
        JOIN NOMENKLATURA N ON (  B.NOMENKLATURA_N = N.N  AND SYSDATE BETWEEN N.FD AND N.TD )
   WHERE (
          (LOWER(TRIM(B.BAR_CODE)) = LOWER(TRIM(VBARCODE)) AND VBARCODE IS NOT NULL) -- ANEE A A?OA IIIAEE IA EAN UCC
       OR (LOWER(TRIM(B.BAR_CODE)) = LOWER(TRIM(PSTR    )) AND PSTR     IS NOT NULL)-- OIAAA I?INOI II OIIO ?OI NEAIE?IAAEE
          )
      AND B.TD = KK_COMMON.GETTD
      AND B.CONTRAGENT_N = VCONTRAGENTN
     UNION
  SELECT N.N ,N.CODE, N.CODE ||' '||N.NAME AS NAME ,N.EXPIRE , N.CONTRAGENT_N , N.CODE AS BARCODE , N.UNIT, 2 AS ORD
     FROM  NOMENKLATURA N
      WHERE  N.TD = KK_COMMON.GETTD
         AND (((
              (LOWER(N.CODE) LIKE '%'||LOWER(VBARCODE)||'%' AND VBARCODE IS NOT NULL) -- ANEE A A?OA IIIAEE IA EAN UCC
           OR (LOWER(N.CODE) LIKE '%'||LOWER(PSTR    )||'%' AND PSTR     IS NOT NULL) -- OIAAA I?INOI II OIIO ?OI NEAIE?IAAEE
              ) AND VSTRICTCODE = 0) OR
              ((
              (LOWER(N.CODE) = LOWER(VBARCODE) AND VBARCODE IS NOT NULL) -- ANEE A A?OA IIIAEE IA EAN UCC
           OR (LOWER(N.CODE) = LOWER(PSTR    ) AND PSTR     IS NOT NULL) -- OIAAA I?INOI II OIIO ?OI NEAIE?IAAEE
              ) AND VSTRICTCODE = 1))
         AND N.CONTRAGENT_N = VCONTRAGENTN
)
SELECT  ROWNUM AS RN,  NOMENKLATURA_N,NAME, EXPIRE , CONTRAGENT_N , COUNT(DISTINCT NOMENKLATURA_N) OVER (PARTITION BY 1) AS CNT
  ,CODE , BARCODE , UNIT
 FROM
 (
SELECT DISTINCT N AS NOMENKLATURA_N,NAME, EXPIRE , CONTRAGENT_N
  ,CODE , BARCODE , UNIT
 FROM
 (   SELECT * FROM TNOM
     UNION

      SELECT/*+ ORDERED*/
         N.N ,N.CODE, N.CODE ||' '||N.NAME AS NAME ,N.EXPIRE , N.CONTRAGENT_N , N.CODE AS BARCODE , N.UNIT, 2 AS ORD
       FROM  NOMENKLATURA N
       WHERE  N.N IN (SELECT  N1 FROM TABLE(CAST( KK_ST_BARCODE.GETNOMCURSORBYUSERPROC(VCONTRAGENTN,PKEYCODE,PSTR) AS TCWMS_TABLE))   )
       AND N.TD = KK_COMMON.GETTD
       AND NOT EXISTS (SELECT NULL FROM TNOM T WHERE T.N = N.N)

   )

)ORDER BY  RN
) LOOP


 IF J.CNT = 1 THEN

  VNOMN := J.NOMENKLATURA_N;
  VNAME := J.NAME;
  VEXPDAYS := J.EXPIRE;
  VNOMUNIT := J.UNIT;
 -- VCONTRAGENTN := J.CONTRAGENT_N;

   PMSG :=  VNAME;
   VCNT := 1 ;

 END IF; --IF J.CNT = 1 THEN

 IF J.CNT > 1 THEN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5, VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,27/*ЗАПОМНИЛИ СПИСОК КОДОВ НОМЕНКЛАТУРЫ*/,J.NOMENKLATURA_N,J.RN,J.BARCODE,J.CODE,SYSDATE,KK_COMMON.GETTD,J.UNIT,PPROCN,J.EXPIRE,J.CONTRAGENT_N)
   RETURNING N INTO PPROCN;

     SELECT SUBSTR(PMSG ||J.RN ||' - ' || /*J.CODE || */  J.NAME   ||CHR(13)|| CHR(10),1,2000) INTO PMSG FROM DUAL ;
      VCNT := VCNT +1 ;

      EXIT WHEN LENGTH(PMSG) >= 2000;

 END IF;

END LOOP;



 END IF;--IF PKEYCODE = '00' THEN

--RAISE_APPLICATION_ERROR(-20000,'VCNT='||VCNT);

    IF VCNT = 0 THEN

      IF KK_CONST.GETCONSTN('STDOCIN.INBOUND.CREATETECHNOMIFNOTEXISTS',SYSDATE,VCONTRAGENTN) = 1 THEN



      /*
      ПРИ ПРИХОДОВАНИИ ТОВАРА СОЗДАВАТЬ ИЛИ НЕТ ТЕХНИЧЕСКУЮ НОМЕНКЛАТУРУ.
      ПАРАМЕТР КОНТРАГЕНТ.
      ПРИ ВКЛЮЧЕННОЙ КОНСТАНТЕ.
      НОВАР НЕ НАЙДЕННЫЙ В СПРАВОЧНИКЕ БУДЕТ ЗАРЕГИСТРИРОВАН ТАМ АВТОМАТИЧЕСКИ (ЗНАЧЕНИЕ = 1) ,
      В ПРОТИВНОМ СЛУЧАЕ БУДЕТ СООБЩЕНИЕ ОБ ОШИБКЕ, ЧТО ТОВАР НЕ НАЙДЕН.
      */

/*        INSERT INTO NOMENKLATURA
          (N, CONTRAGENT_N, CODE, SH_CODE, NAME, GROUP_N, EXPIRE, ZONA_N, PAL_TYP, UNIT, FD, TD, TYP, TN_VED)
         VALUES
           (SQ_NOMENKLATURA.NEXTVAL, VCONTRAGENTN, 'T_'||VCONTRAGENTN||'_'||SQ_NOMENKLATURA.CURRVAL, VBARCODE, 'ТЕХНИЧЕСКАЯ НОМЕНКЛАТУРА', -1 ТЕХНИЧЕСКАЯ,   1, 0, 0, 1, KK_COMMON.GETFD, KK_COMMON.GETTD, 0, 0 )
         RETURNING
          N,FD,TD,CODE
           INTO
            VNOMN,VNOMFD,VNOMTD,VNAME ;

    INSERT INTO NOM_UNIT
         (N,NOMENKLATURA_N,UNIT_TYP,UNIT_CNT,FD,TD,WEIGHT,COST,DIMENSION_L,DIMENSION_W,DIMENSION_H,NDS,CNT_EXPONENT)
      VALUES
        (SQ_NOM_UNIT.NEXTVAL,VNOMN,1,1,VNOMFD,VNOMTD,0,0,0,0,0,0,1);


              FOR JJ IN (SELECT CODE FROM DIC_DATA WHERE UP =359 AND SYSDATE BETWEEN FD AND TD ) LOOP
               INSERT INTO NOM_BLCK (N,NOMENKLATURA_N,BLCK,FD,TD,PALL_TYPE)
               VALUES (SQ_NOM_BLCK.NEXTVAL,VNOMN,1,VNOMFD,VNOMTD,JJ.CODE);
              END LOOP;

      INSERT INTO  NOM_BARCODE
     (N , FD , TD , CONTRAGENT_N , NOMENKLATURA_N , BAR_CODE )  VALUES
     (SQ_NOMENKLATURA.NEXTVAL,SYSDATE,KK_COMMON.GETTD,VCONTRAGENTN,VNOMN,VBARCODE) ;
*/
           PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.BARCODE',VBARCODE);
           PMSG := '<ERR>ОБЯЗАТЕЛЬНО ДЛЯ СВЯЗКИ ЗАПИШИТЕ КОД ТЕХ.НОМЕНКЛАТУРЫ ' || VBARCODE ||' И КОД КОРОБА КОТОРЫЙ СКАНИРОВАЛИ!!!</ERR>';
           RETURN -3 ;
       ELSE
       RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА В СПРАВОЧНИКЕ НЕ НАЙДЕНА VBARCODE="'|| VBARCODE||'"; PSTR="'||PSTR ||'"; PKEYCODE="'||PKEYCODE||'"; ТЕХНИЧЕСКАЯ НЕ СОЗДАНА STDOCIN.INBOUND.CREATETECHNOMIFNOTEXISTS=0 VPARCEBARCODE='||VPARCEBARCODE||'</ERR>');
       END IF;   --KK_CONST.GETCONSTN('STDOCIN.INBOUND.CREATETECHNOMIFNOTEXISTS',SYSDATE,VCONTRAGENTN) = 1

    END IF; -- VTECH


  --...............................................................................


IF VCNT IN (0,1) THEN


 VDIMEXISTS := KK_ST_BARCODE.NOMCHECKDIMENTEXISTS(PNOMN =>VNOMN,PNOMUNIT => VNOMUNIT,PROBJN => PROBJN,PNOMDIMENT => VDIM ,PNOMUNITCNT => VNOMUNITCNT);


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP ,VAL5, VAL6)  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4/*ЗАПОМНИЛИ БАР КОД НОМЕНКЛАТУРЫ*/,VNOMN,PKEYCODE,VBARCODE,VNAME,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОГО НАИМЕНОВАНИЯ',PPROCN,VEXPDAYS,VCONTRAGENTN)
   RETURNING N INTO PPROCN;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);


  IF (VDIMEXISTS = 1) AND ( KK_CONST.GETCONSTN('STDOCIN.NEEDINPUTNOMDIMENTIONS',SYSDATE,VCONTRAGENTN ) = 1) THEN
   PMSG := '<ERR>НУЖНО ПРОМЕРИТЬ!</ERR>';
   RETURN -2;
   VRET := -2;
  END IF ;

----ПОЛЬЗОВАТЕЛЬСКАЯ ПРОЦЕДУРА ПРИ СКАНИРОВАНИИ НОМЕНКЛАТУРЫ
  SELECT KK_CONST.GETCONSTV('STDOCIN.INBOUND.NOM.USERPROC',SYSDATE,D.CONTRAGENT_N,D.TYP)
    INTO VINBOUNDNOMUSERPROC
  FROM ST_DOC_IN D
    WHERE D.N = VDOCN
        AND D.TD = KK_COMMON.GETTD;
--RAISE_APPLICATION_ERROR(-20001,VINBOUNDNOMUSERPROC);
  IF NVL(VINBOUNDNOMUSERPROC,'_') != '_' THEN
      EXECUTE IMMEDIATE 'BEGIN  :RET := '|| VINBOUNDNOMUSERPROC||'(:PCONTRAGENTN,:PDOCN,:PNOMN );END;'
                 USING OUT VRET_1  , IN VCONTRAGENTN, IN VDOCN , IN VNOMN ;
  END IF;
-----------------------------

--STDOCIN.INBOUND.CHECKEXISTSNOMINDOC.CONTRAGENTLIST
  IF INSTR(','||KK_CONST.GETCONSTV('STDOCIN.INBOUND.CHECKEXISTSNOMINDOC.CONTRAGENTLIST',SYSDATE)||',',','||VCONTRAGENTN||',') > 0  THEN

-- ПРОВЕРКА ЕСТЬ ЛИ ЭТА НОМЕНКЛАТУРА В ДОКУМЕНТЕ



 SELECT COUNT(1) INTO VNOMDOCCNT
 FROM ST_DOC_IN_DET D
  WHERE D.SQ_ST_DOC_IN_N =  VDOCN
  AND SYSDATE BETWEEN D.FD AND D.TD
  AND D.TYP = 0
  AND D.NOMENKLATURA_N IN
  (
              SELECT VNOMN AS NOMENKLATURA_N  FROM DUAL
              UNION ALL
              SELECT NOMENKLATURA_N
                 FROM
              (SELECT CN.NOMENKLATURA_N AS NOMENKLATURA_N
                 FROM NOM_CHANGE_NOM CN
               CONNECT BY PRIOR CN.NOMENKLATURA_N = CN.CHANGE_NOM_N
                                AND SYSDATE BETWEEN CN.FD AND CN.TD
              START WITH CN.CHANGE_NOM_N = VNOMN
                AND SYSDATE BETWEEN CN.FD AND CN.TD
                  ORDER BY CN.VAL)
             UNION ALL
              SELECT NOMENKLATURA_N
                 FROM
              (SELECT CN.CHANGE_NOM_N  AS NOMENKLATURA_N
                 FROM NOM_CHANGE_NOM CN
               CONNECT BY PRIOR CN.NOMENKLATURA_N = CN.CHANGE_NOM_N
                                AND SYSDATE BETWEEN CN.FD AND CN.TD
              START WITH CN.NOMENKLATURA_N = VNOMN
                AND SYSDATE BETWEEN CN.FD AND CN.TD
                  ORDER BY CN.VAL)

              )
   ;

  IF VNOMDOCCNT = 0 THEN
  DECLARE
   VNUMACT VARCHAR2(255);
  BEGIN
   SELECT NUM_ACT INTO VNUMACT
    FROM ST_DOC_IN
     WHERE N = VDOCN
     AND SYSDATE BETWEEN FD AND TD ;
   RAISE_APPLICATION_ERROR(-20000,'<ERR>'||VNUMACT||' НЕТ ПО ДОКУМЕНТУ:'||PMSG || '</ERR>');

  END;
  END IF;

  END IF;

 IF VNOMDOCCNT = 0 THEN
  PMSG := '<ERR>НЕТ ПО ДОКУМЕНТУ:'||PMSG ||'</ERR>' ;
 END IF;



VRET := 1;
ELSE
    PMSG := 'НАЙДЕНО '|| VCNT ||' НОМЕНКЛАТУР ПРОИЗВЕДИТЕ ВЫБОР'  ||CHR(13)|| CHR(10)|| PMSG;
VRET := 2;
END IF;



END IF; --IF VCONTRAGENTN IS NULL THEN

RETURN VRET;

END;


FUNCTION TECHNOMGROUPLIST(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VGROUPLIST LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCIN.INBOUND.CREATETECHNOM.GROUPLIST',SYSDATE,VCONTRAGENTN);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

PMSG := NULL;

FOR J IN (SELECT CODE , TERM
            FROM DIC_DATA
              WHERE UP = 354
               AND SYSDATE BETWEEN FD AND TD
               AND REPLACE(','||VGROUPLIST||',',' ','') LIKE '%,'||CODE||',%'
           UNION SELECT -1 AS CODE , 'ТЕХ. НОМЕНКЛАТУРА' FROM DUAL
           ORDER BY  1) LOOP
  PMSG := PMSG ||J.CODE || CHR(9) || J.TERM || V1310;
END LOOP;

  RETURN 1;

END TECHNOMGROUPLIST;

FUNCTION CREATETECHNOM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
VRET INTEGER;
VN INTEGER;
VCONTRAGENTN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VNOMFD DATE ;
VNOMTD DATE;
VNAME VARCHAR2(255);
VBARCODE VARCHAR2(255) := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.BARCODE');
VEMP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VGROUPLIST LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCIN.INBOUND.CREATETECHNOM.GROUPLIST',SYSDATE,VCONTRAGENTN);
VGROUPN INTEGER;
BEGIN


BEGIN
 SELECT CODE INTO VGROUPN
  FROM
  (
  SELECT CODE , TERM
            FROM DIC_DATA
              WHERE UP = 354
               AND SYSDATE BETWEEN FD AND TD
               AND REPLACE(','||VGROUPLIST||',',' ','') LIKE '%,'||CODE||',%'
           UNION SELECT -1 AS CODE , 'ТЕХ. НОМЕНКЛАТУРА' FROM DUAL

  )
  WHERE CODE = NVL(PKEYCODE,0) ;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ГРУППА ТЕХ. НОМЕНКЛАТУРЫ НЕ ОПРЕДЕЛА! ВЫБЕРИТЕ ИЗ СПИСКА! "'||VGROUPLIST||'" "'||PKEYCODE||'"</ERR>');
END;




       INSERT INTO NOMENKLATURA
          (N, CONTRAGENT_N, CODE, SH_CODE, NAME, GROUP_N, EXPIRE, ZONA_N, PAL_TYP, UNIT, FD, TD, TYP, TN_VED)
         VALUES
           (SQ_NOMENKLATURA.NEXTVAL, VCONTRAGENTN, 'T_'||VCONTRAGENTN||'_'||SQ_NOMENKLATURA.CURRVAL, VBARCODE, 'ТЕХНИЧЕСКАЯ НОМЕНКЛАТУРА', VGROUPN /*ТЕХНИЧЕСКАЯ*/,   1, 0, 0, 1, KK_COMMON.GETFD, KK_COMMON.GETTD, 0, 0 )
         RETURNING
          N,FD,TD,CODE
           INTO
            VNOMN,VNOMFD,VNOMTD,VNAME ;

         KK_COMMON.ACTION(VEMP,'NOMENKLATURA',VNOMN,1,SYSDATE,'CREATETECHNOM');

    INSERT INTO NOM_UNIT
         (N,NOMENKLATURA_N,UNIT_TYP,UNIT_CNT,FD,TD,WEIGHT,COST,DIMENSION_L,DIMENSION_W,DIMENSION_H,NDS,CNT_EXPONENT)
      VALUES
        (SQ_NOM_UNIT.NEXTVAL,VNOMN,1,1,VNOMFD,VNOMTD,0,0,0,0,0,0,1);


              FOR JJ IN (SELECT CODE FROM DIC_DATA WHERE UP =359 AND SYSDATE BETWEEN FD AND TD ) LOOP
               INSERT INTO NOM_BLCK (N,NOMENKLATURA_N,BLCK,FD,TD,PALL_TYPE)
               VALUES (SQ_NOM_BLCK.NEXTVAL,VNOMN,1,VNOMFD,VNOMTD,JJ.CODE)
                RETURNING N INTO VN;

               KK_COMMON.ACTION(VEMP,'NOM_BLCK',VN,1,SYSDATE,'CREATETECHNOM');

              END LOOP;

   IF VBARCODE IS NOT NULL THEN
      INSERT INTO  NOM_BARCODE
     (N , FD , TD , CONTRAGENT_N , NOMENKLATURA_N , BAR_CODE )  VALUES
     (SQ_NOMENKLATURA.NEXTVAL,SYSDATE,VNOMTD,VCONTRAGENTN,VNOMN,VBARCODE)
     RETURNING N INTO VN;
     KK_COMMON.ACTION(VEMP,'NOM_BARCODE',VN,1,SYSDATE,'CREATETECHNOM');
   END IF; --IF VBARCODE IS NOT NULL THEN

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP ,VAL5, VAL6)  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4/*ЗАПОМНИЛИ БАР КОД НОМЕНКЛАТУРЫ*/,VNOMN,PKEYCODE,VBARCODE,VNAME,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОГО НАИМЕНОВАНИЯ',PPROCN,0/*VEXPDAYS*/,VCONTRAGENTN)
   RETURNING N INTO PPROCN;

RETURN 1;

END CREATETECHNOM;


FUNCTION  INPUTINDOCNOMLIST(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
VNOMBAR VARCHAR2(50);
VNOMCODE VARCHAR2(250);
VCOUNT INTEGER := 0;
VRET INTEGER := 0;
VRET_1 INTEGER := 0;
VDOCN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VNOMDOCCNT INTEGER;
VDIMEXISTS INTEGER ;
VNOMUNIT INTEGER;
VDIM VARCHAR2(500);
VNOMUNITCNT INTEGER;
VINBOUNDNOMUSERPROC VARCHAR2(255);
BEGIN

 PMSG := NULL;

FOR J IN (
SELECT VAL1,VAL2,VAL3,VAL4,VAL5,VAL6,DSC
   FROM MCIS_NODES_PROC
   WHERE TYP = 27
    AND SYSDATE BETWEEN FD AND TD
 CONNECT BY PRIOR UP= N AND SYSDATE BETWEEN FD AND TD
  START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD ) LOOP

  IF J.VAL2 = TO_NUMBER(PKEYCODE) THEN

  IF J.VAL1 IS NULL THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЗНАЧЕНИЯ В СПИСКЕ НЕТ</ERR>');
  END IF;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',J.VAL1);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',J.VAL6);

   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5, VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4,J.VAL1,J.VAL4,J.VAL3,J.VAL4,SYSDATE,KK_COMMON.GETTD,PKEYCODE,PPROCN,J.VAL5,J.VAL6)
   RETURNING N INTO PPROCN;

   SELECT N.UNIT INTO VNOMUNIT
   FROM NOMENKLATURA N
   WHERE N.N=J.VAL1 AND SYSDATE BETWEEN N.FD AND N.TD AND ROWNUM<2;

      VDIMEXISTS := KK_ST_BARCODE.NOMCHECKDIMENTEXISTS(PNOMN =>J.VAL1,PNOMUNIT => VNOMUNIT,PROBJN => PROBJN,PNOMDIMENT => VDIM ,PNOMUNITCNT => VNOMUNITCNT);
  IF (VDIMEXISTS = 1) AND ( KK_CONST.GETCONSTN('STDOCIN.NEEDINPUTNOMDIMENTIONS',SYSDATE,J.VAL6 ) = 1) THEN
    PMSG := '<ERR>НУЖНО ПРОМЕРИТЬ! НЕ ЗАДАНЫ ШВГ В УЧ.ЕД.; КОНСТАНТА STDOCIN.NEEDINPUTNOMDIMENTIONS=1; PNOMN='||J.VAL1||'</ERR>';
   --RAISE_APPLICATION_ERROR(-20000,'<ERR>НУЖНО ПРОМЕРИТЬ! НЕ ЗАДАНЫ ШВГ В УЧ.ЕД.; КОНСТАНТА STDOCIN.NEEDINPUTNOMDIMENTIONS=1; PNOMN='||J.VAL1||'</ERR>');
   RETURN -2;
  END IF ;

 IF NVL(VNOMUNITCNT,0 ) = 0 THEN
  RAISE_APPLICATION_ERROR(-20000,'КОНВЕРТАЦИЯ НЕ ВЕРНА!');
 END IF;

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_UNIT.UNIT_CNT',VNOMUNITCNT);


----ПОЛЬЗОВАТЕЛЬСКАЯ ПРОЦЕДУРА ПРИ СКАНИРОВАНИИ НОМЕНКЛАТУРЫ
  IF VDOCN > 0 THEN
    SELECT KK_CONST.GETCONSTV('STDOCIN.INBOUND.NOM.USERPROC',SYSDATE,D.CONTRAGENT_N,D.TYP)
      INTO VINBOUNDNOMUSERPROC
    FROM ST_DOC_IN D
      WHERE D.N = VDOCN
          AND D.TD = KK_COMMON.GETTD;
  --RAISE_APPLICATION_ERROR(-20001,VINBOUNDNOMUSERPROC);
    IF NVL(VINBOUNDNOMUSERPROC,'_') != '_' THEN
        EXECUTE IMMEDIATE 'BEGIN  :RET := '|| VINBOUNDNOMUSERPROC||'(:PCONTRAGENTN,:PDOCN,:PNOMN );END;'
                   USING OUT VRET_1  , IN J.VAL6, IN VDOCN , IN J.VAL1 ;
    END IF;
  END IF;
-----------------------------

--STDOCIN.INBOUND.CHECKEXISTSNOMINDOC.CONTRAGENTLIST
  IF NVL(VDOCN,0) >0 AND INSTR(','||KK_CONST.GETCONSTV('STDOCIN.INBOUND.CHECKEXISTSNOMINDOC.CONTRAGENTLIST',SYSDATE)||',',','||J.VAL6||',') > 0   THEN

  -- ПРОВЕРКА ЕСТЬ ЛИ ЭТА НОМЕНКЛАТУРА В ДОКУМЕНТЕ


 SELECT COUNT(1) INTO VNOMDOCCNT
 FROM ST_DOC_IN_DET D
  WHERE D.SQ_ST_DOC_IN_N =  VDOCN
  AND SYSDATE BETWEEN D.FD AND D.TD
  AND D.TYP = 0
  AND D.NOMENKLATURA_N IN
  (
              SELECT J.VAL1 AS NOMENKLATURA_N  FROM DUAL
              UNION ALL
              SELECT NOMENKLATURA_N
                 FROM
              (SELECT CN.NOMENKLATURA_N AS NOMENKLATURA_N
                 FROM NOM_CHANGE_NOM CN
               CONNECT BY PRIOR CN.NOMENKLATURA_N = CN.CHANGE_NOM_N
                                AND SYSDATE BETWEEN CN.FD AND CN.TD
              START WITH CN.CHANGE_NOM_N = J.VAL1
                AND SYSDATE BETWEEN CN.FD AND CN.TD
                  ORDER BY CN.VAL)
             UNION ALL
              SELECT NOMENKLATURA_N
                 FROM
              (SELECT CN.CHANGE_NOM_N  AS NOMENKLATURA_N
                 FROM NOM_CHANGE_NOM CN
               CONNECT BY PRIOR CN.NOMENKLATURA_N = CN.CHANGE_NOM_N
                                AND SYSDATE BETWEEN CN.FD AND CN.TD
              START WITH CN.NOMENKLATURA_N = J.VAL1
                AND SYSDATE BETWEEN CN.FD AND CN.TD
                  ORDER BY CN.VAL)

              )
   ;


   IF VNOMDOCCNT = 0 THEN
     DECLARE
   VNUMACT VARCHAR2(255);
  BEGIN
   SELECT NUM_ACT INTO VNUMACT
    FROM ST_DOC_IN
     WHERE N = VDOCN
     AND SYSDATE BETWEEN FD AND TD ;
   RAISE_APPLICATION_ERROR(-20000,'<ERR>'||VNUMACT||' НЕТ ПО ДОКУМЕНТУ:'|| J.VAL4 || '</ERR>');

  END;

   END IF; --IF VNOMDOCCNT = 0 THEN

  END IF; --IF INSTR(','||KK_CONST.GETCONSTV('

 IF VNOMDOCCNT = 0 THEN
  PMSG := '<ERR>НЕТ ПО ДОКУМЕНТУ:' ||  J.VAL4||'</ERR>' ;
 ELSE
  PMSG :=                         'ВЫБРАНО ' ||  J.VAL4;
 END IF;


    VRET :=1 ;
   EXIT;
  END IF; --IF J.VAL2 = TO_NUMBER(PKEYCODE) THEN



END LOOP;
--RAISE_APPLICATION_ERROR(-20000,'SSS');

IF VRET = 0 THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>ЗНАЧЕНИЕ НЕ ИЗ СПИСКА</ERR>');
END IF;

IF VRET = 1 THEN
 UPDATE MCIS_NODES_PROC SET TD = SYSDATE
  WHERE ROWID IN
  (SELECT ROWID
    FROM MCIS_NODES_PROC
      WHERE TYP = 27
       AND SYSDATE BETWEEN FD AND TD
       CONNECT BY PRIOR UP= N AND SYSDATE BETWEEN FD AND TD
         START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD) ;

RETURN 1;
END IF;

END INPUTINDOCNOMLIST;

FUNCTION  REINPUTPARTNUM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=     NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0);
VPART INTEGER := 0;
VPARTNUM VARCHAR2(500):= NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PART.PART_NUM'),'_') ;
--VCHECKUNIQUEPARTPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCIN.CHECKUNIQUEPART.USERPROC',SYSDATE,VCONTRAGENTN);
VRET INTEGER; /* БЕЗ ПРОВЕРКИ НА УНИКАЛЬНОСТЬ*/
BEGIN
  IF VPARTNUM='_' THEN
    NULL; --RAISE_APPLICATION_ERROR(-20000,'НЕ УКАЗАНА ПАРТИЯ ("'||VPARTNUM||'")');
  ELSE
  BEGIN
   SELECT N INTO VPART
    FROM ST_PART
     WHERE LOWER(TRIM(VPARTNUM)) = LOWER(TRIM(PART_NUM))
      AND TD = KK_COMMON.GETTD
      AND CONTRAGENT_N = VCONTRAGENTN
      AND ROWNUM<2;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN

      INSERT INTO ST_PART
          (N,CONTRAGENT_N,PART_NUM,FD,TD,DSC)
      VALUES
          (SQ_ST_PART.NEXTVAL,NVL(VCONTRAGENTN,0),VPARTNUM,KK_COMMON.GETFD,KK_COMMON.GETTD,'ПРИХОДОВАНИЕ ПО ФАКТУ')
          RETURNING N INTO VPART;

      PMSG := 'ЗАРЕГИСТРИРОВАНА НОВАЯ ПАРТИЯ '||VPARTNUM;
   END;



  INSERT INTO MCIS_NODES_PROC
       (N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )
  VALUES
       (SQ_MCIS_NODES_PROC.NEXTVAL,19/*ЗАПОМНИЛИ ПАРТИЮ*/,VPART,/*TRIM(UPPER(PKEYCODE))*/VPARTNUM,PSTR,VPARTNUM,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР ПАРТИИ',PPROCN)
        RETURNING N INTO PPROCN;

  PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',VPART);
  PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.PART_NUM',VPARTNUM);
  END IF;
  RETURN 1;
END REINPUTPARTNUM;

FUNCTION  INPUTPARTNUM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=     NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0);
VDOCN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VPART INTEGER := 0;
VPARTNUM VARCHAR2(50);
VCHECKUNIQUEPARTPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCIN.CHECKUNIQUEPART.USERPROC',SYSDATE,VCONTRAGENTN);
VRET INTEGER :=-1;
VRET2 INTEGER;  /*С ПРОВЕРКОЙ НА УНИКАЛЬНОСТЬ*/
VSTR VARCHAR2(1500);
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VGROUPN INTEGER;
VNEEDPARCEPARTNUMBYMASK INTEGER := KK_CONST.GETCONSTN('CONTRAGENT.NEEDPARCEPARTNUMBYMASK',SYSDATE,VCONTRAGENTN);
VNEEDPARCEGROUPLIST VARCHAR2(200) := KK_CONST.GETCONSTV('CONTRAGENT.NEEDPARCEPARTNUMBYMASKGROUPLIST',SYSDATE,VCONTRAGENTN);
BEGIN

 SELECT TRIM(UPPER(PSTR||DECODE(PKEYCODE,NULL,NULL,DECODE(PSTR,NULL,NULL,'/')||PKEYCODE))) INTO VPARTNUM FROM DUAL;

--НА СЛУЧАЙ, ЕСЛИ ВКЛЮЧЕНА МАСКА ПО ШТРИХ-КОДУ
SELECT GROUP_N INTO VGROUPN FROM NOMENKLATURA WHERE N=VNOMN AND ROWNUM<2;
IF  VNEEDPARCEPARTNUMBYMASK = 1
AND VPARTNUM!='0'
AND (VNEEDPARCEGROUPLIST='0' OR VNEEDPARCEGROUPLIST LIKE '%,'||VGROUPN||',%')  THEN
 IF   KK_BARCODE_MASK.PARCEBARCODE(PROBJN,VPARTNUM,VSTR)!=0 THEN
    VPARTNUM :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.PART_NUM');
 ELSE
    RAISE_APPLICATION_ERROR(-20000,'НЕКОРРЕКТНО УКАЗАНА ПАРТИЯ:'||VPARTNUM);
 END IF;--IF KK_BARCODE_MASK.PARCEBARCODE(PROBJN,VPARTNUM,VSTR)!=0 THEN
END IF;--IF VNEEDPARCEPARTNUMBYMASK = 1 THEN

IF VPARTNUM <> '0' THEN

    IF VCHECKUNIQUEPARTPROC = '_' THEN
      VRET:=1; --ПАРТИЯ НЕ ДОЛЖНА БЫТЬ УНИКАЛЬНОЙ ВООБЩЕ
    ELSE
         EXECUTE IMMEDIATE 'BEGIN  :RET := '|| VCHECKUNIQUEPARTPROC||'(:PCONTRAGENTN ,:PDOCN,:PARTNUM , :PROBJN );  END;'
                 USING OUT VRET  , IN VCONTRAGENTN, IN VDOCN , IN VPARTNUM , IN OUT PROBJN;
         --ПРОВЕРЯЕМ, УНИКАЛЬНА ИЛИ НЕТ, ПО ИМЕНИ ПАРТИИИ
     END IF;
     --ЕСЛИ VRET=1, ТО ЕСТЬ УНИКАЛЬНА, ТОГДА ИЛИ ЗАПОМИНАЕМ НОМЕР, ИЛИ РЕГИСТРИРУЕМ НОВУЮ
     --ЕСЛИ -1,     ТО НЕТ СМЫСЛА НИ ИСКАТЬ, НЕ РЕГИСТРИРОВАТЬ НОВУЮ, В  MCIS_NODES_PROC ПИШЕМ, НО ВОЗВРАЩАЕМ ФУНКЦИЕЙ -1

   IF VRET=1 THEN

       PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.PART_NUM',VPARTNUM);
       VRET2:=REINPUTPARTNUM(PKEYCODE, PSTR, PMSG ,PNEXTNODE ,PPROCN ,PROBJN); /*ЗАПИСАЛИ ПАРТИЮ, ЕСЛИ ТОЧНО ТАКОЙ НЕТ, ЗАПОМНИЛИ НОМЕР ПАРТИИ В ЛЮБОМ СЛУЧАЕ*/

       /*ПЕРЕМЕННЫЕ 'PART.N' И 'PART.PART_NUM' УЖЕ ЗАПИСАНЫ, MCIS_NODES_ТОЖЕ*/

  ELSE --VRET=-1 ПАРТИЯ НЕУНИКАЛЬНА
    PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',0);
    PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.PART_NUM',VPARTNUM);

  END IF; --IF VRET
ELSE
  IF (NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'INPUTPARTNUMCANCEL',SYSDATE),0) <> 3) THEN
      RAISE_APPLICATION_ERROR(-20000,  '<ERR>У ВАС НЕТ ДОСТУПА НА ПРОПУСК ПАРТИИ!</ERR>');
    END IF;

  VRET :=1;
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,19/*ЗАПОМНИЛИ ПАРТИЯ*/,VPART,TRIM(UPPER(PKEYCODE)),PSTR,VPARTNUM,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР ПАРТИИ',PPROCN)
   RETURNING N INTO PPROCN;

  PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',VPART);
END IF;

RETURN VRET;

END INPUTPARTNUM;


FUNCTION  INPUTPARTNUMINV(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=     NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0);
VDOCN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VPART INTEGER := 0;
VPARTNUM VARCHAR2(50);
VCHECKUNIQUEPARTPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCINV.CHECKUNIQUEPART.USERPROC',SYSDATE,VCONTRAGENTN);
VRET INTEGER :=-1;
VRET2 INTEGER;  /*С ПРОВЕРКОЙ НА УНИКАЛЬНОСТЬ*/
VSTR VARCHAR2(1500);
VNEEDPARCEPARTNUMBYMASK INTEGER := KK_CONST.GETCONSTN('CONTRAGENT.NEEDPARCEPARTNUMBYMASK',SYSDATE,VCONTRAGENTN);
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
BEGIN

 SELECT TRIM(UPPER(PSTR||DECODE(PKEYCODE,NULL,NULL,DECODE(PSTR,NULL,NULL,'/')||PKEYCODE))) INTO VPARTNUM FROM DUAL;

--НА СЛУЧАЙ, ЕСЛИ ВКЛЮЧЕНА МАСКА ПО ШТРИХ-КОДУ
IF VNEEDPARCEPARTNUMBYMASK = 1 THEN
 IF KK_BARCODE_MASK.PARCEBARCODE(PROBJN,VPARTNUM,VSTR)!=0 THEN
    VPARTNUM :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.PART_NUM');
 ELSE
    RAISE_APPLICATION_ERROR(-20000,'НЕКОРРЕКТНО УКАЗАНА ПАРТИЯ:'||VPARTNUM);
 END IF;--IF KK_BARCODE_MASK.PARCEBARCODE(PROBJN,VPARTNUM,VSTR)!=0 THEN
END IF;--IF VNEEDPARCEPARTNUMBYMASK = 1 THEN

IF VPARTNUM <> '0' THEN

    IF VCHECKUNIQUEPARTPROC = '_' THEN
      VRET:=1; --ПАРТИЯ НЕ ДОЛЖНА БЫТЬ УНИКАЛЬНОЙ ВООБЩЕ
    ELSE
         EXECUTE IMMEDIATE 'BEGIN  :RET := '|| VCHECKUNIQUEPARTPROC||'(:PCONTRAGENTN ,:PDOCN,:PARTNUM , :PROBJN );  END;'
                 USING OUT VRET  , IN VCONTRAGENTN, IN VDOCN , IN VPARTNUM , IN OUT PROBJN;
         --ПРОВЕРЯЕМ, УНИКАЛЬНА ИЛИ НЕТ, ПО ИМЕНИ ПАРТИИИ
     END IF;
     --ЕСЛИ VRET=1, ТО ЕСТЬ УНИКАЛЬНА, ТОГДА ИЛИ ЗАПОМИНАЕМ НОМЕР, ИЛИ РЕГИСТРИРУЕМ НОВУЮ
     --ЕСЛИ -1,     ТО НЕТ СМЫСЛА НИ ИСКАТЬ, НЕ РЕГИСТРИРОВАТЬ НОВУЮ, В  MCIS_NODES_PROC ПИШЕМ, НО ВОЗВРАЩАЕМ ФУНКЦИЕЙ -1

   IF VRET=1 THEN

       PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.PART_NUM',VPARTNUM);
       VRET2:=REINPUTPARTNUM(PKEYCODE, PSTR, PMSG ,PNEXTNODE ,PPROCN ,PROBJN); /*ЗАПИСАЛИ ПАРТИЮ, ЕСЛИ ТОЧНО ТАКОЙ НЕТ, ЗАПОМНИЛИ НОМЕР ПАРТИИ В ЛЮБОМ СЛУЧАЕ*/

       /*ПЕРЕМЕННЫЕ 'PART.N' И 'PART.PART_NUM' УЖЕ ЗАПИСАНЫ, MCIS_NODES_ТОЖЕ*/
  ELSE --VRET=-1 ПАРТИЯ НЕУНИКАЛЬНА
    PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',0);
    PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.PART_NUM',VPARTNUM);

  END IF; --IF VRET
ELSE
  IF (NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'INPUTPARTNUMCANCEL',SYSDATE),0) <> 3) THEN
      RAISE_APPLICATION_ERROR(-20000,  '<ERR>У ВАС НЕТ ДОСТУПА НА ПРОПУСК ПАРТИИ!</ERR>');
    END IF;

  VRET :=1;
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,19/*ЗАПОМНИЛИ ПАРТИЯ*/,VPART,TRIM(UPPER(PKEYCODE)),PSTR,VPARTNUM,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР ПАРТИИ',PPROCN)
   RETURNING N INTO PPROCN;

  PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',VPART);
END IF;

RETURN VRET;

END INPUTPARTNUMINV;

FUNCTION  INPUTPARTNUMX(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VPART INTEGER := 0;
VPARTNUM VARCHAR2(500);
VSTR VARCHAR2(1500);
VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VGROUPN INTEGER;
VNEEDPARCEPARTNUMBYMASK INTEGER := KK_CONST.GETCONSTN('CONTRAGENT.NEEDPARCEPARTNUMBYMASK',SYSDATE,VCONTRAGENTN);
VNEEDPARCEGROUPLIST VARCHAR2(200) := KK_CONST.GETCONSTV('CONTRAGENT.NEEDPARCEPARTNUMBYMASKGROUPLIST',SYSDATE,VCONTRAGENTN);
BEGIN

 -- SELECT TRIM(UPPER(PSTR||DECODE(PKEYCODE,NULL,NULL,DECODE(PSTR,NULL,NULL,'/')||PKEYCODE))) INTO VPARTNUM FROM DUAL;
 -- DVE 27.10.2014 РВАНУЛО НА КЛ ТК У НИХ С ПРИХОДА ЧЕРЕЗ ПРОБЕЛ
  SELECT TRIM(UPPER(PKEYCODE||DECODE(PSTR,NULL,NULL,DECODE(PKEYCODE,NULL,NULL,' ')||PSTR))) INTO VPARTNUM FROM DUAL;


--НА СЛУЧАЙ, ЕСЛИ ВКЛЮЧЕНА МАСКА ПО ШТРИХ-КОДУ
SELECT GROUP_N INTO VGROUPN FROM NOMENKLATURA WHERE N=VNOMN AND ROWNUM<2;
IF  VNEEDPARCEPARTNUMBYMASK = 1
AND VPARTNUM!='0'
AND (VNEEDPARCEGROUPLIST='0' OR VNEEDPARCEGROUPLIST LIKE '%,'||VGROUPN||',%')  THEN
 IF   KK_BARCODE_MASK.PARCEBARCODE(PROBJN,VPARTNUM,VSTR)!=0 THEN
    VPARTNUM :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.PART_NUM');
 ELSE
    RAISE_APPLICATION_ERROR(-20000,'НЕКОРРЕКТНО УКАЗАНА ПАРТИЯ:'||VPARTNUM);
 END IF;--IF KK_BARCODE_MASK.PARCEBARCODE(PROBJN,VPARTNUM,VSTR)!=0 THEN
END IF;--IF VNEEDPARCEPARTNUMBYMASK = 1 THEN

IF VPARTNUM <> '0' THEN

BEGIN

SELECT N INTO VPART
 FROM ST_PART
  WHERE LOWER(PART_NUM) = LOWER(VPARTNUM)      --LIKE '%'||LOWER(VPARTNUM) ||'%' МОЛОЧНИКОВ 5.05.2012
   AND SYSDATE BETWEEN FD AND TD
   AND CONTRAGENT_N = NVL(VCONTRAGENTN,0)
   AND ROWNUM <=1;

PMSG := 'ПАРТИЯ '||VPARTNUM;

EXCEPTION
  WHEN NO_DATA_FOUND THEN

INSERT INTO ST_PART
(N,CONTRAGENT_N,PART_NUM,FD,TD,DSC) VALUES
(SQ_ST_PART.NEXTVAL,NVL(VCONTRAGENTN,0),VPARTNUM,KK_COMMON.GETFD,KK_COMMON.GETTD,'ПРИХОДОВАНИЕ ПО ФАКТУ')
RETURNING N INTO VPART;

PMSG := 'ЗАРЕГИСТРИРОВАНА НОВАЯ ПАРТИЯ '||VPARTNUM;

END;

END IF;



INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,19/*ЗАПОМНИЛИ ПАРТИЯ*/,VPART,TRIM(UPPER(PKEYCODE)),PSTR,VPARTNUM,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР ПАРТИИ',PPROCN)
   RETURNING N INTO PPROCN;

  PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',VPART);


RETURN 1;

END;



FUNCTION  INPUTCOPYLASTPALL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPREVN INTEGER;
VSTDOCINDETN INTEGER ;
VRD ROWID;
VPALLN INTEGER;
VCNT INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VPREVDOCN INTEGER;
VOP_FD DATE ;
VDOCN INTEGER;
VNOMN INTEGER;
VMORE INTEGER;
VMSG VARCHAR2(500);
VMSGX VARCHAR2(500);
BEGIN

SELECT CASE WHEN INSTR(NVL(PSTR,'P-'||PKEYCODE),'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(NVL(PSTR,PKEYCODE),'P-','') ) INTO  VPALLN FROM DUAL;


SELECT/*+ INDEX_DESC(D ST_DOC_IN_DET_PALL_N)*/
   COUNT(1) INTO VCNT
  FROM ST_DOC_IN_DET D
    WHERE D.PALL_N = VPALLN
     AND SYSDATE BETWEEN D.FD AND D.TD ;

IF VCNT <> 0 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА УЖЕ ЗАРЕГИСТРИРОВАНА!!!!/<ERR>');
END IF;


SELECT COUNT(1) INTO VCNT
 FROM
 PALL P
  WHERE P.N =VPALLN
   AND SYSDATE BETWEEN P.FD AND P.TD ;

IF VCNT != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА В СИСТЕМЕ НЕ ЗАРЕГИСТРИРОВАНА!</ERR>');
END IF;

/*
BEGIN
 SELECT TO_NUMBER(REPLACE(PKEYCODE,' ','')) INTO VCNT FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VCNT := 0;
END;
*/

FOR J IN (SELECT VAL1,VAL3,ROWID AS RD
  FROM MCIS_NODES_PROC P
    WHERE TYP =20
       AND SYSDATE BETWEEN FD AND TD

   CONNECT BY PRIOR UP = N
    START WITH N = PPROCN


      ORDER BY LEVEL) LOOP

 VPREVN := J.VAL1;
 VPREVDOCN := J.VAL3;
 VRD  := J.RD;

 EXIT;

END LOOP;






FOR J IN (

SELECT SQ_ST_DOC_IN_N,NOMENKLATURA_N,NUM_SER,NUM_ADD,EXPIRE_DATE,CNT_DOC,CNT_BRAK,CNT_IN,DSC,FD,TD,NOM_CODE,NOM_NAME,PALL_TYPE_N,TYP, PALL_N, NOM_TYP,PALL_TYPE,ST_PART_N,DISTRIB_ON_CELL,WEIGHT,MANUFACTURER,IMPORTER,UNIT_CNT,MAKE_DATE
FROM ST_DOC_IN_DET WHERE
   N = VPREVN
   AND SYSDATE BETWEEN FD AND TD

 ) LOOP

 INSERT INTO ST_DOC_IN_DET
( N,SQ_ST_DOC_IN_N,NOMENKLATURA_N,NUM_SER,NUM_ADD,EXPIRE_DATE,CNT_DOC,CNT_BRAK,CNT_IN,DSC,FD,TD,NOM_CODE,NOM_NAME,PALL_TYPE_N,TYP,PALL_N ,NOM_TYP,PALL_TYPE,ST_PART_N,DISTRIB_ON_CELL,PRM_USERS_N,WEIGHT,MANUFACTURER,IMPORTER,UNIT_CNT,MAKE_DATE)
VALUES
 (SQ_ST_DOC_DET.NEXTVAL,J.SQ_ST_DOC_IN_N,J.NOMENKLATURA_N,J.NUM_SER,J.NUM_ADD,J.EXPIRE_DATE,J.CNT_DOC,J.CNT_BRAK,J.CNT_IN,J.DSC,SYSDATE,KK_COMMON.GETTD,J.NOM_CODE,J.NOM_NAME,J.PALL_TYPE_N,J.TYP,VPALLN ,J.NOM_TYP,J.PALL_TYPE,J.ST_PART_N,J.DISTRIB_ON_CELL,VEMPN,J.WEIGHT,J.MANUFACTURER,J.IMPORTER,J.UNIT_CNT,J.MAKE_DATE)
 RETURNING N,SQ_ST_DOC_IN_N,NOMENKLATURA_N INTO VSTDOCINDETN,VDOCN,VNOMN ;

 KK_ST_NOM_TYP.COPYVALUES(PSTDOCTYP => 1, PSTDOCN => VSTDOCINDETN, PSTDOCTYPFROM => 1, PSTDOCNFROM => VPREVN);
 KK_ST_STATUS_CHANGE.STDOCINDET_USERCHEQUEPROC(PROBJN  , VEMPN,J.SQ_ST_DOC_IN_N , VSTDOCINDETN,J.NOMENKLATURA_N,VMSG,1/*ПРИЕМКА*/);

 KK_COMMON.ACTION(VEMPN,'ST_DOC_IN_DET',VSTDOCINDETN,1,SYSDATE,'PALLCOPY');
 UPDATE PALL
  SET
   WEIGHT = (SELECT DISTINCT WEIGHT FROM PALL WHERE N = J.PALL_N AND SYSDATE BETWEEN FD AND TD),
   WEIGHT2 = (SELECT DISTINCT WEIGHT2 FROM PALL WHERE N = J.PALL_N AND SYSDATE BETWEEN FD AND TD)
   WHERE N = VPALLN
   AND SYSDATE BETWEEN FD AND TD ;


 SELECT NVL( TO_DATE(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'OP_FD'),'DD.MM.YYYY HH24:MI:SS' ) , SYSDATE)
   INTO VOP_FD FROM DUAL ;

KK_ST_BAR_JOBS.CREATEJOBONEMP(PROBJN ,VSTDOCINDETN,1,1,1,VPALLN,3/*СТАТУС ЗАДАНИЯ ВЫПОЛНЕНО*/,SYSDATE,0/*VCONTRAGENT*/,J.NOMENKLATURA_N,J.SQ_ST_DOC_IN_N,VOP_FD);

END LOOP;


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,20/*ПОСЛЕДНИЙ ПРИХОДОВАННЫЙ ПАЛЛЕТ*/,VSTDOCINDETN,VPALLN,VPREVDOCN,SYSDATE,KK_COMMON.GETTD,'ПОСЛЕДНИЙ ПРИХОДОВАННЫЙ ПАЛЛЕТ',PPROCN)
   RETURNING N INTO PPROCN;

  PROBJN:= KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PID',VPALLN);

   UPDATE MCIS_NODES_PROC SET TD = SYSDATE
    WHERE ROWID = VRD;


    PMSG := 'СКОПИРОВАНО НА P-'||VPALLN;

  VMORE :=  KK_ST_BARCODE.STDOCINDETDIFF(PROBJN,VDOCN,VNOMN,PMSG,KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMMANUFACTUREN'),KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMIMPORTERN'));--VMSGX);

--RAISE_APPLICATION_ERROR(-20000,'VMSGX='||VMSGX);

  -- SELECT PMSG ||V1310 ||  VMSGX   INTO PMSG FROM DUAL;

   SELECT DECODE(SIGN(VMORE),1,'<ERR>'||PMSG||'</ERR>',PMSG) INTO PMSG FROM DUAL;



RETURN 1;

END;

FUNCTION STDOCINDETDIFF(PROBJN IN OUT INTEGER ,PDOCN INTEGER,PNOMN INTEGER,PMSG IN OUT VARCHAR2
, PMANUFACTURER_N INTEGER DEFAULT 0, PIMPORTER_N INTEGER DEFAULT 0) RETURN INTEGER IS
VPROC LIST_CONST.VAL%TYPE ;
VRET INTEGER:=0;
BEGIN

   VPROC := KK_CONST.GETCONSTV('STDOCINDETDIFF.PROCNAME',SYSDATE,KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N' ));

--RAISE_APPLICATION_ERROR(-20000,VPROC||'; '||KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N' ));

 IF NVL(VPROC,'_') = '_' THEN
     VRET:=KK_ST_BARCODE.STDOCINDETDIFF_DEF(PROBJN, PDOCN ,PNOMN ,PMSG , PMANUFACTURER_N , PIMPORTER_N );
 ELSE

    EXECUTE IMMEDIATE 'BEGIN :PRET:='||VPROC||'(:PROBJN, :PDOCN ,:PNOMN ,:PMSG , :PMANUFACTURER_N , :PIMPORTER_N ); END;'
         USING OUT VRET , IN  OUT PROBJN , IN PDOCN , IN  PNOMN , IN OUT PMSG ,  IN PMANUFACTURER_N ,  IN PIMPORTER_N;

 END IF;
RETURN VRET;
END STDOCINDETDIFF;

FUNCTION STDOCINDETDIFF_DEF(PROBJN IN OUT INTEGER, PDOCN INTEGER
,PNOMN INTEGER,PMSG IN OUT VARCHAR2
, PMANUFACTURER_N INTEGER DEFAULT 0, PIMPORTER_N INTEGER DEFAULT 0) RETURN INTEGER IS
VMORE INTEGER;
VDOCCNT INTEGER;
VINCNT INTEGER;
VMSG VARCHAR2(4000);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
--RAISE_APPLICATION_ERROR(-20000,'PMANUFACTURER_N='||PMANUFACTURER_N||'  PDOCN='||PDOCN||'  PNOMN='||PNOMN);
SELECT
D1.CNT  -   D0.CNT  --DECODE(D0.CNT,0,-1,D0.CNT ) ХЗ ЗАЧЕМ ТАК НАПИСАНО (ДМИТРИЕВ 26,10,2016)
,D0.CNT , D1.CNT
 INTO VMORE,VDOCCNT,VINCNT

 FROM (
SELECT NVL(SUM(NVL(D0.CNT_IN,0)+NVL(D0.CNT_BRAK,0)),0)   AS CNT
 FROM ST_DOC_IN_DET  D0
 WHERE
 D0.SQ_ST_DOC_IN_N = PDOCN
AND D0.NOMENKLATURA_N = PNOMN
AND (D0.MANUFACTURER=PMANUFACTURER_N OR NVL(PMANUFACTURER_N,0)=0)
AND (D0.IMPORTER=PIMPORTER_N OR NVL(PIMPORTER_N,0)=0)
AND SYSDATE BETWEEN D0.FD AND D0.TD
AND D0.TYP = 0
  ) D0
  FULL OUTER JOIN
(
SELECT NVL(SUM(NVL(D0.CNT_IN,0)+NVL(D0.CNT_BRAK,0)),0)  AS CNT, COUNT(DISTINCT PALL_N)   AS PALL_N
 FROM ST_DOC_IN_DET  D0
 WHERE
 D0.SQ_ST_DOC_IN_N = PDOCN
AND D0.NOMENKLATURA_N = PNOMN
AND (D0.MANUFACTURER=PMANUFACTURER_N OR NVL(PMANUFACTURER_N,0)=0)
AND (D0.IMPORTER=PIMPORTER_N OR NVL(PIMPORTER_N,0)=0)
AND SYSDATE BETWEEN D0.FD AND D0.TD
AND D0.TYP = 1
  ) D1   ON (1=1) ;
  --PMSG := NULL;
--RAISE_APPLICATION_ERROR(-20000,'VDOCCNT='||VDOCCNT||  '  PNOMN='||PNOMN||   '  VINCNT='||VINCNT||  '  VMORE='||VMORE||);
   SELECT CODE||' '||SUBSTR(NAME,1,15) || V1310 ||
   'ПО ДОКУМЕНТУ:'||DECODE(VDOCCNT,0,'0',KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(PNOMN,VDOCCNT))|| V1310 ||
   'ПРИНЯТО:'     ||DECODE(VINCNT,0,'0',KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(PNOMN,VINCNT))|| V1310 ||
        DECODE(SIGN(VMORE),1,'ИЗЛИШЕК: '||KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(PNOMN,VMORE)
        ,'НУЖНО: '||KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(PNOMN,ABS(VMORE)))
        INTO VMSG FROM NOMENKLATURA
         WHERE N = PNOMN
         AND SYSDATE BETWEEN FD AND TD;

   SELECT PMSG ||V1310 ||  VMSG   INTO PMSG FROM DUAL;

   RETURN VMORE;

END STDOCINDETDIFF_DEF;

FUNCTION  INPUTPALLTYPES(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VNOMENKLATURAN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
    VBLCK INTEGER;
BEGIN

/*ПЕРЕПИСАН ТАК КАК ИСПОЛЬЗУЕТСЯ В ПОШТУЧНОЙ ПРИЕМКЕ, ГДЕ НОМЕНКЛАТУРА СКАНИРУЕТСЯ ПОСЛЕ ПИД*/
SELECT
   DISTINCT DD.TERM,
            DECODE(NVL(VNOMENKLATURAN,0),0,NULL,
                   DECODE(NVL(NB.BLCK,0),
                          0,-1,
                          NB.BLCK) )
   INTO PMSG, VBLCK
  FROM DIC_DATA DD
  LEFT OUTER JOIN NOM_BLCK NB ON (NB.PALL_TYPE = DD.CODE
                            AND NB.NOMENKLATURA_N = VNOMENKLATURAN
                            AND NVL(VNOMENKLATURAN,0) !=0
                            AND SYSDATE BETWEEN NB.FD AND NB.TD)
  WHERE DD.UP=359
           AND  SYSDATE BETWEEN DD.FD AND DD.TD
           AND DD.CODE = TO_NUMBER(PKEYCODE);
/*-----------------------*/

/*-----------------------*/
IF VBLCK=-1 THEN /*АВТОКОНВЕРТАЦИЯ ПАЛЛЕТИЗАЦИИ*/
BEGIN
 VBLCK:= KK_ST_DOC_NEW.GETNOMBLCKBYPALLTYP( PNOMENKLATURAN  => VNOMENKLATURAN,
                                            PPALLTYP        => TO_NUMBER(PKEYCODE) ,
                                            PRAISEEXCEPTION => 1);
 PMSG:='(ТИП ПАЛЛЕТЫ '||PKEYCODE||' НЕ ОПИСАН В НОМЕНКЛАТУРЕ, ПО АВТОМАТИЧЕСКОЙ КОНВЕРТАЦИИ ПОЛУЧЕНА ПАЛЛЕТИЗАЦИЯ '||VBLCK||'.)';
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
  VBLCK := -1 ;
END;
END IF;


    INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP )  VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,6/*ЗАПОМНИЛИ ТИП ПАЛЛЕТА*/,VBLCK,TO_NUMBER(PKEYCODE),PSTR,PMSG,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ТИП ПАЛЛЕТА',PPROCN)
       RETURNING N INTO PPROCN;
       PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PALL_TYPE',TO_NUMBER(PKEYCODE));
       PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN.PALL_TYPE',TO_NUMBER(PKEYCODE));
       PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN.BLCK',VBLCK);

    IF NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0) = 1 THEN
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_PALL_TYPE',TO_NUMBER(PKEYCODE));
    END IF;

IF VBLCK = -1 THEN
RETURN 3;
END IF;

RETURN 1;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ТАКОЙ ТИП ПАЛЛЕТА НЕ ЗАРЕГИСТРИРОВАН </ERR>VNOMENKLATURAN='||VNOMENKLATURAN);
END;

FUNCTION  INPUTMOVEN(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VSTDOCMOVEN INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
PMSG := NULL;
VSTDOCMOVEN := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_MOVE.N'),0);
IF VSTDOCMOVEN = 0 THEN
    BEGIN
        SELECT M.N INTO VSTDOCMOVEN
            FROM ST_DOC_MOVE M
        WHERE  M.N = TO_NUMBER(PSTR)
            AND  SYSDATE BETWEEN M.FD AND M.TD;
        EXCEPTION
            WHEN OTHERS THEN
                PMSG :=  PMSG || '<ERR>АКТ ПО НОМЕРУ НЕ НАЙДЕН!</ERR>' ||
                V1310 ||'СКАНИРУЙТЕ НОМЕР АКТА';
                RETURN 2;
        END;
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_MOVE.N',VSTDOCMOVEN);
END IF;

RETURN 1;

END;

FUNCTION INPUTPALLHEIGHT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,7/*ЗАПОМНИЛИ ВЫСОТУ ПАЛЛЕТА*/,NULL,TO_NUMBER(PKEYCODE),PSTR,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ВЫСОТУ ПАЛЛЕТА',PPROCN)
   RETURNING N INTO PPROCN;
PROBJN:=KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PALL_H',TO_NUMBER(PKEYCODE));
RETURN 1;

END;

FUNCTION INPUTPALLWIDTH(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,8/*ЗАПОМНИЛИ ШИРИНУ ПАЛЛЕТА*/,NULL,TO_NUMBER(PKEYCODE),PSTR,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ШИРИНУ ПАЛЛЕТА',PPROCN)
   RETURNING N INTO PPROCN;
PROBJN:=KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PALL_W',TO_NUMBER(PKEYCODE));
RETURN 1;

END;

FUNCTION INPUTPALLDEEP(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,9/*ЗАПОМНИЛИ ГЛУБИНУ ПАЛЛЕТА*/,NULL,TO_NUMBER(PKEYCODE),PSTR,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ГЛУБИНУ ПАЛЛЕТА',PPROCN)
   RETURNING N INTO PPROCN;
PROBJN:=KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PALL_L',TO_NUMBER(PKEYCODE));
RETURN 1;

END;


FUNCTION KINDPALLWEIGHT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VWEIGHT_NETTO NUMBER;
VWEIGHT_BRUTTO NUMBER;
VRET INTEGER;
BEGIN



 BEGIN
  SELECT NVL(TO_NUMBER(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.WEIGHT_NETTO'),'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0)
     INTO VWEIGHT_NETTO
       FROM DUAL;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VWEIGHT_NETTO := 0;
 END;

 BEGIN
  SELECT NVL(TO_NUMBER(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.WEIGHT_BRUTTO'),'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0)
     INTO VWEIGHT_BRUTTO
       FROM DUAL;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VWEIGHT_BRUTTO := 0;
 END;


IF VWEIGHT_NETTO <=0 AND VWEIGHT_BRUTTO <= 0 THEN
BEGIN
  SELECT TO_NUMBER(DECODE(PKEYCODE,'0','0','1','1','_')) INTO VN
    FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВЕРНОЕ ЗНАЧЕНИЕ!</ERR>');
END;
  VRET := 1;
ELSE
--0-БРУТТО
--1-НЕТТО
   SELECT CASE WHEN VWEIGHT_NETTO > 0  THEN 1 ELSE 0 END  INTO VN
    FROM DUAL;
 VRET := 2;
END IF;



INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,231/*0-БРУТТО; 1-НЕТТО*/,VN,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'0-БРУТТО; 1-НЕТТО',PPROCN)
   RETURNING N INTO PPROCN;


 RETURN VRET;
END KINDPALLWEIGHT;


FUNCTION STDOCINNEEDPALLWEIGHT2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VNEED INTEGER := 1 ;
BEGIN
  FOR J IN (SELECT P.VAL1
               FROM MCIS_NODES_PROC P
                WHERE  TYP = 231
           CONNECT BY PRIOR  UP =N  AND SYSDATE BETWEEN FD AND TD
               START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD
               ORDER BY LEVEL DESC
) LOOP
    IF J.VAL1 = 1 THEN
      VNEED := -1;
    END IF;
    EXIT;
  END LOOP;
  IF VNEED = 1 AND KK_CONST.GETCONSTN('USE.DEFAULT.PALLET.WEIGHT', SYSDATE) = 1 THEN
    VNEED := -1;
  END IF;
  RETURN VNEED;
END STDOCINNEEDPALLWEIGHT2;

FUNCTION GETWEIGHTFROMWEIGHER(PWEIGHER INTEGER) RETURN NUMBER IS
VRET NUMBER := NULL;
VI INTEGER := 0;
BEGIN

WHILE VI <= 7 LOOP
  EXIT WHEN NVL(VRET,0) > 0 ;
 BEGIN
    SELECT LAST_VAL INTO VRET
       FROM R_WEIGHER
         WHERE N = PWEIGHER
           AND TD = KK_COMMON.GETTD
           AND (SYSDATE -LAST_FD) *86400 BETWEEN 0 AND 2 ;

 EXCEPTION
 WHEN NO_DATA_FOUND THEN
       NULL;
 END;

 KK_COMMON.SLEEP(1);
 VI := VI + 1;
END LOOP;

IF NVL(VRET,0) = 0 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕТ ДАННЫХ ОТ ВЕСОВ В ТЕЧЕНИИ 3СЕК! ПОВТОРИТЕ</ERR>');
END IF;

RETURN VRET;

END GETWEIGHTFROMWEIGHER;

FUNCTION INPUTPALLWEIGHT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VWEIGHT NUMBER;
VRET INTEGER;
VCNT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CNT');
VCONTRAGENTN   INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'  );
VCONST3 LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NOMWEIGHT.TYPWEIGHT',SYSDATE,VCONTRAGENTN);

NOREQUESTWEIGHT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOREQUESTWEIGHT');
VWEIGHT_NETTO NUMBER;
VWEIGHT_BRUTTO NUMBER;

VNEEDDIFFQUANT LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCININBOUNDCHECKQUANTUM',SYSDATE,VCONTRAGENTN);
VNOMN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');


BEGIN

 IF INSTR(UPPER(PSTR),'W-') = 1 THEN
  VWEIGHT := KK_ST_BARCODE.GETWEIGHTFROMWEIGHER(TO_NUMBER(SUBSTR(
  UPPER(PSTR),INSTR(UPPER(PSTR),'W-') + 2 , 999 )));
  VRET := 1;

 ELSE -- -IF INSTR(UPPER(PSTR),'W-') = 1 THEN



 BEGIN
  SELECT NVL(TO_NUMBER(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.WEIGHT_NETTO'),'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0)
     INTO VWEIGHT_NETTO
       FROM DUAL;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VWEIGHT_NETTO := 0;
 END;

 BEGIN
  SELECT NVL(TO_NUMBER(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.WEIGHT_BRUTTO'),'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0)
     INTO VWEIGHT_BRUTTO
       FROM DUAL;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VWEIGHT_BRUTTO := 0;
 END;


 IF NOREQUESTWEIGHT = 1 AND (VWEIGHT_NETTO <= 0 AND  VWEIGHT_BRUTTO <= 0 ) THEN

 FOR J IN (SELECT P.VAL5,P.VAL4
               FROM MCIS_NODES_PROC P
                WHERE  TYP = 48
           CONNECT BY PRIOR  UP =N  AND SYSDATE BETWEEN FD AND TD
               START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD
               ORDER BY LEVEL DESC ) LOOP
   VWEIGHT :=  VCNT * J.VAL5 ;



  IF NVL(VWEIGHT,0) = 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕТ ВЕСА "'||J.VAL4||'" В СПРАВОЧНИКЕ !</ERR>"'||VCNT||'"');
  END IF;
  EXIT;
 END LOOP;

  VRET := 2;
 ELSIF  NOREQUESTWEIGHT = 0 AND (VWEIGHT_NETTO > 0 OR  VWEIGHT_BRUTTO > 0 ) THEN

-- RAISE_APPLICATION_ERROR(-20000,'<ERR>');
--  RAISE_APPLICATION_ERROR(-20000,'<ERR>'||NOREQUESTWEIGHT||'_'||VWEIGHT_NETTO||'_'||VWEIGHT_BRUTTO);

  VWEIGHT := VWEIGHT_NETTO;
  VRET := 1;
 ELSE

  BEGIN
  SELECT TO_NUMBER(REPLACE(NVL(PSTR,PKEYCODE), '.', TO_CHAR(0,'FMD'))) INTO  VWEIGHT  FROM DUAL;

   EXCEPTION
    WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ОШИБКА ПРИ ВВОДЕ ВЕСА!</ERR>');
  END;
  VRET := 1;
 END IF;

 END IF; -- НЕ ВВОДИЛИ С ВЕСОВ --IF INSTR(UPPER(PSTR),'W-') = 1 THEN

--RAISE_APPLICATION_ERROR(-20000,VWEIGHT);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,191/*ЗАПОМНИЛИ ВЕС ПАЛЛЕТА*/,VWEIGHT,VWEIGHT,NVL(PSTR,PKEYCODE),SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ВЕС',PPROCN)
   RETURNING N INTO PPROCN;

 VWEIGHT_NETTO := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PWEIGHT_NETTO',VWEIGHT);
 --RAISE_APPLICATION_ERROR(-20000,'<ERR>'||VWEIGHT||'</ERR>');

 IF VNEEDDIFFQUANT = 1 THEN
    VNEEDDIFFQUANT:= STDOCININBOUNDQUANTUMCHECK(VNOMN,VWEIGHT,VCNT, PMSG);
    IF VNEEDDIFFQUANT = 3 THEN VRET:=3;END IF;
 END IF;

RETURN VRET;

END;

FUNCTION INPUTPALLWEIGHT2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VWEIGHT NUMBER;
NOREQUESTWEIGHT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOREQUESTWEIGHT');
BEGIN

IF NOREQUESTWEIGHT =1 THEN
 VWEIGHT := 0 ;
ELSE
 SELECT TO_NUMBER(REPLACE(NVL(PSTR,PKEYCODE), '.', TO_CHAR(0,'FMD'))) INTO  VWEIGHT  FROM DUAL;
END IF;


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,212/*ЗАПОМНИЛИ ВЕС ДЕРЕВЯШКИ*/,VWEIGHT,VWEIGHT,NVL(PSTR,PKEYCODE),SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ВЕС',PPROCN)
   RETURNING N INTO PPROCN;

VWEIGHT := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PWEIGHT',VWEIGHT);

RETURN 1;

EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ОШИБКА ПРИ ВВОДЕ ВЕСА!</ERR>');

END;


FUNCTION WHATISDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VDATE DATE;
  VRET INTEGER;
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VKIND LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUT',SYSDATE,VCONTRAGENTN);
  VDEFAULTYEARSEXPIRE INTEGER :=KK_CONST.GETCONSTV('CONTRAGENT.DEFAULTYEARSEXPIRE',SYSDATE,VCONTRAGENTN);
  VNOMENKLATURAN INTEGER :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
  VEXPIREN INTEGER;
  VCHECKNOMENKLATURAEXPIRE INTEGER :=KK_CONST.GETCONSTV('CHECKNOMENKLATURAEXPIRE',SYSDATE,VCONTRAGENTN);
  VDEF_NOM_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP'),0);
  VDEF_NOM_SUB_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_SUB_TYP'),0);
  VDEF_NOM_TYP_RESPONSE INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP_RESPONSE'),0);
  VNEEDMAKEDATE LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NEEDINPUTMAKEDATE',SYSDATE,VCONTRAGENTN);
  VEXPIRE VARCHAR2(25) := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'EXPIRE');
  V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
  VKEY INTEGER;
BEGIN
  PMSG := NULL;

  --ПО ЗАПРОСУ LDV - НЕ ДАВАТЬ ПРОПУСКАТЬ ВВОД СРОКА ГОДНОСТИ, ЕСЛИ У НОМЕНКЛАТУРЫ НЕПУСТО ПОЛЕ EXPIRE
  BEGIN
  SELECT EXPIRE INTO VEXPIREN FROM NOMENKLATURA WHERE N=VNOMENKLATURAN AND TD=KK_COMMON.GETTD;
   EXCEPTION WHEN NO_DATA_FOUND THEN
    VEXPIREN:=0;
  END;
  IF VCHECKNOMENKLATURAEXPIRE=1 AND TO_NUMBER(PKEYCODE)=0 AND VEXPIREN>0 THEN
     RAISE_APPLICATION_ERROR(-20000,'ВЫ НЕ МОЖЕТЕ ПРОПУСТИТЬ ВВОД СРОКА ГОДНОСТИ ДЛЯ ДАННОЙ НОМЕНКЛАТУРЫ!');
  END IF;

  IF NVL(INSTR(VKIND,','||TO_NUMBER(PKEYCODE)||','),0) = 0 THEN
    SELECT
      SYS_XMLAGG(XMLELEMENT(COL,
      CHR(13)||
      DECODE(RECIPIENT,1,'1'||CHR(9)||'ГОДЕН ДО'
                      ,9,'9'||CHR(9)||'ДАТА ИЗГОТОВЛ.'
                      ,10,'10'||CHR(9)||'ЛЕТ ОТ ДАТЫ ПРИЁМКИ: '||VDEFAULTYEARSEXPIRE
                      ,0,'0'||CHR(9)||'БЕЗ. ОГРАНИЧ СРОКА')
                       )).EXTRACT('/ROWSET/COL/TEXT()').GETSTRINGVAL()
      || NVL(INSTR(VKIND,','||TO_NUMBER(PKEYCODE)||','),0) INTO PMSG
       FROM
      TABLE(KK_SMS.CREATETABLE(',1,9,10,0,',','))
      WHERE VKIND LIKE '%,'||RECIPIENT||',%';
    RAISE_APPLICATION_ERROR(-20000,'<ERR>КАКАЯ ДАТА ВАМ ИЗВЕСТНА? '||V1310||PMSG||'</ERR>CONTRAGENT.KINDOFDATEINPUT='||VKIND);
  ELSE
    VKEY := TO_NUMBER(PKEYCODE);
    IF VKEY = 11 THEN
      VKEY := 1;
    END IF;
    INSERT INTO MCIS_NODES_PROC
      (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
      VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЧТО ЗА ДАТА*/,VKEY,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ЧТО ЗА ДАТА',PPROCN)
      RETURNING N
      INTO PPROCN;
    IF TO_NUMBER(PKEYCODE) IN (0,10) AND VNEEDMAKEDATE!=0 THEN
      RETURN 4;
    END IF;
    IF TO_NUMBER(PKEYCODE) IN (1,9) THEN
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN_PRIEMKA_DATE_TYPE',TO_NUMBER(PKEYCODE));
      VRET := 1;
    ELSE
      IF TO_NUMBER(PKEYCODE) = 11 THEN
        INSERT INTO MCIS_NODES_PROC
          (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
          VALUES
          (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЗАПОМНИЛИ ДАТА СРОК ДО*/,1,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
          RETURNING N
          INTO PPROCN;
        INSERT INTO MCIS_NODES_PROC
          (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
          VALUES
          (SQ_MCIS_NODES_PROC.NEXTVAL,11/*ЗАПОМНИЛИ ДАТА СРОК ДО*/,NULL,NULL,VEXPIRE,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
          RETURNING N
          INTO PPROCN;
      END IF;
      -------- ПОСЛЕ ДАННОЙ ФУНКЦИИ ИДЕТ ВВОД КОНДИЦИИ И ГРАДАЦИИ, ЕСЛИ БЫЛИ УСТАНОВЛЕНЫ
      -------- ЗНАЧЕНИЯ В ПЕРЕМЕННЫЕ ПО УМОЛЧАНИЮ - ТО ПРОПУСКАЕМ ЭТИ УЗЛЫ ВВОДА
      IF VDEF_NOM_TYP != 0 THEN
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP',VDEF_NOM_TYP);
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_SUB_TYP',VDEF_NOM_SUB_TYP);
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP_RESPONSE',VDEF_NOM_TYP_RESPONSE);
        RETURN 3; --
      END IF;
    --------
      VRET:=   2;
    END IF;
  END IF;
  PMSG :=  PMSG ||V1310/*|| KK_ST_BARCODE.GETTERMLIST(422)*/     ; -- ЗАЧЕМ  ПРИ ВВОД ДАТЫ ВЫВОДИТЬ СЛОВАРЬ КОНДИЦИИ ИЛИ БРАКА?
  RETURN VRET;
END WHATISDATE;

FUNCTION WHATISDATE2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VDATE DATE;
VRET INTEGER;
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VKIND LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUTMAKE',SYSDATE,VCONTRAGENTN);

VDEF_NOM_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP'),0);
VDEF_NOM_SUB_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_SUB_TYP'),0);
VDEF_NOM_TYP_RESPONSE INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP_RESPONSE'),0);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
 PMSG := NULL;

 IF NVL(INSTR(VKIND,','||TO_NUMBER(PKEYCODE)||','),0) = 0 THEN


SELECT
SYS_XMLAGG(XMLELEMENT(COL,
CHR(13)||
DECODE(RECIPIENT,9,'9'||CHR(9)||'ДАТА ПРОИЗВОДСТВА'
                ,0,'0'||CHR(9)||'БЕЗ ДАТЫ ПРОИЗВОДСТВА')
                 )).EXTRACT('/ROWSET/COL/TEXT()').GETSTRINGVAL()
|| NVL(INSTR(VKIND,','||TO_NUMBER(PKEYCODE)||','),0) INTO PMSG
 FROM
TABLE(KK_SMS.CREATETABLE(',9,0,',','))
WHERE VKIND LIKE '%,'||RECIPIENT||',%';

 RAISE_APPLICATION_ERROR(-20000,'<ERR>КАКАЯ ДАТА ВАМ ИЗВЕСТНА? '||V1310||PMSG||'</ERR>CONTRAGENT.KINDOFDATEINPUTMAKE='||VKIND);

 ELSE

--INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
--  (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЧТО ЗА ДАТА*/,TO_NUMBER(PKEYCODE),NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ЧТО ЗА ДАТА',PPROCN)
--   RETURNING N INTO PPROCN;

   IF TO_NUMBER(PKEYCODE)=9 THEN
     PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STDOCIN_PRIEMKA_DATE_TYPE',TO_NUMBER(PKEYCODE));
     PMSG := '9'||CHR(9)||'ДАТА ПРОИЗВОДСТВА';
     VRET := 1;
   ELSE
      -------- ПОСЛЕ ДАННОЙ ФУНКЦИИ ИДЕТ ВВОД КОНДИЦИИ И ГРАДАЦИИ, ЕСЛИ БЫЛИ УСТАНОВЛЕНЫ
      -------- ЗНАЧЕНИЯ В ПЕРЕМЕННЫЕ ПО УМОЛЧАНИЮ - ТО ПРОПУСКАЕМ ЭТИ УЗЛЫ ВВОДА
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'MAKE_DATE',NULL);
        IF VDEF_NOM_TYP != 0
            THEN   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP',VDEF_NOM_TYP);
                   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_SUB_TYP',VDEF_NOM_SUB_TYP);
                   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP_RESPONSE',VDEF_NOM_TYP_RESPONSE);
            RETURN 3; --
        END IF;
    --------
        VRET:=   2;
   END IF;

 END IF;

  PMSG :=  PMSG ||V1310/*|| KK_ST_BARCODE.GETTERMLIST(422)*/     ; -- ЗАЧЕМ  ПРИ ВВОД ДАТЫ ВЫВОДИТЬ СЛОВАРЬ КОНДИЦИИ ИЛИ БРАКА?
 RETURN VRET;
END WHATISDATE2;

FUNCTION WHATISDATESIMPLE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VDATE DATE;
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VKIND LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUT',SYSDATE,VCONTRAGENTN);
VDEFAULTYEARSEXPIRE INTEGER :=KK_CONST.GETCONSTV('CONTRAGENT.DEFAULTYEARSEXPIRE',SYSDATE,VCONTRAGENTN);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN




 IF NVL(INSTR(VKIND,','||TO_NUMBER(PKEYCODE)||','),0) = 0 THEN


SELECT
SYS_XMLAGG(XMLELEMENT(COL,
CHR(13)||
DECODE(RECIPIENT,1,'1'||CHR(9)||'ГОДЕН ДО'
                ,9,'9'||CHR(9)||'ДАТА ИЗГОТОВЛ.'
                ,10,'10'||CHR(9)||'ЛЕТ ОТ ДАТЫ ПРИЁМКИ:'||VDEFAULTYEARSEXPIRE
                ,0,'0'||CHR(9)||'БЕЗ. ОГРАНИЧ СРОКА')
                 )).EXTRACT('/ROWSET/COL/TEXT()').GETSTRINGVAL()
|| NVL(INSTR(VKIND,','||TO_NUMBER(PKEYCODE)||','),0) INTO PMSG
 FROM
TABLE(KK_SMS.CREATETABLE(',1,9,10,0,',','))
WHERE VKIND LIKE '%,'||RECIPIENT||',%';

 RAISE_APPLICATION_ERROR(-20000,'<ERR>КАКАЯ ДАТА ВАМ ИЗВЕСТНА?'||V1310||PMSG||'</ERR>CONTRAGENT.KINDOFDATEINPUT='||VKIND);


 ELSE

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,10/*ЧТО ЗА ДАТА*/,TO_NUMBER(PKEYCODE),NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ЧТО ЗА ДАТА',PPROCN)
   RETURNING N INTO PPROCN;

   IF TO_NUMBER(PKEYCODE) IN (1,9) THEN
     RETURN 1;
   ELSE
     RETURN 2;
   END IF;

 END IF;

END WHATISDATESIMPLE;


FUNCTION SHOWCONDTYPES(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VASK INTEGER := KK_CONST.GETCONSTN('STDOCINV.ASKFORNOMTYP', SYSDATE);
BEGIN
  IF VASK = 1 THEN
    PMSG := KK_ST_BARCODE.GETTERMLIST(422) ;
    RETURN 1;
  ELSE
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP',1);
    RETURN 2;
  END IF;
END SHOWCONDTYPES;


FUNCTION CHECKPRODDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
 VDATE DATE;
 VDATES DATE;
 VEXPIRE INTEGER;
 VSYSDATE DATE:= SYSDATE;
 VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
 VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
 VTMP VARCHAR2(20);
 VDEF_NOM_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP'),0);
 VDEF_NOM_SUB_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_SUB_TYP'),0);
 VDEF_NOM_TYP_RESPONSE INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP_RESPONSE'),0);
 VEMPN  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');

BEGIN --ДАТА ПРОИЗВОДСТВА НЕ БОЛЬШЕ ТЕКУЩЕЙ
 PMSG := NULL;

  IF LENGTH(PKEYCODE) = 6 THEN
        SELECT TO_DATE(PKEYCODE,'DDMMYY') INTO VDATE FROM DUAL;
  ELSE
          SELECT TO_DATE(PKEYCODE,'DDMMYYYY') INTO VDATE FROM DUAL;
  END IF;

  SELECT NVL(N.EXPIRE,0)
    INTO VEXPIRE
    FROM NOMENKLATURA N
      WHERE N.N = VNOMN
        AND SYSDATE BETWEEN N.FD AND N.TD;

  VTMP:=SESSIONVARGET(PROBJN,'STDOCIN_PRIEMKA_DATE_TYPE');

   IF VEXPIRE > 0 THEN
     IF (VTMP='1') THEN
        VDATES := VDATE-VEXPIRE;
     ELSIF (VTMP='9') THEN
        VDATES := VDATE+VEXPIRE;
     END IF;
   END IF;

   IF (VTMP='1') AND  (VDATE<VSYSDATE AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CONTRAGENT.CANENTERINVALIDDATE',SYSDATE) != 3) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>СРОК ГОДНОСТИ '||VDATE||' НЕ МОЖЕТ БЫТЬ МЕНЬШЕ ТЕКУЩЕЙ ДАТЫ '||VSYSDATE||'</ERR>');
   ELSIF (VTMP='1') AND (VEXPIRE>0) AND (VDATES>VSYSDATE AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CONTRAGENT.CANENTERINVALIDDATE',SYSDATE) != 3) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА ПРОИЗВОДСТВА '||VDATES||' НЕ МОЖЕТ БЫТЬ БОЛЬШЕ ТЕКУЩЕЙ ДАТЫ '||VSYSDATE||'</ERR>');
   ELSIF (VTMP='9') AND  (VDATE>VSYSDATE AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CONTRAGENT.CANENTERINVALIDDATE',SYSDATE) != 3) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА ПРОИЗВОДСТВА '||VDATE||' НЕ МОЖЕТ БЫТЬ БОЛЬШЕ ТЕКУЩЕЙ ДАТЫ '||VSYSDATE||'</ERR>');
   ELSIF (VTMP='9') AND (VEXPIRE>0) AND (VDATES<VSYSDATE AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CONTRAGENT.CANENTERINVALIDDATE',SYSDATE) != 3) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>СРОК ГОДНОСТИ '||VDATES||' НЕ МОЖЕТ БЫТЬ МЕНЬШЕ ТЕКУЩЕЙ ДАТЫ '||VSYSDATE||'</ERR>');
   ELSE
    -------- ПОСЛЕ ДАННОЙ ФУНКЦИИ ИДЕТ КОНДИЦИИ И ГРАДАЦИИ, ЕСЛИ БЫЛИ УСТАНОВЛЕНЫ
    -------- ЗНАЧЕНИЯ В ПЕРЕМЕННЫЕ ПО УМОЛЧАНИЮ - ТО ПРОПУСКАЕМ ЭТИ УЗЛЫ ВВОДА
    IF VDEF_NOM_TYP != 0
        THEN   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP',VDEF_NOM_TYP);
               PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_SUB_TYP',VDEF_NOM_SUB_TYP);
               PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP_RESPONSE',VDEF_NOM_TYP_RESPONSE);
        RETURN 2; --
    END IF;
--------
    RETURN 1;
   END IF;
   PMSG :=   KK_ST_BARCODE.GETTERMLIST(422);

END CHECKPRODDATE;

FUNCTION CHECKMAKEDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
 I INTEGER;
 VDATE DATE;
 VSYSDATE DATE:= SYSDATE;
 VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
 VNEEDMAKEDATE LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NEEDINPUTMAKEDATE',SYSDATE,VCONTRAGENTN);
 VDEF_NOM_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP'),0);
 VDEF_NOM_SUB_TYP INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_SUB_TYP'),0);
 VDEF_NOM_TYP_RESPONSE INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP_RESPONSE'),0);
 VTMP VARCHAR2(20);
 VKIND LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.KINDOFDATEINPUTMAKE',SYSDATE,VCONTRAGENTN);
 VCNT INTEGER;
 VKEY INTEGER;
 VEMPN  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN --ДАТА ПРОИЗВОДСТВА НЕ БОЛЬШЕ ТЕКУЩЕЙ
 PMSG := NULL;
  IF LENGTH(PKEYCODE) = 6 THEN
        SELECT TO_DATE(PKEYCODE,'DDMMYY') INTO VDATE FROM DUAL;
  ELSIF LENGTH(PKEYCODE)>2 THEN
          SELECT TO_DATE(PKEYCODE,'DDMMYYYY') INTO VDATE FROM DUAL;
  END IF;

  VTMP:=SESSIONVARGET(PROBJN,'STDOCIN_PRIEMKA_DATE_TYPE');
   IF (VTMP='1') AND  (VDATE<VSYSDATE AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CONTRAGENT.CANENTERINVALIDDATE',SYSDATE) != 3) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>СРОК ГОДНОСТИ '||VDATE||' НЕ МОЖЕТ БЫТЬ МЕНЬШЕ ТЕКУЩЕЙ ДАТЫ '||VSYSDATE||'</ERR>');
   ELSIF (VTMP='9') AND  (VDATE>VSYSDATE AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CONTRAGENT.CANENTERINVALIDDATE',SYSDATE) != 3) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА ИЗГОТОВЛЕНИЯ '||VDATE||' НЕ МОЖЕТ БЫТЬ БОЛЬШЕ ТЕКУЩЕЙ ДАТЫ '||VSYSDATE||'</ERR>');
   ELSE

    IF VNEEDMAKEDATE != 0 THEN
       SELECT
        STRAGG_SEP(T_STR_SEP(
        DECODE(RECIPIENT,9,'9-ДАТА ПРОИЗВОДСТВА'
        ,0,'0-БЕЗ ДАТЫ ПРОИЗВОДСТВА')
        ,V1310)), COUNT(1) , MIN(RECIPIENT)
         INTO PMSG ,VCNT , VKEY
         FROM
        TABLE(KK_SMS.CREATETABLE(',9,0,',','))
        WHERE VKIND LIKE '%,'||RECIPIENT||',%';
        IF VCNT = 1 THEN
         I := WHATISDATE2(VKEY, NULL, PMSG, PNEXTNODE, PPROCN, PROBJN);
         RETURN 4;
       END IF;
       RETURN 3; --ИДЁМ НА ВВОД ДАТЫ ПРОИЗВОДСТВА
    END IF;
    IF VDEF_NOM_TYP != 0
    THEN   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP',VDEF_NOM_TYP);
           PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_SUB_TYP',VDEF_NOM_SUB_TYP);
           PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP_RESPONSE',VDEF_NOM_TYP_RESPONSE);
    RETURN 2; --
    END IF;
--------
    RETURN 1;
   END IF;
   PMSG :=   KK_ST_BARCODE.GETTERMLIST(422);

END CHECKMAKEDATE;

FUNCTION INPUTDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VCONTRAGENTN INTEGER :=    NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'FILTER.CONTRAGENT_N'  ),0);
    VEMPN  INTEGER :=   KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'  );
    VDATE DATE;
    VD VARCHAR2(100);
    VSTR VARCHAR2(100);
    VACCESS  INTEGER;
    VOPTIONS PRM_CORRS.OPTIONS%TYPE;
BEGIN

    -------- ВВОД ДАТЫ ЧЕРЕЗ СКАНИРОВАНИЕ ШК ---------------
        IF PSTR IS NULL AND PKEYCODE IS NULL THEN
           RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА НЕ СОСКАНИРОВАНА ИЛИ НЕ ВВЕДЕНА</ERR>');
        END IF;

        VACCESS := KK_PERMIT.EXISTSPERMIT(VEMPN,'ACCESSLISTCONTRAGENT',SYSDATE,VOPTIONS);

        IF (PSTR IS NOT NULL) AND KK_BARCODE_MASK.PARCEBARCODE(PROBJN ,PSTR,VSTR) != 0 THEN
            VD := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.PROD_DATE');
          IF NVL(VD,'0') = '0' THEN
            RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА ОТСУТСТВУЕТ В ШТРИХКОДЕ</ERR>');
          ELSE
            VDATE := TRUNC(TO_DATE(VD,'DD.MM.YYYY HH24:MI:SS'));
          END IF;

--    RAISE_APPLICATION_ERROR(-20010,TO_CHAR(VDATE,'DDMMYYYY'));
    -------- ВВОД ДАТЫ ЧЕРЕЗ СКАНИРОВАНИЕ ШК ---------------
        ELSE
            IF LENGTH(PKEYCODE) = 6 THEN
                SELECT TO_DATE(PKEYCODE,'DDMMYY') INTO VDATE FROM DUAL;
            ELSE
                SELECT TO_DATE(PKEYCODE,'DDMMYYYY') INTO VDATE FROM DUAL;
            END IF;
        END IF;

      -- RAISE_APPLICATION_ERROR(-20000,'VDATE='||VDATE);

    IF (PSTR IS NOT NULL) AND NVL(VD,'0') = '0' THEN
        RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА ОТСУТСТВУЕТ В ШТРИХКОДЕ</ERR>');

    END IF;

    IF VDATE < KK_COMMON.GETFD THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА НЕ МОЖЕТ БЫТЬ МЕНЕЕ ' || TO_CHAR(KK_COMMON.GETFD) || '</ERR>');
    END IF;

PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_IN.DATE',VDATE);

    INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,11/*ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ*/,NULL,NULL,TO_CHAR(VDATE,'DDMMYYYY'),SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
       RETURNING N INTO PPROCN;

    PMSG :=  PMSG || KK_ST_BARCODE.GETTERMLIST(422)     ;
RETURN 1;
END INPUTDATE;

FUNCTION INPUTMAKEDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER :=    NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'FILTER.CONTRAGENT_N'  ),0);
VEMPN  INTEGER :=   KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'  );
VDATE DATE;
VD VARCHAR2(100);
VSTR VARCHAR2(100);
VACCESS  INTEGER;
VOPTIONS PRM_CORRS.OPTIONS%TYPE;
--VCANENTERINVALIDDATE LIST_CONST.VAL%TYPE :=  KK_CONST.GETCONSTV('CONTRAGENT.CANENTERINVALIDDATE',SYSDATE,VCONTRAGENTN);
BEGIN
    IF PSTR IS NULL AND PKEYCODE IS NULL THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА НЕ СОСКАНИРОВАНА ИЛИ НЕ ВВЕДЕНА</ERR>');
    END IF;

    IF LENGTH(PKEYCODE) = 6 THEN
        SELECT TO_DATE(PKEYCODE,'DDMMYY') INTO VDATE FROM DUAL;
    ELSE
        SELECT TO_DATE(PKEYCODE,'DDMMYYYY') INTO VDATE FROM DUAL;
    END IF;


    IF VDATE < KK_COMMON.GETFD/* AND VCANENTERINVALIDDATE='0'*/ THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА НЕ МОЖЕТ БЫТЬ МЕНЕЕ ' || TO_CHAR(KK_COMMON.GETFD) || '</ERR>');
    END IF;

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'MAKE_DATE',VDATE);

    PMSG :=  PMSG || KK_ST_BARCODE.GETTERMLIST(422)     ;
RETURN 1;
END INPUTMAKEDATE;

FUNCTION INPUTSIMPLEDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VDATE DATE;
  VDATETYPE NUMBER := 1;
BEGIN
  BEGIN
    IF LENGTH(PKEYCODE) = 6 THEN
      SELECT TO_DATE(PKEYCODE,'DDMMYY') INTO VDATE FROM DUAL;
    ELSE
      SELECT TO_DATE(PKEYCODE,'DDMMYYYY') INTO VDATE FROM DUAL;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN -- CAUTION:HANDLES ALL EXCEPTIONS
      SELECT TO_DATE(PKEYCODE,'DDMMYY') INTO VDATE FROM DUAL;
  END;
  IF VDATE < KK_COMMON.GETFD THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАТА НЕ МОЖЕТ БЫТЬ МЕНЕЕ ' || TO_CHAR(KK_COMMON.GETFD) || '</ERR>');
  END IF;

--RAISE_APPLICATION_ERROR(-20001,PPROCN);
  INSERT INTO MCIS_NODES_PROC
    (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
    VALUES
    (SQ_MCIS_NODES_PROC.NEXTVAL,11 /* 11 ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ*/,NULL,NULL,TO_CHAR(VDATE,'DDMMYYYY'),SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ ДАТА ИЗГОТОВЛЕНИЯ',PPROCN)
    RETURNING N
    INTO PPROCN;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'DATE', VDATE);
  PMSG := 'ВВЕДЕНА ДАТА '|| TO_CHAR(VDATE,'DD.MM.YYYY');
  RETURN 1;
END;

FUNCTION INPUTCONDTYPE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VTYPLIST VARCHAR2(50);
VTYP INTEGER;
VSTDOCINN INTEGER :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
--VPALLN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');
--VCNT INTEGER;
BEGIN
--RETURN 1;
--RAISE_APPLICATION_ERROR(-20666, PKEYCODE || ' - ' || PROBJN  );
  PMSG := NULL;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_SUB_TYP', NULL);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP_RESPONSE', NULL);

  SELECT TO_NUMBER(PKEYCODE) INTO VN FROM DUAL;
--RAISE_APPLICATION_ERROR (-20001, VN);
  IF (VN NOT IN (1,3) OR NVL(VN,0)=0) THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>УКАЖИТЕ 1-КОНДИЦИЯ 3-БРАК!!!</ERR>');
  END IF;

  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,12/*ЗАПОМНИЛИ КОНДИЦИЯ БРАК*/,VN,TO_NUMBER(PKEYCODE),NULL,DECODE(TO_NUMBER(PKEYCODE),1,'КОНДИЦИЯ',3,'БРАК','XXXXXX'),SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ КОНДИЦИЯ БРАК',PPROCN)
   RETURNING N INTO PPROCN;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP',TO_NUMBER(PKEYCODE));

  IF NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0) = 1 THEN
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_NOM_TYP',TO_NUMBER(PKEYCODE));
  END IF;
--     RAISE_APPLICATION_ERROR(-20666, PKEYCODE || ' - ' || PROBJN  );

/*ЧТО ЗА ХУЙНЯ, НЫЙДУ КТО НАПИСАЛ УБЬЮ! С ЧЕГО ВЫ ВЗЯЛИ ЧТО ЭТО ТОЛЬКО ИЗ ПРИХОДОВ ВЫЗЫВАЕТСЯ??? */
-- IF NVL(VPALLN, 0)  <> 0 THEN
--  SELECT SUM(DECODE(D.CNT_IN,0,D.CNT_BRAK,NULL,D.CNT_BRAK,D.CNT_IN)) INTO VCNT FROM
  /*ЗАПРОС ИЗ ШТРИХ КОДИРОВАНИЯ ПОКАЗЫВАЕТ ЧТО СОДЕРЖИТ ПАЛЛЕТА ГДЕ НАХОДИТСЯ НА ЭТАПЕ РАССТАНОВКИ*/
--  ST_DOC_IN_DET D
--  WHERE 1=1
--    AND D.TYP =1
--    AND SYSDATE BETWEEN D.FD AND D.TD
--    AND D.PALL_N = VPALLN;
-- END IF;
--  PMSG := 'КОЛИЧЕСТВО НА ПАЛЛЕТЕ = '||NVL(VCNT,0);


--DENIS BEGIN ЗАДАЧА 29617
VTYP:=0;
BEGIN
  SELECT TYP INTO VTYP FROM ST_DOC_IN WHERE N=VSTDOCINN AND TD=KK_COMMON.GETTD;
EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
END;

--RAISE_APPLICATION_ERROR(-20000,PNEXTNODE ||' ; '||'%,'||VTYP||',%');

IF NVL(VTYP,0)!=0 THEN --ВЫЗОВ ИЗ ПРИХОДЫВАНИЯ
VTYPLIST:=KK_CONST.GETCONSTV('STDOCIN.INPUTCONDTYPE.DOCTYPLIST',SYSDATE,0);

IF VTYPLIST LIKE '%,'||VTYP||',%' OR VTYPLIST IN('0',',0,','_')  THEN
  RETURN 3;
ELSE
  RETURN 1;
END IF;
END IF; --NVL(VTYP,0)!=0

IF PNEXTNODE=279 AND KK_CONST.GETCONSTV('STDOCINV.INPUTCONDTYPE.NEEDGRADCOND',SYSDATE,0)=1 THEN --ВЫЗОВ ИЗ ИНВЕНТАРИЗАЦИИ
   RETURN -1;
END IF;
--END DENIS

  RETURN 3;
END;


FUNCTION SHOWBRAKTYPE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2
                        , PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER
                        )RETURN INTEGER IS
  VMSG VARCHAR2(1500);
  VTYP VARCHAR2(1500) := '0';
  VCONTRN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VDOCINN INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N'),0);
  VDOCINTYP INTEGER := 0;
  VNOMTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
    PMSG := '';

   IF VDOCINN > 0 THEN
    -- ДЕЛИМ КОНСТАНТУ И ПО ТИПУ ДОКУМЕНТА
     SELECT TYP INTO VDOCINTYP
      FROM ST_DOC_IN
       WHERE N = VDOCINN
         AND SYSDATE BETWEEN FD AND TD;
   END IF ;

    VTYP:= KK_CONST.GETCONSTV('STDOCIN.INBOUND.SUBCONDITIONLIST',SYSDATE,VCONTRN,VDOCINTYP);

-- ВЫВОДИМ СПИСОК КОНДИЦИЙ В СООТВЕТСТВИИ С КОНСТАНТОЙ STDOCIN.INBOUND.SUBCONDITIONLIST
    FOR J IN(
        SELECT NVL(DD.CODE2,DD.CODE) AS CODE,TERM --, ROW_NUMBER() OVER (ORDER BY DD.CODE) AS RN
        FROM DIC_DATA DD
        WHERE DD.UP = 496
            AND SYSDATE BETWEEN FD AND TD
            AND (R_N = VNOMTYP OR NVL(R_N,0) = 0 OR NVL(VNOMTYP, 0) = 0)
            AND (VTYP LIKE '%,'||DD.CODE||',%' OR VTYP = '0')
            ORDER BY NVL(DD.CODE2,DD.CODE)
    ) LOOP
        VMSG :=  VMSG || J.CODE ||CHR(9)|| J.TERM || V1310;
    END LOOP;

--   VMSG := KK_ST_BARCODE.GETTERMLIST(496,NULL,VN);

   IF VMSG IS NULL THEN
     PMSG :=  NULL;
     RETURN -1;
   ELSE
     PMSG :=  PMSG ||VMSG;
     RETURN 1;
   END IF;

END SHOWBRAKTYPE;

FUNCTION INPUTBRAKTYPE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VKEYCODE INTEGER;
VCODE INTEGER;
VTYP VARCHAR2(1500) := '0';
VCONTRN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VDOCINN INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N'),0);
VDOCINTYP INTEGER := 0;
VNOMTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
BEGIN
  PMSG := '';
  SELECT TO_NUMBER(PKEYCODE) INTO VKEYCODE FROM DUAL;
  IF VDOCINN > 0 THEN
    -- ДЕЛИМ КОНСТАНТУ И ПО ТИПУ ДОКУМЕНТА
    SELECT TYP INTO VDOCINTYP
      FROM ST_DOC_IN
      WHERE N = VDOCINN
        AND SYSDATE BETWEEN FD AND TD;
  END IF ;
  VTYP:= KK_CONST.GETCONSTV('STDOCIN.INBOUND.SUBCONDITIONLIST',SYSDATE,VCONTRN,VDOCINTYP);

BEGIN
SELECT CODE,TERM INTO VCODE,PMSG
 FROM DIC_DATA DD
   WHERE DD.UP = 496
     AND SYSDATE BETWEEN FD AND TD
     AND (
       VTYP = '_'
       OR VTYP = '0'
       OR VTYP LIKE '%,'||DD.CODE||',%'
     )
     AND (R_N = VNOMTYP OR NVL(R_N,0) = 0 OR NVL(VNOMTYP, 0) = 0)
     AND NVL(CODE2,CODE) = VKEYCODE;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ВЫБЕРИТЕ ИЗ ПЕРЕЧИСЛЕНОГО</ERR>');
END;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1,  FD , TD , DSC, UP,VAL4 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,43,VCODE,SYSDATE,KK_COMMON.GETTD,'КЛАССИФИЦИРОВАЛИ БРАК',PPROCN,PMSG)
   RETURNING N INTO PPROCN;

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_SUB_TYP',VCODE);

  IF NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0) = 1 THEN
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_NOM_SUB_TYP',TO_NUMBER(PKEYCODE));
  END IF;

RETURN 1;
END INPUTBRAKTYPE;

PROCEDURE CHECKPACKAGEEXECUTED IS
VEXECUTED INTEGER;
BEGIN

SELECT PATCH_EXECUTED INTO VEXECUTED
  FROM
 CIS_COPY  C
 WHERE UPPER(C.NAME) = UPPER(SYS_CONTEXT('USERENV','DB_NAME')||'-'||SYS_CONTEXT('USERENV','SESSION_USER'))
  AND C.N = 0
  AND C.TD = KK_COMMON.GETTD;

  IF VEXECUTED = 1 THEN
   RAISE_APPLICATION_ERROR(-20100,'СИСТЕМА В РЕЖИМЕ ПАТЧИРОВАНИЯ! ДЕЙСТВИЯ НЕВОЗМОЖНЫ! ПОЖАЛУЙСТА ЖДИТЕ!');
  END IF; --IF VEXECUTED = 1 THEN

END CHECKPACKAGEEXECUTED;

PROCEDURE BAR_LOG(PNODE INTEGER, PKEYCODE IN VARCHAR2,PSTR IN VARCHAR2, PROBJN INTEGER, PPROCN INTEGER, PRET INTEGER, PMSG VARCHAR2, PERR VARCHAR2) IS
  VNEEDLOG INTEGER:= KK_CONST.GETCONSTN('BARCODE.NEEDLOG');
  VEMPN  INTEGER :=  NVL( KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'),0);
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  IF VNEEDLOG = 1 THEN
    INSERT INTO ST_BAR_LOG
      (N, FD, PNODE, PKEYCODE, PSTR
      , PROBJN, PPROCN, RET, ERR, MSG, EMPN)
      VALUES
      (SQ_BAR_LOG.NEXTVAL, SYSDATE, PNODE, PKEYCODE, PSTR
      ,PROBJN, PPROCN, PRET, PERR, PMSG ,VEMPN );
    COMMIT;
  END IF;
END BAR_LOG;

FUNCTION PROC3(PNODE IN INTEGER,PNEXTNODE IN OUT INTEGER,PKEYCODE IN VARCHAR2,PSTR IN VARCHAR2,
  PMSG IN  OUT VARCHAR2,PPROCN IN OUT INTEGER,PBARCODEPROC OUT VARCHAR2,PROBJN IN OUT INTEGER,
  PSUBMITONBAR OUT INTEGER)RETURN INTEGER IS
  VKEYCODE VARCHAR2(512);
  VPROC VARCHAR2(255) := '_';
  VRET INTEGER;
  VSTR VARCHAR2(512);
  VMSG VARCHAR2(255);
  VMSGSTR VARCHAR2(255);
  VERRMSG VARCHAR2(4000);
  VIN_KEY INTEGER := 0;
  VRESETPROCN INTEGER ;
  VEMPN  INTEGER :=  NVL( KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'),0);
  VNODEX INTEGER := NULL;
  VINKEY INTEGER := NULL;
  VMCIS_NODES_COPY_N INTEGER := KK_CONST.GETCONSTN('MCIS_NODES.CIS_COPY_N',SYSDATE,0);
  VPERMIT PRM_PERMITS.SYSNAME%TYPE;
  VPROCAFTER LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('MCIS.AFTERSELECTNODE', SYSDATE);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);

VINC INTEGER := 0;
BEGIN
-- ПРОВЕРКА НА ТО ЧТО ИДЕТ ПАТЧ
  CHECKPACKAGEEXECUTED;
---  RAISE_APPLICATION_ERROR(-20000,'STR'||TRIM(PSTR)||'; VSTR='||VSTR);
-- RAISE_APPLICATION_ERROR(-20000, 'PNODE='|| PNODE||';PNEXTNODE='|| PNEXTNODE||';PKEYCODE='|| PKEYCODE||';PSTR='|| PSTR||';PMSG='|| PMSG||';PPROCN='|| PPROCN||';PBARCODEPROC='|| PBARCODEPROC||';PROBJN='|| PROBJN||';PSUBMITONBAR='|| PSUBMITONBAR);

  VKEYCODE := CLEARNULLTERMINATEDSTRING(PKEYCODE);
  VSTR     := CLEARNULLTERMINATEDSTRING(PSTR);
--RAISE_APPLICATION_ERROR(-20000,'PKEYCODE='||PKEYCODE||'; VKEYCODE='||VKEYCODE||'; PSTR='||PSTR||'; VSTR='||VSTR);

  IF INSTR(VKEYCODE,'!') > 0
     AND INSTR(VKEYCODE,'?') > 0 THEN


   VSTR     := SUBSTR(VKEYCODE, INSTR(VKEYCODE,'!') +1 , INSTR(VKEYCODE,'?') - INSTR(VKEYCODE,'!') -1  );
   VKEYCODE := SUBSTR(VKEYCODE,1, INSTR(VKEYCODE,'!') -1 ) ;


  END IF;

--RAISE_APPLICATION_ERROR(-20000,PSTR||'_'||VKEYCODE||'PKEYCODE='||PKEYCODE||'VKEYCODE='||VKEYCODE||'PSTR='||PSTR||'VSTR='||VSTR);

  IF VKEYCODE = '027' THEN  -- ОЧИЩАЕМ СООБЩЕНИЕ!
    PMSG := NULL;
  END IF;
  IF VEMPN > 0 THEN
    KK_TRACE.LOGON(VEMPN);
  END IF;--IF VEMPN > 0 THEN
  IF VEMPN = 0 AND PNODE NOT IN(6,18,2,1,20,2530,834) AND NVL(INSTR(VSTR,'ND-18/99'), 0) = 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ВЫ НЕ ИДЕНТИФИЦИРОВАНЫ! PNODE='||PNODE||'</ERR>');
  END IF;--IF VEMPN > 0 THEN
  KK_ST_CTX.ASSIGN('PROBJN', PROBJN);
  PNEXTNODE := NULL;
  IF INSTR(VSTR,'ND-') = 1  THEN
    SELECT TO_NUMBER(SUBSTR(VSTR,4 , DECODE(INSTR(VSTR,'/'),0,LENGTH(VSTR), INSTR(VSTR,'/') - 4 ))) AS NODE
           , DECODE(INSTR(VSTR,'/'),0,NULL, SUBSTR(VSTR,INSTR(VSTR,'/')+1, DECODE(INSTR(VSTR,'.'),0,255,INSTR(VSTR,'.') -INSTR(VSTR,'/') -1 ) ) ) AS KEY_
           , DECODE(INSTR(VSTR,'.'),0,NULL, SUBSTR(VSTR,INSTR(VSTR,'.')+1 ) ) AS STR
      INTO VNODEX, VKEYCODE ,VSTR
      FROM DUAL;
    VKEYCODE := NVL(VKEYCODE,'0');
    FOR J IN (
      SELECT BNODE,KEY_CODE,IN_KEY
        FROM MCIS_NODES_PATH
        WHERE  N = 0
          AND ANODE = 0
          AND BNODE = VNODEX
          AND (KEY_CODE = VKEYCODE OR VKEYCODE IS NULL)
          AND CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
          AND SYSDATE BETWEEN FD AND TD
    )
    LOOP
      VNODEX := J.BNODE;
      VKEYCODE := J.KEY_CODE ;
      VINKEY := J.IN_KEY ;
      IF VINKEY = 2 THEN
        VSTR := NULL;
      END IF; -- IF VINKEY = 2 THEN
    END LOOP;
    IF VNODEX IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>УЗЕЛ '||VSTR||' НЕ ЯВЛЯЕТСЯ БАЗОВЫМ! VNODEX=_'||VNODEX||'_</ERR>');
    END IF; --IF VINKEY IS NULL THEN THEN
  ELSE
    VNODEX := PNODE ;
  END IF;
  FOR J IN (
    SELECT X.BNODE,X.MSG,X.RESET_PROC_N,A.SUBMIT_ON_BAR , NVL(A.PERMIT,P.PERMIT) AS PERMIT
      FROM MCIS_NODES_PATH X
      JOIN MCIS_NODES P ON (
            P.TD=KK_COMMON.GETTD
            AND P.N = X.BNODE
            AND P.CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
          )
      LEFT OUTER JOIN  MCIS_NODES_ACCESS A ON (A.MCIS_NODES_N = P.N AND  A.TD = KK_COMMON.GETTD)
      WHERE X.ANODE =  VNODEX
        AND X.CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
        AND (    (  X.IN_KEY =2 AND X.KEY_CODE = VKEYCODE AND  VKEYCODE IS NOT NULL )
          OR (  X.IN_KEY =1  )
          OR (  X.IN_KEY =3 AND (VKEYCODE IS NOT NULL OR VSTR IS NOT NULL) AND X.KEY_CODE IS NULL AND (NVL(KEY_CODE,'_') != NVL(VKEYCODE,'_') OR NVL(X.KEY_CODE,'_') != NVL(VSTR,'_')) /*AND NVL(VKEYCODE,'_') != '27'*/)
         )
        AND X.TD=KK_COMMON.GETTD
      ORDER BY X.ORD
  )
  LOOP
    IF (J.PERMIT IS     NULL) OR (J.PERMIT IS NOT NULL AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,J.PERMIT,SYSDATE) = 3) THEN
      PNEXTNODE := J.BNODE;
      VMSGSTR := J.MSG ;
      VRESETPROCN := J.RESET_PROC_N;
      PSUBMITONBAR := NVL(J.SUBMIT_ON_BAR,0);
      EXIT;
    END IF;
  END LOOP;

  IF PNEXTNODE IS NULL THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НАЖАТОЕ НЕ СООТВЕТСВУЕТ УЗЛУ!!'||'</ERR>;VEMPN ='||VEMPN ||'; VNODEX='||VNODEX
      ||';VMCIS_NODES_COPY_N ='||VMCIS_NODES_COPY_N ||';VKEYCODE ='||VKEYCODE ||'; VSTR='||VSTR );
  END IF;

  WHILE TRUE LOOP
    IF VRESETPROCN = 1 THEN -- ЕСЛИ ПЕРЕХОД ПОМЕЧЕН КАК ОБНУЛЯЮЩИЙ ТО PPROCN := 0 ЗНАЧИТ ЧТО MCIS_NODES_PROC.UP БУДЕТ = 0
      PPROCN := 0 ;
    END IF;
    VINC := VINC+1;
    IF VINC > 100 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ПРОИЗОШЛО ЗАЦИКЛИВАНИЕ. ОБРАТИТЕСЬ К РАЗРАБОТЧИКАМ!!');
    END IF;
    EXIT WHEN (VIN_KEY =3) OR (VPROC IS NULL);
    VPROC := NULL;
  --  RAISE_APPLICATION_ERROR(-20000,PNEXTNODE );
    BEGIN
      SELECT P.PROC_NAME,P.ON_BARCODE_PROC,GREATEST(NVL(PSUBMITONBAR,1),NVL(A.SUBMIT_ON_BAR,1)), NVL(A.PERMIT,P.PERMIT) AS PERMIT
        INTO VPROC,PBARCODEPROC,PSUBMITONBAR , VPERMIT
        FROM MCIS_NODES P
        LEFT OUTER JOIN  MCIS_NODES_ACCESS A ON (A.MCIS_NODES_N = P.N AND A.TD = KK_COMMON.GETTD)
        WHERE P.N =  PNEXTNODE
          AND P.CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
          AND SYSDATE BETWEEN P.FD AND P.TD ;
    EXCEPTION
      WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
        RAISE_APPLICATION_ERROR(-20000,'PNEXTNODE='||PNEXTNODE||'; VMCIS_NODES_COPY_N='||VMCIS_NODES_COPY_N||SQLERRM);
    END;
    IF (VPERMIT IS NOT NULL) AND  ( KK_PERMIT.EXISTSPERMITACCESS(VEMPN,VPERMIT,SYSDATE) != 3 ) THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ОТСУТСТВУЕТ ДОСТУП '||VPERMIT ||'</ERR>' );
    END IF;
    IF  VPROC IS NOT NULL THEN
      BEGIN
        EXECUTE IMMEDIATE  'BEGIN :RET := ' ||VPROC || '(:PKEYCODE,:PSTR,:PMSG,:PNEXTNODE,:PPROCN,:PROBJN); END;'
          USING OUT VRET, IN VKEYCODE, IN VSTR, IN  OUT PMSG,IN OUT PNEXTNODE , IN OUT PPROCN, IN OUT PROBJN;
        IF VRET IS NULL THEN
          RAISE_APPLICATION_ERROR(-20000, 'ПРОЦЕДУРА: "'||VPROC||'" ВЕРНУЛА NULL. ОБРАТИТЕСЬ К РАЗРАБОТЧИКУ');
        END IF;
      EXCEPTION
        WHEN OTHERS THEN
          VERRMSG := SQLERRM ||CHR(13)||CHR(10)||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
          BAR_LOG(PNODE, PKEYCODE, PSTR, PROBJN, PPROCN, NULL, NULL, VERRMSG);
          IF VPROCAFTER != '_' THEN
            EXECUTE IMMEDIATE
              'BEGIN '||VPROCAFTER||'(:PNODE, :PKEYCODE, :PSTR, :PMSG, :PPROCN, :PROBJN); END;'
              USING  IN PNODE, IN PKEYCODE, IN PSTR, IN OUT VERRMSG, IN OUT PPROCN, IN OUT PROBJN;
          END IF;
          RAISE_APPLICATION_ERROR(-20911,
          --VPROC || '('|| PKEYCODE ||','||PSTR ||','||PMSG ||','||PNEXTNODE ||','||PPROCN ||','||PROBJN ||');' ||
          VERRMSG);
      END;
      BAR_LOG(PNODE, PKEYCODE, PSTR, PROBJN, PPROCN, VRET, PMSG, NULL);
      IF VPROCAFTER != '_' THEN
        EXECUTE IMMEDIATE
          'BEGIN '||VPROCAFTER||'(:PNODE, :PKEYCODE, :PSTR, :PMSG, :PPROCN, :PROBJN); END;'
          USING  IN PNODE, IN PKEYCODE, IN PSTR, IN  OUT PMSG, IN OUT PPROCN, IN OUT PROBJN;
      END IF;
      BEGIN
        IF VRET != 0 THEN
          SELECT BNODE,PMSG ||DECODE(X.MSG,NULL,NULL,V1310||X.MSG),IN_KEY,RESET_PROC_N
            INTO PNEXTNODE,PMSG, VIN_KEY,VRESETPROCN
            FROM MCIS_NODES_PATH  X
            JOIN MCIS_NODES P ON (
                  P.TD=KK_COMMON.GETTD
                  AND P.N = X.BNODE
                  AND P.CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
                )
            LEFT OUTER JOIN  MCIS_NODES_ACCESS A ON (A.MCIS_NODES_N = P.N AND  A.TD = KK_COMMON.GETTD)
            WHERE ANODE = PNEXTNODE
              AND X.CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
              AND X.TD = KK_COMMON.GETTD
              AND IF_PROC_RET =  VRET
              AND IF_PROC_RET != 0
              AND ((NVL(A.PERMIT,P.PERMIT) IS     NULL) OR (NVL(A.PERMIT,P.PERMIT) IS NOT NULL AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,NVL(A.PERMIT,P.PERMIT),SYSDATE) = 3));
          SELECT P.ON_BARCODE_PROC,NVL(A.SUBMIT_ON_BAR,1)
            INTO PBARCODEPROC,PSUBMITONBAR
            FROM MCIS_NODES P
            LEFT OUTER JOIN  MCIS_NODES_ACCESS A ON (A.MCIS_NODES_N = P.N AND A.TD = KK_COMMON.GETTD)
            WHERE P.N =  PNEXTNODE
              AND P.CIS_COPY_N IN (0,VMCIS_NODES_COPY_N)
              AND SYSDATE BETWEEN P.FD AND P.TD ;
          VMSGSTR := '';
        END IF;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RAISE_APPLICATION_ERROR(-20000,'НЕ НАЙДЕН ПЕРЕХОД ПО ВОЗВРАТУ ИЗ Ф-ЦИИ PNEXTNODE=' || PNEXTNODE ||'; VRET=' || VRET ||'; VPROC='|| VPROC || SQLERRM );
        WHEN OTHERS THEN -- CAUTION:HANDLES ALL EXCEPTIONS
          RAISE_APPLICATION_ERROR(-20000,' PNEXTNODE=' || PNEXTNODE ||'; VRET=' || VRET ||'; VPROC='|| VPROC|| SQLERRM  );
      END;
    ELSE
      BAR_LOG(PNODE, PKEYCODE, PSTR, PROBJN, PPROCN, NULL, PMSG, NULL);
      IF VPROCAFTER != '_' THEN
        EXECUTE IMMEDIATE
          'BEGIN '||VPROCAFTER||'(:PNODE, :PKEYCODE, :PSTR, :PMSG, :PPROCN, :PROBJN); END;'
          USING  IN PNODE, IN PKEYCODE, IN PSTR, IN  OUT PMSG, IN OUT PPROCN, IN OUT PROBJN;
      END IF;
    END IF; --VPROC IS NOT NULL THEN
  END LOOP; ---WHILE TRUE DO LOOP
  PBARCODEPROC := DOUBLESTRING(PBARCODEPROC);
  SELECT DOUBLESTRING(SUBSTR(PMSG||DECODE(PMSG,NULL,NULL,V1310)||VMSGSTR/*||PNEXTNODE*/,1,1500))
    INTO PMSG
    FROM DUAL;
  KK_TRACE.LOGON(VEMPN);
   --RAISE_APPLICATION_ERROR(-20000,'VEMPN ='||VEMPN);
  DBMS_ALERT.SIGNAL('ST_BAR_JOBS_' || VEMPN,
    '<M>' ||V1310 ||
    '<NEXT>' ||PNEXTNODE ||'</NEXT>'|| V1310||
    '<OBJ>' || PROBJN    ||'</OBJ>' || V1310||
    '<CODE>' ||VKEYCODE  ||'</CODE>'||V1310||
    '<STR>'  ||VSTR      ||'</STR>' ||V1310||
    '<MSG>'  ||TRIM(PMSG)||'</MSG>'||V1310||
    '</M>'
  );
  RETURN 0;
END PROC3;

PROCEDURE MOVETROUTHNODE(PNODE INTEGER,PTROUTHNODE INTEGER) IS
VMCIS_NODES_COPY_N INTEGER := KK_CONST.GETCONSTN('MCIS_NODES.CIS_COPY_N',SYSDATE,0);
BEGIN

INSERT INTO   MCIS_NODES_PATH
(N,ANODE,BNODE,FD,TD,MSG,CIS_COPY_N) VALUES
(SQ_MCIS_NODES_PATH.NEXTVAL,PNODE,PTROUTHNODE,SYSDATE,KK_COMMON.GETTD,'РЕДИРЕКТ ПЕРЕХОДА ЧЕРЕЗ ДРУГОЙ УЗЕЛ. СОЗДАНО АВТОМАТИЧЕСКИ',VMCIS_NODES_COPY_N);


UPDATE MCIS_NODES_PATH P
 SET ANODE = PTROUTHNODE
 WHERE P.ANODE = PNODE
  AND SYSDATE BETWEEN P.FD AND P.TD
  AND P.CIS_COPY_N = VMCIS_NODES_COPY_N;


END;

FUNCTION ONBARCODE(PPROCNAME VARCHAR2,PBARCODE VARCHAR2 )RETURN VARCHAR2 IS
VRET VARCHAR2(2500);
VSTR VARCHAR2(255);
VPROCNAME VARCHAR2(255);
VBARCODE VARCHAR2(255);
BEGIN

--RAISE_APPLICATION_ERROR(-20000,'PBARCODE='||PBARCODE);

VPROCNAME := CLEARNULLTERMINATEDSTRING(PPROCNAME);
VBARCODE  := CLEARNULLTERMINATEDSTRING(PBARCODE);

--   BEGIN
     VSTR := 'BEGIN  :PRET:='||VPROCNAME||'(:PBARCODE);  END;';
--     KK_COMMON.ERR_LOG('ONBARCODE','99',VSTR);
     EXECUTE IMMEDIATE VSTR
      USING OUT VRET, IN VBARCODE;

--     EXCEPTION
--      WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
--       VRET := SUBSTR(VSTR || SQLERRM,1,255);
--   END;

RETURN DOUBLESTRING(VRET);

END;

FUNCTION GETCELLADDRESSNAME(PBARCODE VARCHAR2 )RETURN VARCHAR2 IS
VRET VARCHAR2(255);
VCODE INTEGER;
VADDR CELL_ADDRESS.ADDR%TYPE;
BEGIN


BEGIN
SELECT TO_NUMBER(DECODE(INSTR(LOWER(PBARCODE),'C-'),
                  0,       PBARCODE
                   ,SUBSTR(PBARCODE,3)
                   )) INTO VCODE FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VCODE := 0;
   VADDR := PBARCODE;
END;

 BEGIN

 SELECT A.ADDR
    INTO VRET
 FROM CELL_ADDRESS A
 WHERE (A.N = VCODE OR VCODE = 0)
  AND (A.ADDR LIKE '%'||VADDR OR VADDR IS NULL  )
  AND SYSDATE BETWEEN A.FD AND A.TD;


 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
  VRET := 'GETCELLADDRESSNAME '|| SUBSTR(SQLERRM,1,30);
 END;

RETURN  DOUBLESTRING(VRET);

END;


FUNCTION GETNOMBYBARCODE(PBARCODE VARCHAR2 )RETURN VARCHAR2 IS
VRET VARCHAR2(1250);
VCNT INTEGER := 0 ;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN


FOR J IN (
 SELECT N.CODE ||' ' ||N.NAME AS NAME
   FROM NOM_BARCODE B,
      NOMENKLATURA N
 WHERE B.BAR_CODE = PBARCODE
  AND SYSDATE BETWEEN B.FD AND B.TD
  AND B.NOMENKLATURA_N = N.N
  AND SYSDATE BETWEEN N.FD AND N.TD
) LOOP
 VRET := SUBSTR( VRET || J.NAME ||V1310,1,1000) ;
 VCNT := VCNT +1;
END LOOP;

  IF VCNT = 0 THEN
    VRET := 'КОД НЕ НАЙДЕН! БУДЕТ СОЗДАНА ТЕХН. НОМЕНКЛАТУРА';
  END IF;

--RAISE_APPLICATION_ERROR(-20000,LENGTH(VRET));

RETURN  DOUBLESTRING(VRET);

END;

FUNCTION GETPARTBYBARCODE(PBARCODE VARCHAR2 )RETURN VARCHAR2 IS
--VRET VARCHAR2(1250);
--VCNT INTEGER := 0 ;
BEGIN

RETURN  DOUBLESTRING(PBARCODE);

END;


FUNCTION  INPUTCELLADDRESS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VCODE INTEGER;
VSTOREN INTEGER;
VLINE INTEGER;
VPLACE INTEGER;
VFLOR INTEGER;
VSTAGE INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VADDR CELL_ADDRESS.ADDR%TYPE;
VCELLTYPN INTEGER;
VCANIGNOREINPUT INTEGER:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUTFROM');
VCOMPARECELLBYFUNC INTEGER:= KK_CONST.GETCONSTN('COMPARECELLBYFUNC', SYSDATE);
VOPT VARCHAR2(50);
BEGIN



--RAISE_APPLICATION_ERROR(-20000,'QWEQWEQWE__'|| KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_BAR_JOBS.N')||'____'||PROBJN);
  IF VCANIGNOREINPUT=1 AND (NVL(PSTR,'0')='0' AND NVL(PKEYCODE,'0')='0') THEN
  --ВВОД АДРЕСА НЕ НУЖЕН, ТОГДА ВВОДИМ 0 ИЛИ НИЧЕГО НЕ ВВОДИМ

      INSERT INTO MCIS_NODES_PROC
        (N , TYP, VAL1, VAL2 , VAL3 ,VAL4,VAL5,VAL6, FD , TD , DSC, UP )
      VALUES
        (SQ_MCIS_NODES_PROC.NEXTVAL,13/*ЗАПОМНИЛИ НОМЕР ЯЧЕЙКИ*/,0,0,0,PMSG,0,0,SYSDATE,KK_COMMON.GETTD,0,PPROCN)
      RETURNING N INTO PPROCN;

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STORE_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS.CELL_TYP_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ADDR',NULL);
      RETURN 1;
  ELSE --НУЖЕН ВВОД АДРЕСА ЯЧЕЙКИ


     IF PSTR IS NOT NULL THEN

      BEGIN
       SELECT TO_NUMBER(DECODE(INSTR(PSTR,'C-')
                                      ,1,SUBSTR(PSTR,3)
                                      ,         PSTR
                             )
                        ) INTO VCODE FROM DUAL;
      EXCEPTION
         WHEN OTHERS THEN
           VCODE := -1;
           VADDR :=  PSTR  ;
      END;


     ELSE --IF PSTR IS NOT NULL THEN

           IF(KK_PERMIT.EXISTSPERMIT(VEMPN,'CELLADDRESS.FINDCELLBYADDRESS',SYSDATE,VOPT) <> 3) THEN
              IF NVL(VOPT,'0')='0' THEN -- ANEE IIOEE IONOUA - ?AAI, ANEE IAO OI ?AAI ANEE IA IIAOIAEO OEI Y?AEEE (CAIENUAAAONY A OPTIONS)
                  RAISE_APPLICATION_ERROR(-20000,  '<ERR>У ВАС НЕТ ДОСТУПА НА ВВОД ВРУЧНУЮ АДРЕСА (CELLADDRESS.FINDCELLBYADDRESS) *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>');
              END IF;
            END IF;

      BEGIN
       SELECT TO_NUMBER(REPLACE(PKEYCODE,'C-') ) INTO VCODE FROM DUAL;
---- ПОТЕСТИТЬ ВВОД АДРЕСА ИЗ ЦЫФР
        SELECT NVL(COUNT(1),0) INTO VCODE FROM CELL_ADDRESS CA WHERE LOWER(CA.ADDR) = LOWER(VCODE) AND CA.TD = KK_COMMON.GETTD;
        IF NVL(VCODE,0) = 1 THEN VCODE:= -1; VADDR:= PKEYCODE; END IF;
---- ПОТЕСТИТЬ ВВОД АДРЕСА ИЗ ЦЫФР
      EXCEPTION
         WHEN OTHERS THEN
           VCODE := -1;
           VADDR := PKEYCODE;
      END;

     END IF; --IF PSTR IS NOT NULL THEN

--RAISE_APPLICATION_ERROR(-20001,'VCODE='||VCODE||' VADDR='||VADDR);

     BEGIN
        SELECT/*+ ORDERED*/  A.ADDR , A.N,A.STORE_N,A.FLOR,A.LINE,A.PLACE,A.STAGE,A.CELL_TYP_N
         INTO PMSG ,VN,VSTOREN,VFLOR,VLINE,VPLACE,VSTAGE,VCELLTYPN
         FROM
          CELL_ADDRESS A
         WHERE (N = VCODE OR VCODE = -1)
         AND  (  VADDR IS NULL
              OR VCOMPARECELLBYFUNC = -1 AND LOWER(A.ADDR)=LOWER(VADDR)
              OR VCOMPARECELLBYFUNC =  1 AND INPUTADDRESS_COMPARE(VADDR,A.ADDR)=1 AND VADDR IS NOT NULL
               )
           AND STORE_N>0
          AND SYSDATE BETWEEN FD AND TD
          /*AND ROWNUM  =1*/ ;  -- КОГД ЯЧЕЙКА С ОДНИМ ИМЕНЕНМ НА РАЗНЫХ СКАЛАДАХ, ЭТО В ДАЛЬНЕЙШЕМ ПРИВОДИТ К ОШИБКАМ - НАДО РВАТЬ СРАЗУ


               EXCEPTION
         WHEN OTHERS THEN

                  /*RAISE_APPLICATION_ERROR(-20012,'TEST 2A
                  PKEYCODE='||PKEYCODE||'; CELLN='||VN||'; MSG='||SQLERRM||' + '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
       */
            --RAISE_APPLICATION_ERROR(-20000,VCOMPARECELLBYFUNC||' '||VADDR);
            SELECT/*+ ORDERED*/  A.ADDR , A.N,A.STORE_N,A.FLOR,A.LINE,A.PLACE,A.STAGE,A.CELL_TYP_N
               INTO PMSG ,VN,VSTOREN,VFLOR,VLINE,VPLACE,VSTAGE,VCELLTYPN
            FROM
               CELL_ADDRESS A
            WHERE 1=1
               AND  (  VCOMPARECELLBYFUNC = -1 AND LOWER(A.ADDR)=LOWER(VADDR)
                    OR VCOMPARECELLBYFUNC =  1 AND INPUTADDRESS_COMPARE(VADDR,A.ADDR)=1 AND VADDR IS NOT NULL
                     )
               AND VADDR IS NOT NULL
               AND STORE_N>0
               AND TD = KK_COMMON.GETTD
               /* AND ROWNUM  =1 */ ; -- КОГД ЯЧЕЙКА С ОДНИМ ИМЕНЕНМ НА РАЗНЫХ СКАЛАДАХ, ЭТО В ДАЛЬНЕЙШЕМ ПРИВОДИТ К ОШИБКАМ - НАДО РВАТЬ СРАЗУ

                       /*RAISE_APPLICATION_ERROR(-20012,'TEST 2  PKEYCODE='||PKEYCODE||'; CELLN='||VN||'; MSG='||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
     */
         END;

IF  PKEYCODE IS NOT NULL
        AND KK_PERMIT.EXISTSPERMIT(VEMPN,'CELLADDRESS.FINDCELLBYADDRESS',SYSDATE,VOPT) <> 3
        AND VOPT LIKE '%,'||VCELLTYPN||',%' THEN
       -- ЕСЛИ ОПЦИИ ПУСТЫЕ - РВЕМ, ЕСЛИ НЕТ ТО РВЕМ ЕСЛИ НЕ ПОДХОДИТ ТИП ЯЧЕЙКИ (ЗАПИСЫВАЕТСЯ В OPTIONS)
        RAISE_APPLICATION_ERROR(-20000,  '<ERR>У ВАС НЕТ ДОСТУПА НА ВВОД ВРУЧНУЮ АДРЕСА (CELLADDRESS.FINDCELLBYADDRESS) *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>');
    END IF;


    IF VN = 0 OR VSTOREN = 0 THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERROR>ОШИБКА ПРИ ВВОДЕ АДРЕСА VN='||VN||'; VSTOREN='||VSTOREN||' </ERROR>');
    END IF;


   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4,VAL5,VAL6, FD , TD , DSC, UP )  VALUES
     (SQ_MCIS_NODES_PROC.NEXTVAL,13/*ЗАПОМНИЛИ НОМЕР ЯЧЕЙКИ*/,VN,VSTOREN,VFLOR,PMSG,VLINE,VPLACE,SYSDATE,KK_COMMON.GETTD,VSTAGE,PPROCN)
      RETURNING N INTO PPROCN;

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS_N',VN);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STORE_N',VSTOREN);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS.CELL_TYP_N',VCELLTYPN);
         PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ADDR',PMSG);


   RETURN 1;
END IF; -- /НУЖЕН ВВОД АДРЕСА ЯЧЕЙКИ
--RAISE_APPLICATION_ERROR(-20000,'QWEQWEQWE__'|| KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_BAR_JOBS.N')||'____'||PROBJN);
EXCEPTION
    WHEN OTHERS THEN
  --   KK_COMMON.ACTION(VEMPN,'INPUT.CELL_ADDRESS',VCODE,1,SYSDATE,'PKEYCODE='||PKEYCODE||'; PSTR='||PSTR);
     RAISE_APPLICATION_ERROR(-20000,  '<ERR>ЯЧЕЙКА НЕ ОБНАРУЖЕНА *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>' ||SQLERRM||' + '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);

END INPUTCELLADDRESS;


FUNCTION  INPUTCELLADDRESSTO(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VCODE INTEGER;
VSTOREN INTEGER;
VLINE INTEGER;
VPLACE INTEGER;
VFLOR INTEGER;
VSTAGE INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VADDR CELL_ADDRESS.ADDR%TYPE;
VCELLTYPN INTEGER;
VCANIGNOREINPUT INTEGER:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUTFROM');
BEGIN

  IF VCANIGNOREINPUT=1 AND (NVL(PSTR,'0')='0' OR NVL(PKEYCODE,'0')='0') THEN
  --ВВОД АДРЕСА НЕ НУЖЕН, ТОГДА ВВОДИМ 0 ИЛИ НИЧЕГО НЕ ВВОДИМ

      INSERT INTO MCIS_NODES_PROC
        (N , TYP, VAL1, VAL2 , VAL3 ,VAL4,VAL5,VAL6, FD , TD , DSC, UP )
      VALUES
        (SQ_MCIS_NODES_PROC.NEXTVAL,13/*ЗАПОМНИЛИ НОМЕР ЯЧЕЙКИ*/,0,0,0,PMSG,0,0,SYSDATE,KK_COMMON.GETTD,0,PPROCN)
      RETURNING N INTO PPROCN;

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.CELL_ADDRESS_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.STORE_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.CELL_ADDRESS.CELL_TYP_N',0);
         PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.ADDR',NULL);
      RETURN 1;
  ELSE --НУЖЕН ВВОД АДРЕСА ЯЧЕЙКИ


     IF PSTR IS NOT NULL THEN

      BEGIN
       SELECT TO_NUMBER(DECODE(INSTR(PSTR,'C-')
                                      ,1,SUBSTR(PSTR,3)
                                      ,         PSTR
                             )
                        ) INTO VCODE FROM DUAL;
      EXCEPTION
         WHEN OTHERS THEN
           VCODE := -1;
           VADDR :=  PSTR  ;
      END;


     ELSE --IF PSTR IS NOT NULL THEN

            IF(KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CELLADDRESS.FINDCELLBYADDRESS',SYSDATE) <> 3) THEN
              RAISE_APPLICATION_ERROR(-20000,  '<ERR>У ВАС НЕТ ДОСТУПА НА ВВОД ВРУЧНУЮ АДРЕСА (CELLADDRESS.FINDCELLBYADDRESS) *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>');
            END IF;


      BEGIN
       SELECT TO_NUMBER(PKEYCODE) INTO VCODE FROM DUAL;
      EXCEPTION
         WHEN OTHERS THEN
           VCODE := -1;
           VADDR :=  PKEYCODE;
      END;


     END IF; --IF PSTR IS NOT NULL THEN



     BEGIN
        SELECT/*+ ORDERED*/  A.ADDR , A.N,A.STORE_N,A.FLOR,A.LINE,A.PLACE,A.STAGE,A.CELL_TYP_N
         INTO PMSG ,VN,VSTOREN,VFLOR,VLINE,VPLACE,VSTAGE,VCELLTYPN
         FROM
          CELL_ADDRESS A
         WHERE (N = VCODE OR VCODE = -1)
         AND  (INPUTADDRESS_COMPARE(VADDR,A.ADDR)=1
                 --LOWER(A.ADDR)=LOWER(VADDR)
                   OR VADDR IS NULL
              )
           AND STORE_N>0
          AND SYSDATE BETWEEN FD AND TD
          AND ROWNUM  =1 ;
        EXCEPTION
         WHEN OTHERS THEN
            --RAISE_APPLICATION_ERROR(-20000,'<ERROR>IOEGEA I?E AAIAA AA?ANA</ERROR>');
            SELECT/*+ ORDERED*/  A.ADDR , A.N,A.STORE_N,A.FLOR,A.LINE,A.PLACE,A.STAGE,A.CELL_TYP_N
               INTO PMSG ,VN,VSTOREN,VFLOR,VLINE,VPLACE,VSTAGE,VCELLTYPN
            FROM
               CELL_ADDRESS A
            WHERE
               --(LOWER(A.ADDR) LIKE '%'|| LOWER(PKEYCODE))
               --НУЖНО ДЛЯ PI - ИМЯ ОДНОЙ ЯЧЕЙКИ СОДЕОЖИТ ДРУГУЮ
               --(LOWER(A.ADDR)= LOWER(PKEYCODE))
                INPUTADDRESS_COMPARE(PKEYCODE,A.ADDR)=1
               AND STORE_N>0
               AND SYSDATE BETWEEN FD AND TD
               AND ROWNUM  =1 ;
         END;

    IF VN = 0 OR VSTOREN = 0 THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERROR>ОШИБКА ПРИ ВВОДЕ АДРЕСА VN='||VN||'; VSTOREN='||VSTOREN||' </ERROR>');
    END IF;

   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4,VAL5,VAL6, FD , TD , DSC, UP )  VALUES
     (SQ_MCIS_NODES_PROC.NEXTVAL,13/*ЗАПОМНИЛИ НОМЕР ЯЧЕЙКИ*/,VN,VSTOREN,VFLOR,PMSG,VLINE,VPLACE,SYSDATE,KK_COMMON.GETTD,VSTAGE,PPROCN)
      RETURNING N INTO PPROCN;

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.CELL_ADDRESS_N',VN);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.STORE_N',VSTOREN);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.CELL_ADDRESS.CELL_TYP_N',VCELLTYPN);
         PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.ADDR',PMSG);


   RETURN 1;
END IF; -- /НУЖЕН ВВОД АДРЕСА ЯЧЕЙКИ
EXCEPTION
    WHEN OTHERS THEN
     KK_COMMON.ACTION(VEMPN,'INPUT.CELL_ADDRESS',VCODE,1,SYSDATE,'PKEYCODE='||PKEYCODE||'; PSTR='||PSTR);
     RAISE_APPLICATION_ERROR(-20000,  '<ERR>ЯЧЕЙКА НЕ ОБНАРУЖЕНА *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>' ||SQLERRM);

END INPUTCELLADDRESSTO;

FUNCTION STDOCINDETSETADDR(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN


 FOR J IN (SELECT VAL1
 FROM MCIS_NODES_PROC
 WHERE SYSDATE BETWEEN FD AND TD
       AND TYP =20
   CONNECT BY PRIOR UP = N
  START WITH N = PPROCN
   ORDER BY LEVEL
  ) LOOP


UPDATE ST_DOC_IN_DET
 SET CELL_ADDRESS_FR = DECODE(NVL(CELL_ADDRESS_FR,0),0, KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS_N'),CELL_ADDRESS_FR)
  WHERE N = J.VAL1
  AND SYSDATE BETWEEN FD AND TD
  ;


END LOOP;

RETURN 1;

END STDOCINDETSETADDR;



FUNCTION  INPUTCELLADDRESSSILENT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VCODE INTEGER;
VSTOREN INTEGER;
VLINE INTEGER;
VPLACE INTEGER;
VFLOR INTEGER;
VSTAGE INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VADDR CELL_ADDRESS.ADDR%TYPE;
VCELLTYPN INTEGER;
BEGIN

 IF PKEYCODE = '0' THEN
 RETURN -1;

 END IF;


   BEGIN



SELECT TO_NUMBER(DECODE(INSTR(NVL(PSTR,PKEYCODE),'C-')
                   ,1,NVL(          SUBSTR(PSTR,3),PKEYCODE)
                     ,NVL(          PSTR,PKEYCODE   )
                   )) INTO VCODE FROM DUAL;
   EXCEPTION
      WHEN OTHERS THEN
        VCODE := 0;
       VADDR :=  NVL(PKEYCODE,PSTR);
   END;

     SELECT/*+ ORDERED*/  A.ADDR , A.N,A.STORE_N,A.FLOR,A.LINE,A.PLACE,A.STAGE,A.CELL_TYP_N
      INTO PMSG ,VN,VSTOREN,VFLOR,VLINE,VPLACE,VSTAGE,VCELLTYPN
      FROM
       CELL_ADDRESS A
      WHERE (N = VCODE OR VCODE = 0)
      AND  (INPUTADDRESS_COMPARE(VADDR,A.ADDR)=1
             --LOWER(A.ADDR) LIKE '%'|| LOWER(VADDR)
               OR VADDR IS NULL
            )
       AND SYSDATE BETWEEN FD AND TD
       AND ROWNUM  =1 ;


SELECT/*+ ORDERED*/  A.ADDR , A.N,A.STORE_N,A.FLOR,A.LINE,A.PLACE,A.STAGE,A.CELL_TYP_N
      INTO PMSG ,VN,VSTOREN,VFLOR,VLINE,VPLACE,VSTAGE,VCELLTYPN
      FROM
       CELL_ADDRESS A
      WHERE (N = VCODE OR VCODE = 0)
      AND  (INPUTADDRESS_COMPARE(VADDR,A.ADDR)=1
             --  LOWER(A.ADDR) LIKE '%'|| LOWER(VADDR)
             OR VADDR IS NULL)
       AND SYSDATE BETWEEN FD AND TD
       AND ROWNUM  =1 ;


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4,VAL5,VAL6, FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,13/*ЗАПОМНИЛИ НОМЕР ЯЧЕЙКИ*/,VN,VSTOREN,VFLOR,PMSG,VLINE,VPLACE,SYSDATE,KK_COMMON.GETTD,VSTAGE,PPROCN)
   RETURNING N INTO PPROCN;

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS_N',VN);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STORE_N',VSTOREN);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS.CELL_TYP_N',VCELLTYPN);


RETURN 1;

EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20000,'ОШИБА ОПЕРЕДЕЛНИЯ ЯЧЕЙКИ PKEYCODE='||PKEYCODE ||';  PSTR='||PSTR);

END INPUTCELLADDRESSSILENT;

FUNCTION INITIALMOVEINSERTROOT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,31,NULL,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ПЕРЕМЕЩЕНИЕ ПО ИНИЦИАТИВЕ',0)
   RETURNING N INTO PPROCN;

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'STORE_N',0);

      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.CELL_ADDRESS_N',0);
      PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'TO.STORE_N',0);


PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',0);


    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CNT',0);

RETURN 1;
END;

FUNCTION INITIALMOVESUBMIT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 0;
VCELLTO INTEGER := 0;
VSTORETO INTEGER;
VSTDOCMOVEN INTEGER := 0;
VSTDOCMOVETYP INTEGER ;
VFD DATE :=SYSDATE;
VNDET INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VPALLN INTEGER;
VXRET INTEGER := 0;
VCONTRAGENTN INTEGER;
VLISTAREAS VARCHAR2(500) :=KK_CONST.GETCONSTV('DENYALLOCOTHERCONTRAGENT.CELLAREAS',SYSDATE);
VJOBN INTEGER;
VPROCNAME LIST_CONST.VAL%TYPE;
VN INTEGER;
CURSOR VSTOCKCUR IS
    SELECT ROWID
        FROM
          ST_STOCK ST
                    WHERE ST.TYP IN (1/*IN*/,3,5,10,12/*BRAK*/,13/*UNRESERVED*/)
                    AND SYSDATE BETWEEN ST.FD AND ST.TD
                    AND ST.CNT > 0
                    AND ST.TD = TO_DATE('01-01-3000','DD-MM-YYYY')
                    AND N IN (SELECT  VAL1 FROM MCIS_NODES_PROC
              WHERE TYP = 29
                CONNECT BY PRIOR UP = N AND SYSDATE BETWEEN FD AND TD
                    START WITH N = PPROCN AND SYSDATE BETWEEN FD AND TD
                    )
               FOR UPDATE NOWAIT ;

BEGIN


FOR J IN (SELECT VAL1,VAL2,TYP,VAL5 FROM MCIS_NODES_PROC
             CONNECT BY PRIOR UP = N AND SYSDATE BETWEEN FD AND TD
                 START WITH N = PPROCN AND SYSDATE BETWEEN FD AND TD
               ORDER BY LEVEL
) LOOP
    IF J.TYP = 29 THEN
     VPALLN := J.VAL5;
    END IF; --IF J.TYP = 29 THEN

    IF J.TYP = 13 THEN

       IF VCELLTO = 0 THEN

        VCELLTO := J.VAL1;
        VSTORETO := J.VAL2;

       ELSE
/*        IF VSTORETO != J.VAL2 THEN
             PMSG := 'МЕЖСКЛАДСКИЕ ПЕРЕМЕЩЕНИЯ ЗАПРЕЩЕНЫ!';
             RETURN 2;
        END IF;

        IF J.VAL1 = VCELLTO THEN
             PMSG := 'АДРЕС НАЗНАЧЕНИЯ ДОЛЖЕН ОТЛИЧАТЬСЯ!';
             RETURN 2;
        END IF;
  */


            BEGIN
                OPEN VSTOCKCUR;
                CLOSE VSTOCKCUR;

            EXCEPTION
               WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
               CLOSE VSTOCKCUR;
               PMSG := 'СТОК ЗАБЛОКИРОВАН.ПОПОРОБУЙТЕ ЕЩЕ РАЗ!';
                 RETURN 3;
            END;


    SELECT KK_CONST.GETCONSTN ('STDOCMOVETYPFORINITIATIVMOVE',VFD,VSTORETO) INTO VSTDOCMOVETYP FROM DUAL;

FOR K IN (
       SELECT/*+ ORDERED INDEX_DESC(ST ST_STOCK_N_FD_TD)*/ RANK()OVER ( ORDER BY P.RN DESC)AS P_R,
            RANK()OVER ( PARTITION BY DECODE(ST.N,NULL,0,1) ORDER BY ST.N)AS S_R,
            ST.CONTRAGENT_N ,ST.NOMENKLATURA_N, ST.EXPIRE_DATE,ST.MAKE_DATE,  ST.CNT,   ST.CELL_ADDRESS_N ,ST.N,ST.NOM_TYP,ST.STORE_N,
            ST.ROWID AS RD
        FROM
          (SELECT ROW_NUMBER() OVER (PARTITION BY 1 ORDER BY P.VAL1) AS RN ,P.VAL1
              FROM
            (SELECT  VAL1 FROM MCIS_NODES_PROC
              WHERE TYP = 29
                CONNECT BY PRIOR UP = N AND SYSDATE BETWEEN FD AND TD
                    START WITH N = PPROCN AND SYSDATE BETWEEN FD AND TD
                    ORDER BY VAL1 DESC
              ) P
              ) P
              LEFT OUTER JOIN ST_STOCK ST
                    ON (ST.N = P.VAL1  AND ST.TYP IN (1/*IN*/,3,5,10,12/*BRAK*/,13/*UNRESERVED*/)
                    AND SYSDATE BETWEEN ST.FD AND ST.TD
                    AND ST.CNT > 0
                    AND ST.TD = TO_DATE('01-01-3000','DD-MM-YYYY'))
ORDER BY P.RN
) LOOP

   IF VSTORETO != K.STORE_N THEN
             PMSG := 'МЕЖСКЛАДСКИЕ ПЕРЕМЕЩЕНИЯ ЗАПРЕЩЕНЫ!';
             RETURN 4;
        END IF;


   IF VCELLTO = K.CELL_ADDRESS_N THEN
             PMSG := 'АДРЕС НАЗНАЧЕНИЯ ДОЛЖЕН ОТЛИЧАТЬСЯ!';
             RETURN 2;
   END IF;

--//////////// ПРОВЕРКА МОЖНО ЛИ ПЕРЕМЕЩАТЬ В ОДНУ ЯЧЕЙКУ НЕСКОЛЬКИХ КОНТРАГЕНТОВ (ПО ЗАПРОСУ UPS)
 DECLARE
 VCNT0 INTEGER;
 VCNT INTEGER;
 VCONTRAGENT INTEGER;
 VDENYMOVEOTHERCONTRAGENT INTEGER;
 BEGIN
 SELECT KK_CONST.GETCONSTN('DENYMOVEOTHERCONTRAGENTCELL2CELL',SYSDATE,STORE_N) INTO VDENYMOVEOTHERCONTRAGENT
 FROM CELL_ADDRESS WHERE N=VCELLTO AND TD=KK_COMMON.GETTD AND ROWNUM<2;
 IF VDENYMOVEOTHERCONTRAGENT = 1 THEN
    BEGIN
     SELECT DISTINCT CONTRAGENT_N INTO VCONTRAGENT
     FROM V_ST_STOCK_ACTIVE A
     WHERE A.ST_PALL_N=VPALLN
       AND A.TD=KK_COMMON.GETTD;
    EXCEPTION WHEN OTHERS THEN VCONTRAGENT:=0;
    END;
     SELECT COUNT(1) INTO VCNT
      FROM V_ST_STOCK_ACTIVE A
          JOIN CELL_ADDRESS CA ON (CA.N=A.CELL_ADDRESS_N AND CA.TD=KK_COMMON.GETTD AND (VLISTAREAS='0' OR VLISTAREAS NOT LIKE '%,'||CA.STORE_AREA||',%'))
          WHERE A.CONTRAGENT_N!=VCONTRAGENT
            AND A.CELL_ADDRESS_N=VCELLTO
            AND A.TD=KK_COMMON.GETTD;

        IF VCNT > 0 THEN
          RAISE_APPLICATION_ERROR(-20000,'ЯЧЕЙКА №'||VCELLTO||' ЗАНЯТА ДРУГИМ КОНТРАГЕНТОМ!');
        END IF;
  END IF; --IF VDENYMOVEOTHERCONTRAGENT = 1 THEN

 END; --DECLARE
--//////////// END ПРОВЕРКА МОЖНО ЛИ ПЕРЕМЕЩАТЬ В ОДНУ ЯЧЕЙКУ НЕСКОЛЬКИХ КОНТРАГЕНТОВ

--//////////// ПРОВЕРКА МОЖНО ЛИ ПЕРЕМЕЩАТЬ В ОДНУ ЯЧЕЙКУ ТОВАРЫ РАЗНЫХ ГРУПП (ПО ЗАПРОСУ UPS)
 DECLARE
 VCNT INTEGER;
 VGROUP VARCHAR2(500);
 VDENYMOVEOTHERGROUP INTEGER;
 VCONTRAGENT INTEGER;
 BEGIN

 BEGIN
   SELECT CONTRAGENT_N INTO VCONTRAGENT
   FROM V_ST_STOCK_ACTIVE A
   WHERE A.ST_PALL_N=VPALLN
     AND A.TD=KK_COMMON.GETTD;
 EXCEPTION WHEN OTHERS THEN VCONTRAGENT:=0;
 END;

 VDENYMOVEOTHERGROUP:= KK_CONST.GETCONSTN('DENYMOVEOTHERGROUPCELL2CELL',SYSDATE,VCONTRAGENT);
 IF VDENYMOVEOTHERGROUP = 1 THEN
 SELECT COUNT(DISTINCT N.GROUP_N),STRAGG(N.GROUP_N) INTO VCNT,VGROUP
  FROM V_ST_STOCK_ACTIVE A
  JOIN NOMENKLATURA N ON (N.N=A.NOMENKLATURA_N AND N.TD=KK_COMMON.GETTD)
 WHERE A.ST_PALL_N=VPALLN
   AND A.TD=KK_COMMON.GETTD;
 IF VCNT=1 THEN
  SELECT COUNT(1) INTO VCNT
  FROM V_ST_STOCK_ACTIVE A
       JOIN NOMENKLATURA N ON (N.N=A.NOMENKLATURA_N AND TO_CHAR(N.GROUP_N)!=VGROUP AND N.TD=KK_COMMON.GETTD)
       JOIN CELL_ADDRESS CA ON (CA.N=A.CELL_ADDRESS_N AND CA.TD=KK_COMMON.GETTD AND (VLISTAREAS='0' OR VLISTAREAS NOT LIKE '%,'||CA.STORE_AREA||',%'))
      WHERE A.CONTRAGENT_N=VCONTRAGENT
        AND A.CELL_ADDRESS_N=VCELLTO
        AND A.TD=KK_COMMON.GETTD;

    IF VCNT > 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'В ЯЧЕЙКЕ №'||VCELLTO||' УЖЕ СОДЕРЖИТСЯ ТОВАР ДРУГОЙ ГРУППЫ!');
    END IF;
  END IF;
 END IF; --IF VDENYMOVEOTHERGROUP = 1 THEN

 END; --DECLARE
--//////////// END ПРОВЕРКА МОЖНО ЛИ ПЕРЕМЕЩАТЬ В ОДНУ ЯЧЕЙКУ ТОВАРЫ РАЗНЫХ ГРУПП (ПО ЗАПРОСУ UPS)


    IF VSTDOCMOVEN = 0 THEN
      SELECT SQ_ST_DOC_DET.NEXTVAL INTO VSTDOCMOVEN FROM DUAL;
      VCONTRAGENTN := K.CONTRAGENT_N ;
    END IF;

  INSERT INTO ST_DOC_MOVE_DET
  (N, ST_DOC_MOVE_N, NOMENKLATURA_N, EXPIRE_DATE,MAKE_DATE,   CNT,   CELL_ADDRESS_N, CELL_ADDRESS_NEW_N, DSC, FD,STOCK_N,NOM_TYP,LEFT,ST_PALL_N)
     VALUES
    (SQ_ST_DOC_DET.NEXTVAL, VSTDOCMOVEN, K.NOMENKLATURA_N, K.EXPIRE_DATE,K.MAKE_DATE,  K.CNT,   K.CELL_ADDRESS_N , VCELLTO, 'ПЕРЕМЕЩЕНИЕ ПО ИНИЦИАТИВЕ СКЛАДА', VFD,K.N,K.NOM_TYP,0,VPALLN)
   RETURNING
      N
    INTO
  VNDET;

KK_COMMON.ACTION(VEMPN,'ST_DOC_MOVE_DET',VNDET,1,SYSDATE);
--KK_ST_BAR_JOBS.CREATEJOBONEMP(PROBJN,VNDET,3,13,0,K.CNT,3,SYSDATE,K.CONTRAGENT_N,K.NOMENKLATURA_N,VSTDOCMOVEN,SYSDATE-1/86400,K.CELL_ADDRESS_N);
--ВМЕСТО CREATEJOBONEMP ВСТАВЛЯЕМ НАПРЯМУЮ (В ЭТОЙ ПРОЦЕДУРЕ НЕ ВСЕ ДАННЫЕ ПЕРЕДАЮТСЯ). ТАРАБЦЕВ
  INSERT INTO ST_BAR_JOBS
           (N,                FD,                TD,    TYP, PRIORITY,  STATUS, TERMINAL_N,EMP_N,ST_DOC_TYP,ST_DOC_N,DSC,VAL1,RN,OP_FD,           VAL2,CONTRAGENT_N,NOMENKLATURA_N,VAL3,BASE_DOC_N,ST_STOCK_N,ST_PALL_N,JOB_BLOCK,CNT,    UP,CELL_ADDRESS_N)
  VALUES (SQ_ST_BAR_JOBS.NEXTVAL, SYSDATE - 1/86400,SYSDATE, 13, NULL, 3, 0, NVL(VEMPN,0), 3, VNDET, 'KK_ST_BARCODE.INITIALMOVESUBMIT', K.CNT/*VVAL1*/, 1, SYSDATE - 1/86400, K.CELL_ADDRESS_N/*VVAL2*/, K.CONTRAGENT_N, K.NOMENKLATURA_N, 1/*VVAL3*/, VSTDOCMOVEN, K.N, VPALLN, NULL, K.CNT, 0, K.CELL_ADDRESS_N
  )
  RETURNING N INTO VJOBN;
  KK_COMMON.ACTION(VEMPN, 'ST_BAR_JOBS', VJOBN, 1, SYSDATE, 'KK_ST_BARCODE10.PID2PIDCOMPLETEMOVE');


  INSERT INTO ST_BAR_JOBS_PROTOCOL
  (N ,  FD ,  ST_BAR_JOBS_N ,  TERMINAL_N ,  STATUS ,  EMP_N ) VALUES
  (SQ_ST_BAR_JOBS_PROTOCOL.NEXTVAL,SYSDATE - 1/86400,VJOBN,0,1,NVL(VEMPN,0));


  INSERT INTO ST_BAR_JOBS_PROTOCOL
  (N ,  FD ,  ST_BAR_JOBS_N ,  TERMINAL_N ,  STATUS ,  EMP_N ) VALUES
  (SQ_ST_BAR_JOBS_PROTOCOL.NEXTVAL,SYSDATE ,VJOBN,0,3,NVL(VEMPN,0));


 VXRET :=  KK_ST_DOC_NEW.ST_MOVE2( VSTDOCMOVEN ,K.CONTRAGENT_N,VFD,K.STORE_N ,VNDET,1 /*PIGNOREBLOCK */, 3 ) ;

  VPROCNAME := KK_CONST.GETCONSTV('STDOC.PALLJOBCOMPLETE.USERPROC',SYSDATE,K.CONTRAGENT_N, 13);
  IF VPROCNAME != '_' THEN
   EXECUTE IMMEDIATE 'BEGIN '||VPROCNAME||'(:PROBJN , :PCONTRAGENTN ,   :PBASEDOCN   ,:PJOBN     , :PTYP  , :PNEWCELL   ,:PNEWCELLDT   ,:PEMPN );  END;'
                                  USING  IN PROBJN, IN K.CONTRAGENT_N,  IN VSTDOCMOVEN, IN VJOBN, IN 13, IN K.CELL_ADDRESS_N,IN VCELLTO, IN VEMPN;
  END IF ;
  KK_ST_RESERVE_VIRT.UNRESERVENOMCELLORDERS(PSKIPDOCN => 0,
                                            PNOMN     => K.NOMENKLATURA_N,
                                            PCELLN    => K.CELL_ADDRESS_N,
                                            PEMPN     => VEMPN);
     END LOOP;
       PPROCN :=0;
       VRET := 1;
       KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN , 0,13,VPALLN,NULL,VCELLTO,VSTDOCMOVEN);
/*
--COMPLETEJOB(
 PROBJN INTEGER
,PJOBN INTEGER
,PJOBTYP INTEGER DEFAULT 0
,PJOBDOCN INTEGER DEFAULT 0
,PVAL1 NUMBER DEFAULT NULL
,PDSC VARCHAR2 DEFAULT NULL
,PVAL2 NUMBER DEFAULT NULL
,PSTATUS INTEGER DEFAULT 3
,PTD DATE DEFAULT SYSDATE
,PVAL3 NUMBER DEFAULT NULL
,PEMPN INTEGER DEFAULT NULL
,PRECREATESTATUS INTEGER DEFAULT 0 ) AS
  */
      END IF; --IF VCELLTO != 0 THEN

    END IF; -- IF J.TYP = 13 THEN


END LOOP;


  IF VSTDOCMOVEN != 0 THEN

   VSTDOCMOVEN := KK_ST_DOC.CREATESTDOCMOVEHEADER(VSTDOCMOVEN ,VCONTRAGENTN ,'ПЕРЕМЕЩЕНИЕ ПО ИНИЦИАТИВЕ СКЛАДА' ,VFD,3/*DIC 466 ПОДТВЕРЖДЕН СРАЗУ*/,0,VSTDOCMOVETYP,VEMPN);
     UPDATE ST_DOC_MOVE
       SET MOVE_DATE = FD,
          STATUS_DATE =FD
       WHERE N = VSTDOCMOVEN
        AND TD = KK_COMMON.GETTD ;

   END IF; --     IF VSTDOCMOVEN != 0 THEN

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_MOVE.N',VSTDOCMOVEN);

RETURN VRET;
END;

FUNCTION INITIALMOVENOPALLIDINPUTCNT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

RETURN 1;
END;

FUNCTION INITIALMOVENOPALLIDINPUTNOM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
 VCNT INTEGER := 0;
 VCODE VARCHAR2(255);
 VEXPIRE INTEGER;
 VCONTRAGENTN INTEGER;
BEGIN


IF PSTR IS NOT NULL THEN

      FOR J IN (SELECT/*+ ORDERED*/ B.NOMENKLATURA_N , N.CODE,ROWNUM AS RN,EXPIRE , B.CONTRAGENT_N
                  FROM NOM_BARCODE B
                   , NOMENKLATURA N
                    WHERE B.BAR_CODE  = PSTR
                         AND SYSDATE BETWEEN  B.FD  AND B.TD
                         AND N.N = B.NOMENKLATURA_N
                         AND SYSDATE BETWEEN N.FD AND N.TD ) LOOP

           VNOMN :=  J.NOMENKLATURA_N ;
           VEXPIRE := J.EXPIRE;
           VCONTRAGENTN := J.CONTRAGENT_N;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5 , VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,27/*ЗАПОМНИЛИ СПИСОК КОДОВ НОМЕНКЛАТУРЫ*/,J.NOMENKLATURA_N,J.RN,PSTR,J.CODE,SYSDATE,KK_COMMON.GETTD,'СПИСОК НОМЕНКЛАТУРЫ',PPROCN,J.EXPIRE,J.CONTRAGENT_N)
   RETURNING N INTO PPROCN;

      PMSG := PMSG ||J.RN ||' - ' || J.CODE ||CHR(13)|| CHR(10);
      VCNT := VCNT +1 ;
      VCODE := J.CODE;
       END LOOP;

IF  VCNT = 1 THEN
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP, VAL5 , VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4/*ЗАПОМНИЛИ БАР КОД НОМЕНКЛАТУРЫ*/,VNOMN,PKEYCODE,PSTR,VCODE,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОГО НАИМЕНОВАНИЯ',PPROCN,VEXPIRE,VCONTRAGENTN)
   RETURNING N INTO PPROCN;

   RETURN 1;
END IF;

IF  VCNT > 1 THEN
  RETURN 2;
END IF;


END IF; --IF PSTR IS NOT NULL THEN

IF  VCNT = 0 THEN

  IF (PKEYCODE IS NOT NULL) AND NVL(LENGTH(PKEYCODE),0)>2 THEN

      FOR J IN (SELECT/*+ ORDERED*/ N.N AS NOMENKLATURA_N , N.CODE,ROWNUM AS RN,EXPIRE , CONTRAGENT_N
         FROM  NOMENKLATURA N
                    WHERE UPPER(N.CODE) LIKE '%'||UPPER(PKEYCODE)||'%'
                      AND N.TD = KK_COMMON.GETTD
     UNION
     SELECT/*+ ORDERED*/ N.N AS NOMENKLATURA_N , N.CODE,ROWNUM AS RN,EXPIRE , CONTRAGENT_N
         FROM  NOMENKLATURA N
          WHERE  N.N IN (SELECT  N1 FROM TABLE(CAST( KK_ST_BARCODE.GETNOMCURSORBYUSERPROC(VCONTRAGENTN,PKEYCODE,PSTR) AS TCWMS_TABLE))   )
            AND N.TD = KK_COMMON.GETTD

                      ) LOOP

           VNOMN :=  J.NOMENKLATURA_N ;
           VCONTRAGENTN := J.CONTRAGENT_N;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP, VAL5 , VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,27/*ЗАПОМНИЛИ СПИСОК КОДОВ НОМЕНКЛАТУРЫ*/,J.NOMENKLATURA_N,J.RN,PSTR,J.CODE,SYSDATE,KK_COMMON.GETTD,'СПИСОК НОМЕНКЛАТУРЫ',PPROCN,J.EXPIRE, J.CONTRAGENT_N)
   RETURNING N INTO PPROCN;

      PMSG := PMSG ||J.RN ||' - ' || J.CODE ||CHR(13)|| CHR(10);
      VCNT := VCNT +1 ;
      VCODE := J.CODE;
      VEXPIRE := J.EXPIRE;
      VCONTRAGENTN := J.CONTRAGENT_N;

       IF VCNT > 10 THEN
         RAISE_APPLICATION_ERROR(-20000,'<ERR>НАЙДЕНО МНОГО НОМЕНКЛАТУР! УТОЧНИТЕ КОД </ERR>');
       END IF;

       END LOOP;

IF  VCNT = 1 THEN

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP,VAL5 , VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4/*ЗАПОМНИЛИ БАР КОД НОМЕНКЛАТУРЫ*/,VNOMN,PKEYCODE,PSTR,VCODE,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОГО НАИМЕНОВАНИЯ',PPROCN,VEXPIRE, VCONTRAGENTN)
   RETURNING N INTO PPROCN;

   RETURN 1;
END IF;

IF  VCNT > 1 THEN
  RETURN 2;
END IF;

IF  VCNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕРКЛАТУРА ПО ШТРИХКОДУ НЕ ОБНАРУЖЕНА *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>' );
END IF;

  ELSE
   RAISE_APPLICATION_ERROR(-20000,'<ERR>УТОЧНИТЕ КОД ИЛИ СКАНИРУЙТЕ ШТРИХКОД!!!</ERR>');
  END IF; --IF PKEYCODE IS NOT NULL THEN


END IF; --IF  VCNT = 0 THEN



END;

FUNCTION INPUTNOMBARCODE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
 VCNT INTEGER := 0;
 VCODE VARCHAR2(255);
 VEXPIRE INTEGER;
 VCONTRAGENTN INTEGER :=    NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'FILTER.CONTRAGENT_N'  ),0);
 VEMPN  INTEGER :=   KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'  );
 VOPTIONS PRM_CORRS.OPTIONS%TYPE;
 VACCESS  INTEGER;
 VBARCODE   VARCHAR2(50);
 VBARCODE2  VARCHAR2(50);
 VSTR VARCHAR2(1500);
 VNOMNAMELENGTH INTEGER;
 /*ИДЕНТИФИКАЦИЯЯ ПО ПОЛНОМУ ШТРИХКОДУ БЕЗ УЧЕТА МАССКИ*/
 VIDENTIFYBYFULLBARCODE LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('INPUTNOMBARCODE.IDENTIFYBYFULLBARCODE.GRPLIST',SYSDATE,VCONTRAGENTN);
 VSTRICTCODE INTEGER := KK_CONST.GETCONSTV('INPUTNOMBARCODE.STRICTCODE',SYSDATE,VCONTRAGENTN);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
  IF PSTR IS NULL AND PKEYCODE != '0' AND NVL(KK_PERMIT.EXISTSPERMITACCESS(VEMPN, 'STBARCODEMANUALNOMCODEINPUT',SYSDATE), -1) !=3 THEN
    RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ НОМЕНКЛАТУРУ, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
  END IF;

 PMSG := NULL;
 IF PSTR IS NULL AND PKEYCODE IS NULL THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА НЕ СОСКАНИРОВАНА</ERR>');
 END IF;
/*ЙУХ*/

   VACCESS := KK_PERMIT.EXISTSPERMIT(VEMPN,'ACCESSLISTCONTRAGENT',SYSDATE,VOPTIONS);


/*ЗАЧЕМ КОМЕНТИРОВАЛИ???? DVE*/
 IF (PSTR IS NOT NULL) AND KK_BARCODE_MASK.PARCEBARCODE(PROBJN ,PSTR,VSTR) != 0 THEN
  VBARCODE  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.CODE' );
  VBARCODE2 := PSTR;
 ELSE
  VBARCODE :=  TRIM(PSTR);
  VBARCODE2:=  NULL ;
 END IF;

      VNOMNAMELENGTH := 23;         --|--
      BEGIN
          SELECT KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH',SYSDATE,VCONTRAGENTN) INTO VNOMNAMELENGTH FROM DUAL;
      EXCEPTION
        WHEN OTHERS THEN
            VNOMNAMELENGTH := 23;
      END;

      FOR J IN (
         WITH TNOM AS (
             SELECT/*+ ORDERED*/ 1 AS X, N.CODE ||' '|| SUBSTR(N.NAME,1,VNOMNAMELENGTH) AS CODE, B.NOMENKLATURA_N ,N.EXPIRE,B.CONTRAGENT_N,SUBSTR(CC.BRIEF,6) AS BRIEF
                   , N.NAME
                   , B.BAR_CODE
                  FROM NOM_BARCODE B
                   JOIN NOMENKLATURA N ON ( N.N = B.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD )
                    JOIN CONTRAGENT CC ON (CC.N=B.CONTRAGENT_N AND CC.TD = KK_COMMON.GETTD)
                    WHERE UPPER(TRIM(B.BAR_CODE))  = UPPER(TRIM(PSTR)) AND PSTR IS NOT NULL
                         AND B.TD = KK_COMMON.GETTD
                         AND (B.CONTRAGENT_N = VCONTRAGENTN OR VCONTRAGENTN = 0)
                         AND (VOPTIONS LIKE '%,'||B.CONTRAGENT_N||',%' OR NVL(VOPTIONS,'0') = '0')
                        /*ИДЕНТИФИКАЦИЯЯ ПО ПОЛНОМУ ШТРИХКОДУ БЕЗ УЧЕТА МАСКИ*/
                         AND VIDENTIFYBYFULLBARCODE LIKE '%,'||N.GROUP_N||',%'
                 UNION
                 SELECT/*+ ORDERED*/ 2 AS X, N.CODE ||' '|| SUBSTR(N.NAME,1,VNOMNAMELENGTH) AS CODE, B.NOMENKLATURA_N ,N.EXPIRE,B.CONTRAGENT_N,SUBSTR(CC.BRIEF,6) AS BRIEF
                   , N.NAME
                   , B.BAR_CODE
                  FROM NOM_BARCODE B
                   JOIN NOMENKLATURA N ON ( N.N = B.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
                    JOIN CONTRAGENT CC ON (CC.N=B.CONTRAGENT_N AND CC.TD = KK_COMMON.GETTD)
                    WHERE UPPER(TRIM(B.BAR_CODE))  = UPPER(TRIM(VBARCODE)) AND VBARCODE IS NOT NULL
                         AND B.TD = KK_COMMON.GETTD
                         AND (B.CONTRAGENT_N = VCONTRAGENTN OR VCONTRAGENTN = 0)
                         AND (VOPTIONS LIKE '%,'||B.CONTRAGENT_N||',%' OR NVL(VOPTIONS,'0') = '0')
                        /*ИДЕНТИФИКАЦИЯЯ ПО ШТРИХКОДУ ИЗ МАСКИ*/
                         AND VIDENTIFYBYFULLBARCODE NOT LIKE '%,'||N.GROUP_N||',%'

                 UNION
                 SELECT/*+ ORDERED*/ 2 AS X, N.CODE ||' '|| SUBSTR(N.NAME,1,VNOMNAMELENGTH) AS CODE  ,N.N ,N.EXPIRE,N.CONTRAGENT_N,SUBSTR(CC.BRIEF,6) AS BRIEF
                  , N.NAME
                  , N.CODE AS BAR_CODE
                     FROM  NOMENKLATURA N
                     JOIN CONTRAGENT CC ON (CC.N=N.CONTRAGENT_N AND CC.TD = KK_COMMON.GETTD)
                       WHERE 1=1
                         AND UPPER(TRIM(N.CODE))  != UPPER(NVL(TRIM(VBARCODE),' '))
                         AND ((LOWER(N.CODE) LIKE '%'||LOWER(NVL(PKEYCODE,VBARCODE))||'%' AND VSTRICTCODE=0)
                              OR (LOWER(TRIM(N.CODE)) =LOWER(TRIM(NVL(PKEYCODE,VBARCODE))) AND VSTRICTCODE=1)
                             )
                         AND N.TD = KK_COMMON.GETTD
                         AND (N.CONTRAGENT_N = VCONTRAGENTN OR VCONTRAGENTN = 0)
                         AND (VOPTIONS LIKE '%,'||N.CONTRAGENT_N||',%' OR NVL(VOPTIONS,'0') = '0')
         )
         SELECT CODE,NOMENKLATURA_N,EXPIRE,CONTRAGENT_N,BRIEF,BAR_CODE
              FROM (
                SELECT * FROM TNOM
                 UNION
                   SELECT/*+ ORDERED*/ 2 AS X, N.CODE ||' '|| SUBSTR(N.NAME,1,VNOMNAMELENGTH) AS CODE  ,N.N ,N.EXPIRE,N.CONTRAGENT_N,SUBSTR(CC.BRIEF,6) AS BRIEF
                  , N.NAME
                  , N.CODE AS BAR_CODE
                     FROM  NOMENKLATURA N
                     JOIN CONTRAGENT CC ON (CC.N=N.CONTRAGENT_N AND CC.TD = KK_COMMON.GETTD)
                        WHERE  N.N IN (SELECT  N1 FROM TABLE(CAST( KK_ST_BARCODE.GETNOMCURSORBYUSERPROC(VCONTRAGENTN,PKEYCODE,PSTR) AS TCWMS_TABLE))   )
                         AND N.TD = KK_COMMON.GETTD
                         AND (N.CONTRAGENT_N = VCONTRAGENTN OR VCONTRAGENTN = 0)
                         AND (VOPTIONS LIKE '%,'||N.CONTRAGENT_N||',%' OR NVL(VOPTIONS,'0') = '0')
                         AND NOT EXISTS (SELECT * FROM TNOM WHERE NOMENKLATURA_N = N.N)
                  )
                         ORDER BY  CASE WHEN CONTRAGENT_N = VCONTRAGENTN THEN 0 ELSE 1 END ,X , NAME
                         ) LOOP

           VNOMN :=  J.NOMENKLATURA_N ;
           VEXPIRE := J.EXPIRE;
           VCONTRAGENTN := J.CONTRAGENT_N;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5 , VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,27/*ЗАПОМНИЛИ СПИСОК КОДОВ НОМЕНКЛАТУРЫ*/,J.NOMENKLATURA_N,VCNT+1,VBARCODE,J.CODE,SYSDATE,KK_COMMON.GETTD,J.BAR_CODE,PPROCN,J.EXPIRE, J.CONTRAGENT_N)
   RETURNING N INTO PPROCN;


      PMSG := PMSG ||TO_CHAR(VCNT+1) ||'- ' || J.CODE ||CHR(13)|| CHR(10);
      VCNT := VCNT +1 ;
      VCODE := J.CODE;

      EXIT WHEN VCNT = 50;

       END LOOP;

IF  VCNT = 1 THEN

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP, VAL5 , VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4/*ЗАПОМНИЛИ БАР КОД НОМЕНКЛАТУРЫ*/,VNOMN,PKEYCODE,VBARCODE,VCODE,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОГО НАИМЕНОВАНИЯ',PPROCN,VEXPIRE , VCONTRAGENTN)
   RETURNING N INTO PPROCN;

   RETURN 1;
END IF;

IF  VCNT > 1 THEN
 PMSG := 'ВЫБЕРИТЕ ИЗ ПЕРЕЧИСЛЕНОГО *'||VBARCODE ||'*'||V1310 || PMSG;
  RETURN 2;
END IF;

IF  VCNT = 0 THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕРКЛАТУРА ПО ШТРИХКОДУ НЕ ОБНАРУЖЕНА *' ||  VBARCODE  ||  '* ' || PKEYCODE ||'; VCONTRAGENTN='||VCONTRAGENTN||'</ERR>');
END IF;


END INPUTNOMBARCODE;


FUNCTION  INPUTCONTRAGENTN(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER;
BEGIN

SELECT N,BRIEF INTO VCONTRAGENTN,PMSG
 FROM CONTRAGENT
  WHERE N = PKEYCODE
   AND SYSDATE BETWEEN FD AND TD;


  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);



INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,15/*ЗАПОМНИЛИ КОД КОНТРАГЕНТА*/,VCONTRAGENTN,PKEYCODE,NULL,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ CONTRAGENT',0)
   RETURNING N INTO PPROCN;



RETURN 1;

EXCEPTION
    WHEN OTHERS THEN
        PMSG :=  'CONTRAGENT НЕ ОБНАРУЖЕН *' ||  PSTR  ||  '* *' || PKEYCODE||  '* ' ||SQLERRM;
    RETURN -1;
END;

FUNCTION INPUTBARCODENOMCODE (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VNOMN INTEGER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VBARCODE NOM_BARCODE.BAR_CODE%TYPE;
VNOMCODE NOMENKLATURA.CODE%TYPE;
VUNIT_TYP NOM_UNIT.UNIT_TYP%TYPE;
VSTR VARCHAR2(255);
VCOUNT INTEGER;
 /*ИДЕНТИФИКАЦИЯЯ ПО ПОЛНОМУ ШТРИХКОДУ БЕЗ УЧЕТА МАССКИ*/
 VIDENTIFYBYFULLBARCODE LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('INPUTNOMBARCODE.IDENTIFYBYFULLBARCODE.GRPLIST',SYSDATE,VCONTRAGENTN);
VGROUPN INTEGER;
BEGIN

 IF PSTR IS NULL THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА НЕ СОСКАНИРОВАНА</ERR>');
 END IF;

BEGIN
SELECT N, CODE , N.GROUP_N INTO VNOMN , VNOMCODE , VGROUPN
 FROM NOMENKLATURA N
  WHERE N= VNOMN
  AND CONTRAGENT_N = VCONTRAGENTN
  AND SYSDATE BETWEEN FD AND TD;

EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ОШИБКА ОПРЕДЕЛЕНИЯ НОМЕНКЛАТУРЫ ПО НОМЕРУ VNOMN='||VNOMN ||' VCONTRAGENTN='||VCONTRAGENTN||'</ERR>');

END;

 IF
   VIDENTIFYBYFULLBARCODE NOT LIKE '%,'||VGROUPN||',%'
  AND KK_BARCODE_MASK.PARCEBARCODE(PROBJN ,PSTR,VSTR) != 0 THEN
  VBARCODE := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.CODE' );
 ELSE
  VBARCODE :=  TRIM(PSTR);
 END IF;

BEGIN

SELECT STRAGG(N.CODE||' '||N.NAME)  , COUNT(1)
     INTO PMSG, VCOUNT
    FROM NOM_BARCODE B
       JOIN NOMENKLATURA N ON (N.N = B.NOMENKLATURA_N AND SYSDATE BETWEEN N.FD AND N.TD)
 WHERE B.CONTRAGENT_N =  VCONTRAGENTN
 AND SYSDATE BETWEEN B.FD AND B.TD
 AND LOWER(B.BAR_CODE) = LOWER(VBARCODE);


IF VCOUNT > 0 THEN

 RAISE_APPLICATION_ERROR(-20000,'<ERR>ШТРИХКОД УЖЕ ЕСТЬ! "'|| VBARCODE||'"</ERR>');

END IF;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,16,0,NULL,PKEYCODE,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ CONTRAGENT',PPROCN)
   RETURNING N INTO PPROCN;

IF  NOT (PKEYCODE IS NULL) THEN
  VUNIT_TYP:= TO_NUMBER(PKEYCODE);
END IF;

BEGIN
  IF NOT (PKEYCODE IS NULL) THEN

    SELECT U.UNIT_TYP INTO VUNIT_TYP
    FROM NOM_UNIT U
    WHERE U.NOMENKLATURA_N=VNOMN
       AND U.UNIT_TYP=VUNIT_TYP
       AND SYSDATE BETWEEN U.FD AND U.TD;
  END IF;
EXCEPTION
    WHEN NO_DATA_FOUND
       THEN RAISE_APPLICATION_ERROR(-20001,'НЕВЕРНО УКАЗАНА ЕДИНИЦА КОНВЕРТАЦИИ ('||PKEYCODE||'), У НОМЕНКЛАТУРЫ НЕТ ТАКОЙ ЕДИНИЦЫ КОНВЕРТАЦИИ!');
END;
BEGIN

  INSERT INTO NOM_BARCODE (N,FD,TD,CONTRAGENT_N,NOMENKLATURA_N,BAR_CODE,UNIT_TYP) VALUES
  (SQ_NOM_BARCODE.NEXTVAL,SYSDATE,KK_COMMON.GETTD,VCONTRAGENTN,VNOMN,UPPER(VBARCODE),VUNIT_TYP);

  PMSG := 'ЗАРЕГИСТРИРОВАНО! '||VNOMCODE||' - ' || VBARCODE;

 PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',0);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    PMSG := 'NOMENKLATURA NOT FOUND!';

END;

END; -- BEGIN


RETURN 1;

END INPUTBARCODENOMCODE;


FUNCTION STOCKNBYNOMUNITS(PNOMENKLATURAN INTEGER,PCNT INTEGER) RETURN VARCHAR2 IS
VRET VARCHAR2(2500);
VUNITNAME VARCHAR2(100);
VLEFTCNT INTEGER := PCNT;
VCNT INTEGER;
BEGIN


FOR REC IN(
    SELECT/*+ ORDERED INDEX_DESC(D ST_DOC_OUT_DET_DOC_N_FD_TD) USE_HASH(S)  INDEX_DESC(S ST_STOCK_DOC_N_FD_TD_TYP) */
     NU.UNIT_CNT
     ,NU.UNIT_TYP
     ,DD_UNIT.TERM AS UNIT_TERM
      FROM
            NOM_UNIT NU
           JOIN DIC_DATA DD_UNIT ON ( DD_UNIT.UP = 362 AND SYSDATE BETWEEN DD_UNIT.FD AND DD_UNIT.TD AND DD_UNIT.CODE = NU.UNIT_TYP)
 WHERE 1=1
 AND NU.NOMENKLATURA_N = PNOMENKLATURAN  AND  SYSDATE BETWEEN NU.FD AND NU.TD
 ORDER BY UNIT_CNT DESC)
 LOOP
   IF VLEFTCNT >= REC.UNIT_CNT THEN
     VCNT := TRUNC(VLEFTCNT/REC.UNIT_CNT);
     VRET := VRET||VCNT||' '||LOWER(REC.UNIT_TERM)||'(ПО'||REC.UNIT_CNT||')'||'; ';
     VLEFTCNT := VLEFTCNT - VCNT*REC.UNIT_CNT;

   END IF;
   EXIT WHEN VLEFTCNT = 0;
 END LOOP;

IF PNOMENKLATURAN IS NOT NULL THEN
  SELECT DD_UNIT.TERM INTO VUNITNAME
  FROM NOMENKLATURA N
  JOIN NOM_UNIT NU ON (N.N=NU.NOMENKLATURA_N AND NU.TD=KK_COMMON.GETTD AND N.UNIT=NU.UNIT_TYP)
  JOIN DIC_DATA DD_UNIT ON ( DD_UNIT.UP = 362 AND DD_UNIT.TD = KK_COMMON.GETTD AND DD_UNIT.CODE = NU.UNIT_TYP)
  WHERE N.N = PNOMENKLATURAN
  AND N.TD=KK_COMMON.GETTD;
ELSE
  VUNITNAME := 'У.Е.';
END IF;

RETURN VRET || ' ВСЕГО:'||PCNT||VUNITNAME;


EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
      RETURN 'ОШИБКА КОНВЕРТАЦИЙ ЕД.УЧЕТА';

END;
/*ЧТО В ЯЧЕЙКЕ*/
FUNCTION WHATONCELLADDRESS (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2, PNEXTNODE IN OUT INTEGER, PPROCN IN OUT INTEGER, PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCODE INTEGER;
VN VARCHAR2(32767);
VADDR VARCHAR2(32767);
VLEFT NUMBER;
VCONST VARCHAR2(50);
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VACCESSLISTSTORE VARCHAR2 (50);
VNOMNAMELEN INTEGER := KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH',SYSDATE);
VSHOWPART INTEGER := KK_CONST.GETCONSTN('WHATONCELL.SHOWPART',SYSDATE);
VCNT INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
PMSG := NULL;

VACCESSLISTSTORE := KK_PERMIT.EXISTSPERMIT(VEMPN, 'ACCESSLISTSTORE', SYSDATE);

BEGIN


    SELECT TO_NUMBER(DECODE(INSTR(NVL(PSTR,PKEYCODE),'C-')
                   ,1,NVL(          SUBSTR(NVL(PSTR,PKEYCODE),3),PKEYCODE)
                     ,NVL(          PSTR,PKEYCODE   )
                            )
          ) INTO VCODE FROM DUAL;

EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
       VCODE := 0;
       VADDR :=  NVL(PKEYCODE,PSTR);
END;

BEGIN
  BEGIN
    SELECT ADDR, N , ROUND(KK_ST_ALLOC.GETLEFTOFADDRESS(N,SIZE_,0,PALL_TYP,STORE_N,0),3) INTO VADDR, VCODE , VLEFT
      FROM CELL_ADDRESS A
      WHERE (N = VCODE OR VCODE = 0)
        AND (LOWER(A.ADDR) = LOWER(VADDR) OR VADDR IS NULL OR A.ADDR = TO_CHAR(VCODE) AND VCODE !=0)
        AND (VACCESSLISTSTORE = '0' OR VACCESSLISTSTORE LIKE '%,'||TO_CHAR(A.STORE_N)||',%')
        AND SYSDATE BETWEEN A.FD AND A.TD;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      SELECT STRAGG(ADDR) AS ADDR, STRAGG(N) AS N , SUM(ROUND(KK_ST_ALLOC.GETLEFTOFADDRESS(N,SIZE_,0,PALL_TYP,STORE_N,0),3)) AS LEFT, COUNT(*) AS CNT INTO VADDR, VN , VLEFT, VCNT
        FROM CELL_ADDRESS A
        WHERE (LOWER(A.ADDR) LIKE '%'|| LOWER(NVL(VADDR, VCODE)))
          AND (VACCESSLISTSTORE = '0' OR VACCESSLISTSTORE LIKE '%,'||TO_CHAR(A.STORE_N)||',%')
          AND SYSDATE BETWEEN A.FD AND A.TD
        HAVING COUNT(*) >= 1;
      IF VCNT > 1 THEN
        RAISE_APPLICATION_ERROR(-20000,'<ERR>ANOU IANEIEUEI IIAIAIUO Y?AAE:'||VADDR||', N EIAAIE:'||VN||'. OOI?IEOA, II?AEOENOA.</ERR>');
      END IF;
      VCODE := VN;
  END;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА С НОМЕРОМ '||VCODE||' НЕ НАЙДЕНА! VADDR='||VADDR||'</ERR>');
END;

FOR J IN (
SELECT COUNT(1) AS  PALL_CNT
FROM (
    SELECT/*+ ORDERED*/
    ST.ST_PALL_N AS PID
    FROM
    /*СЧИТАЕМ СКОЛЬКО ПАЛЕТ В ЯЧЕЙКЕ KK_ST_BARCODE.WHATONCELLADDRESS*/
    ST_STOCK ST
    WHERE ST.CELL_ADDRESS_N = VCODE
    AND ST.ST_PALL_N > 0
    AND SYSDATE BETWEEN ST.FD AND ST.TD
    GROUP BY ST.ST_PALL_N
UNION ALL
      SELECT/*+ ORDERED*/
     D.PALL_N AS PID
    FROM ST_DOC_IN I
    JOIN ST_DOC_IN_DET D ON (
                                     SYSDATE BETWEEN D.FD AND D.TD
                                 AND D.PALL_N > 0
                                 AND D.SQ_ST_DOC_IN_N = I.N
                                 AND D.TYP = 1
                             )
    JOIN  ST_DOC_IN_DET_ADDR A ON (
                                  A.CELL_ADDRESS_N = VCODE
                                  AND A.ST_DOC_IN_DET_N = D.N
                                   AND SYSDATE BETWEEN A.FD AND A.TD)
    WHERE 1=1
         AND I.STATUS NOT IN (4)
         AND SYSDATE BETWEEN I.FD AND I.TD
         AND NOT EXISTS (SELECT NULL FROM ST_STOCK SST
          WHERE SST.ST_DOC_N = A.N /*AND SYSDATE BETWEEN SST.FD AND SST.TD ЭТО ОШИБКА !!!*/)
   )
) LOOP

PMSG := PMSG ||V1310|| J.PALL_CNT || ' ПАЛЕТ ' || CHR(13) || CHR(10) ;


END LOOP;

FOR J IN (SELECT/*+ ORDERED*/
ST.NOMENKLATURA_N
,N.CODE ||' '||SUBSTR(N.NAME,1,TO_NUMBER(VNOMNAMELEN)) AS NAME_X
,SUM(ST.CNT) AS CNT_X
,DD.TERM,ST.EXPIRE_DATE
,STAT.TERM AS STAT_TERM
,ST.ST_PALL_N
,DECODE(VSHOWPART,0,NULL,SUBSTR(STRAGG(P.PART_NUM),1,50)) AS PART_NUM
,SUM(KK_ST_DOC.GETSTOCKWEIGHTBYINPALLWEIGHT(ST.N,0)) AS IN_WEIGHT
,ST.PALL_TYPE
,UN.TERM AS NOM_UNIT
,ST.CONTRAGENT_N
,C.BRIEF
FROM
/*ЧТО ЛЕЖИТ В ЯЧЕЙКЕ KK_ST_BARCODE.WHATONCELLADDRESS*/
ST_STOCK ST
 LEFT OUTER JOIN ST_PART P ON (P.N = ST.ST_PART_N AND  SYSDATE BETWEEN P.FD AND P.TD)
 JOIN NOMENKLATURA N ON (ST.NOMENKLATURA_N = N.N AND ST.FD BETWEEN N.FD AND N.TD)
 JOIN DIC_DATA DD ON (DD.UP =422 AND SYSDATE BETWEEN DD.FD AND DD.TD AND DD.CODE = ST.NOM_TYP)
 JOIN DIC_DATA STAT ON (STAT.UP =416 AND SYSDATE BETWEEN STAT.FD AND STAT.TD AND STAT.CODE = ST.TYP)
 JOIN CONTRAGENT C ON (C.N=ST.CONTRAGENT_N AND C.TD=KK_COMMON.GETTD)
 LEFT OUTER JOIN DIC_DATA UN ON (UN.UP = 362 AND N.UNIT= UN.CODE AND SYSDATE BETWEEN UN.FD AND UN.TD)
WHERE ST.CELL_ADDRESS_N = VCODE
AND SYSDATE BETWEEN ST.FD AND ST.TD
AND NOT EXISTS (SELECT NULL FROM ST_BAR_JOBS J
   WHERE J.ST_STOCK_N = ST.N
   AND SYSDATE BETWEEN J.FD AND J.TD
   AND J.TYP = 3
   AND J.STATUS IN (1,2) )
GROUP BY ST.NOMENKLATURA_N,N.CODE,N.NAME ,DD.TERM,ST.ST_PALL_N,ST.EXPIRE_DATE,STAT.TERM ,ST.PALL_TYPE,UN.TERM,ST.CONTRAGENT_N,C.BRIEF
ORDER BY N.CODE,CNT_X
) LOOP

VCONST := KK_CONST.GETCONSTV('STOCKCNTCONVERTTOUNITDSC',SYSDATE);

SELECT SUBSTR(PMSG ||V1310
         || J.NAME_X ||' '||
         ROUND( J.CNT_X / KK_ST_DOC_NEW.GETNOMBLCKBYPALLTYP(J.NOMENKLATURA_N,J.PALL_TYPE,0),2)
         || ' ПАЛЛЕТ ' || V1310 || DECODE(VCONST,1,KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(J.NOMENKLATURA_N,J.CNT_X ),0,J.CNT_X||' ' ||J.NOM_UNIT) ||V1310
         ||DECODE(J.EXPIRE_DATE,KK_COMMON.GETTD,NULL,TO_CHAR(J.EXPIRE_DATE,'DD-MM-YYYY')||' '  )
         ||J.TERM ||' '  ||J.STAT_TERM ||V1310
         ||DECODE(J.ST_PALL_N,NULL,NULL,0,NULL,'P-'||J.ST_PALL_N ||V1310)
         ||DECODE(J.PART_NUM,NULL,NULL,'ПАРТИЯ:'||J.PART_NUM ||V1310)
         ||DECODE(J.IN_WEIGHT,NULL,NULL,'ВЕС:'||J.IN_WEIGHT ||V1310)
         ||DECODE(J.CONTRAGENT_N,NULL,NULL,'КА:'||J.CONTRAGENT_N||'-'||J.BRIEF||V1310)
         ,1,3800) INTO PMSG
          FROM DUAL;

EXIT WHEN LENGTH(PMSG) >=3800;

END LOOP;

FOR J IN (

SELECT
   N.CODE ||' '||SUBSTR(N.NAME,1,TO_NUMBER(VNOMNAMELEN)) AS NAME_X
  ,A.ADDR
  ,SUM(D.CNT) AS CNT_X
  ,KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(ST.NOMENKLATURA_N,SUM(D.CNT) ) AS DSC
  FROM ST_BAR_JOBS ST
   JOIN NOMENKLATURA N ON (ST.NOMENKLATURA_N = N.N AND ST.FD BETWEEN N.FD AND N.TD)
   JOIN ST_DOC_MOVE_DET D ON (D.N = ST.ST_DOC_N AND SYSDATE BETWEEN D.FD AND D.TD)
   JOIN CELL_ADDRESS A ON (A.N = D.CELL_ADDRESS_NEW_N AND SYSDATE BETWEEN A.FD AND A.TD)
 WHERE ST.TYP = 3
 AND SYSDATE BETWEEN ST.FD AND ST.TD
 AND ST.CELL_ADDRESS_N = VCODE
 AND ST.STATUS = 1
GROUP BY    N.CODE ||' '||SUBSTR(N.NAME,1,TO_NUMBER(VNOMNAMELEN))
  ,A.ADDR
  ,ST.NOMENKLATURA_N
) LOOP

SELECT SUBSTR(PMSG ||V1310
         || 'ПЕРЕМЕЩЕНИЕ ==>'|| J.ADDR ||V1310
         || J.NAME_X ||V1310
         || J.DSC
         ,1,3800) INTO PMSG
          FROM DUAL;

EXIT WHEN LENGTH(PMSG) >=3800;

END LOOP;


SELECT KK_CONST.GETCONSTV('WHATONCELLADDRESS.VIEWSTDOCINADDR',SYSDATE) INTO VCONST FROM DUAL;

FOR J IN (SELECT/*+ ORDERED*/
    D.NOMENKLATURA_N
    ,N.CODE ||' '||SUBSTR(N.NAME,1,TO_NUMBER(VNOMNAMELEN)) AS NAME_X
    ,SUM(DECODE(D.CNT_IN,0,D.CNT_BRAK,NULL,D.CNT_BRAK,D.CNT_IN)) AS CNT_X
    ,DECODE(SUM(D.CNT_IN),0,'БРАК!!!',NULL) AS KOND_TYPE
    ,DD.TERM,D.EXPIRE_DATE
    ,STAT.TERM AS STAT_TERM
    ,D.PALL_N
    ,DECODE(VSHOWPART,0,NULL,SUBSTR(STRAGG(P.PART_NUM),1,50)) AS PART_NUM
    ,D.PALL_TYPE
FROM ST_DOC_IN_DET_ADDR A
    JOIN ST_DOC_IN_DET D ON (A.ST_DOC_IN_DET_N = D.N AND SYSDATE BETWEEN D.FD AND D.TD AND D.PALL_N > 0)
    LEFT OUTER JOIN ST_PART P ON (P.N = D.ST_PART_N AND  SYSDATE BETWEEN P.FD AND P.TD)
    JOIN ST_DOC_IN I ON (D.SQ_ST_DOC_IN_N = I.N AND I.STATUS NOT IN 4 AND SYSDATE BETWEEN I.FD AND I.TD)
    JOIN NOMENKLATURA N ON (D.NOMENKLATURA_N = N.N AND D.FD BETWEEN N.FD AND N.TD)
    JOIN DIC_DATA DD ON (DD.UP =422 AND SYSDATE BETWEEN DD.FD AND DD.TD AND DD.CODE = D.NOM_TYP)
    JOIN DIC_DATA STAT ON (STAT.UP =416 AND SYSDATE BETWEEN STAT.FD AND STAT.TD AND STAT.CODE = 1 /* ПРИХОДОВАНИЕ */)
WHERE A.CELL_ADDRESS_N = VCODE
    AND A.TD=KK_COMMON.GETTD
    AND NVL(VCONST,0) = 1
    AND NOT EXISTS (SELECT NULL FROM ST_STOCK SST
              WHERE SST.ST_DOC_N = A.N /*AND SYSDATE BETWEEN SST.FD AND SST.TD ЭТО ОШИБКА !!!*/)
    AND NOT EXISTS (SELECT NULL FROM ST_BAR_JOBS J
       WHERE J.ST_DOC_N = A.N
       AND SYSDATE BETWEEN J.FD AND J.TD
       AND J.TYP = 11
       AND J.STATUS IN (1,2) )
GROUP BY D.NOMENKLATURA_N,N.CODE,N.NAME ,DD.TERM,D.PALL_N,D.EXPIRE_DATE,STAT.TERM  ,D.PALL_TYPE
ORDER BY N.CODE,CNT_X
) LOOP

SELECT SUBSTR(PMSG ||V1310
         || J.NAME_X ||' '||ROUND( J.CNT_X / KK_ST_DOC_NEW.GETNOMBLCKBYPALLTYP(J.NOMENKLATURA_N,J.PALL_TYPE,0),2)
         || ' ПАЛЛЕТ ' || V1310 || KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(J.NOMENKLATURA_N,J.CNT_X ) ||V1310
         ||J.KOND_TYPE||V1310
         ||DECODE(J.EXPIRE_DATE,KK_COMMON.GETTD,NULL,TO_CHAR(J.EXPIRE_DATE,'DD-MM-YYYY')||' '  )
         ||' '  ||J.TERM
         ||' '  ||J.STAT_TERM ||V1310
         ||DECODE(J.PALL_N,NULL,NULL,0,NULL,'P-'||J.PALL_N ||V1310)
         ||DECODE(J.PART_NUM,NULL,NULL,'ПАРТИЯ:'||J.PART_NUM||V1310)
         ||' <<<<<!!!ПРИХОДУЕТСЯ!!!>>>>',1,3800) INTO PMSG FROM DUAL;
EXIT WHEN LENGTH(PMSG) >=3800;

END LOOP;
------------------------------------------------------------------


IF PMSG IS NULL THEN
PMSG := 'ПУСТО';
ELSE
PMSG := VADDR ||V1310||'СВОБОДНО: '||RTRIM(TO_CHAR(VLEFT, 'FM99999999990D9999999999'), '.,')||V1310||PMSG;
END IF;


  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , VAL4, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,32/*ЧТО В ЯЧЕЙКЕ*/,VCODE,NULL,VADDR,SYSDATE,KK_COMMON.GETTD,SUBSTR(PMSG,1,3800),0)
   RETURNING N INTO PPROCN;

RETURN 1;

--EXCEPTION
--  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
--   RAISE;

END WHATONCELLADDRESS;

/*ЧТО НА ПАЛЛЕТЕ*/
FUNCTION WHATONPALL (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
VSHOWPART INTEGER := KK_CONST.GETCONSTN('WHATONCELL.SHOWPART',SYSDATE);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
VWEIGHT VARCHAR2(50);
BEGIN

SELECT CASE WHEN INSTR(NVL(PSTR,'P-'||PKEYCODE),'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(NVL(PSTR,PKEYCODE),'P-','') ) INTO  VPALLN FROM DUAL;

PMSG := NULL;

-- ПОИСК ПАЛЛЕТА В СТОКЕ
FOR J IN (
SELECT/*+ ORDERD INDEX_DESC(S ST_STOCK_PALL_TD_FD_TYP)*/
N.CODE,N.NAME
,DECODE(VSHOWPART,0,NULL,SUBSTR(STRAGG(P.PART_NUM),1,50)) AS PART_NUM
,C.BRIEF
,A.ADDR
,SUM(S.CNT) AS CNT
,DD_NOM_UNIT.TERM AS  UNIT_TERM
, DD.TERM AS TYP_TERM
, S.EXPIRE_DATE
, S.EXPIRE_DATE - NVL(N.EXPIRE,0 ) AS EXPIRE_FROM
,S.NOMENKLATURA_N
,SUM(KK_ST_DOC.GETSTOCKWEIGHTBYINPALLWEIGHT(S.N,0)) AS IN_WEIGHT
,CC.NAME AS CC_NAME
,O.DOC
,O.N
,SUBSTR(O.DESTINATION,0,120) DESTINATION
FROM
/*ЗАПРОС ИЗ ШТРИХ КОДИРОВАНИЯ ПОКАЗЫВАЕТ ЧТО СОДЕРЖИТ ПАЛЛЕТА ГДЕ НАХОДИТСЯ*/
 ST_STOCK S
 LEFT OUTER JOIN ST_PART P ON (   S.ST_PART_N = P.N AND SYSDATE BETWEEN P.FD AND P.TD)
 JOIN DIC_DATA DD ON (DD.UP =416  AND DD.CODE =  S.TYP AND S.FD BETWEEN DD.FD AND DD.TD)
 JOIN NOMENKLATURA N ON (  N.N = S.NOMENKLATURA_N  AND S.FD BETWEEN N.FD AND N.TD)
 JOIN CONTRAGENT C ON (  C.N = S.CONTRAGENT_N AND S.FD BETWEEN C.FD AND C.TD)
 JOIN CELL_ADDRESS A ON (  A.N = S.CELL_ADDRESS_N  AND S.FD  BETWEEN A.FD AND A.TD)
 JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND S.FD BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
 LEFT JOIN ST_DOC_OUT_DET DT ON (S.ST_DOC_N = DT.N AND DT.TD = KK_COMMON.GETTD)
 LEFT JOIN ST_DOC_OUT O ON (DT.SQ_ST_DOC_OUT_N = O.N AND O.TD = KK_COMMON.GETTD)
 LEFT JOIN C_CONTRAGENT CC ON (O.CCONTRAGENT_N = CC.N AND C.TD = KK_COMMON.GETTD)
 WHERE 1=1
  AND SYSDATE BETWEEN S.FD AND  S.TD
  AND S.ST_PALL_N = VPALLN
GROUP BY N.CODE,N.NAME
,C.BRIEF
,A.ADDR
,DD_NOM_UNIT.TERM
, DD.TERM
, S.EXPIRE_DATE
, S.EXPIRE_DATE - NVL(N.EXPIRE,0 )
,S.NOMENKLATURA_N
,CC.NAME
,O.DOC
,O.N
,SUBSTR(O.DESTINATION,0,120)

UNION ALL

SELECT/*+ ORDERD INDEX_DESC(S ST_STOCK_PALL_TD_FD_TYP)*/
N.CODE,N.NAME
,DECODE(VSHOWPART,0,NULL,SUBSTR(STRAGG(P.PART_NUM),1,50)) AS PART_NUM
,C.BRIEF
,'НЕ В СТОКЕ'
,SUM(S.CNT_IN + S.CNT_BRAK) AS CNT
,DD_NOM_UNIT.TERM AS  UNIT_TERM
, DD.TERM AS TYP_TERM
, S.EXPIRE_DATE
, S.EXPIRE_DATE - NVL(N.EXPIRE,0 ) AS EXPIRE_FROM
,S.NOMENKLATURA_N
,SUM(KK_ST_DOC.GETSTOCKWEIGHTBYINPALLWEIGHT(S.N,0)) AS IN_WEIGHT
,NULL AS CC_NAME
,NULL AS DOC
,NULL AS N
,NULL AS DESTINATION
FROM
/*?????? ?? ????? ??????????? ?????????? ??? ???????? ??????? ??? ?????????*/
 ST_DOC_IN_DET S
  JOIN ST_DOC_IN D ON (D.N = S.SQ_ST_DOC_IN_N AND SYSDATE BETWEEN D.FD AND D.TD AND D.STATUS != 4 )
 LEFT OUTER JOIN ST_PART P ON (   S.ST_PART_N = P.N AND SYSDATE BETWEEN P.FD AND P.TD)

 JOIN DIC_DATA DD ON (DD.UP =416  AND DD.CODE =  S.TYP AND S.FD BETWEEN DD.FD AND DD.TD)
 JOIN NOMENKLATURA N ON (  N.N = S.NOMENKLATURA_N  AND S.FD BETWEEN N.FD AND N.TD)
 JOIN CONTRAGENT C ON (  C.N = D.CONTRAGENT_N AND S.FD BETWEEN C.FD AND C.TD)
 --JOIN CELL_ADDRESS A ON (  A.N = S.CELL_ADDRESS_N  AND S.FD  BETWEEN A.FD AND A.TD)
 JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND S.FD BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
 WHERE 1=1
  AND SYSDATE BETWEEN S.FD AND  S.TD
  AND S.PALL_N = VPALLN
  AND NOT EXISTS
  (SELECT NULL
    FROM ST_DOC_IN_DET_ADDR A
    JOIN ST_STOCK ST ON (A.N = ST.ST_DOC_N AND ST.TYP = 1 AND ST.UP = 0 AND ST.ST_PALL_N = VPALLN)
    WHERE A.ST_DOC_IN_DET_N = S.N
      AND A.TD = KK_COMMON.GETTD
  )
GROUP BY N.CODE,N.NAME
,C.BRIEF
--,A.ADDR
,DD_NOM_UNIT.TERM
, DD.TERM
, S.EXPIRE_DATE
, S.EXPIRE_DATE - NVL(N.EXPIRE,0 )
,S.NOMENKLATURA_N
  ) LOOP

PMSG := SUBSTR(PMSG ||CHR(13)||'КОНТРАГЕНТ: '||J.BRIEF ||V1310 ||
        J.CODE ||' '|| J.NAME ||V1310||
        J.CNT ||' '||J.UNIT_TERM||' '|| J.TYP_TERM||V1310||
         STOCKNBYNOMUNITS(J.NOMENKLATURA_N,J.CNT)||V1310||
        'НА АДРЕСЕ: '|| J.ADDR ||V1310||
        CASE WHEN J.PART_NUM IS NULL THEN NULL ELSE 'ПАРТИЯ:' ||J.PART_NUM||V1310 END  ||
        'СРОК: '     || TO_CHAR(J.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
        'ИГОТОВЛ: '  || TO_CHAR(J.EXPIRE_FROM,'DD.MM.YYYY') || V1310 ||
        'ВЕС:' || J.IN_WEIGHT || V1310
          ,1,3800);
IF J.DOC IS NOT NULL THEN


    SELECT ' ВЕС ЗАКАЗА: '||SUM(D.CNT*U.WEIGHT/1000) INTO VWEIGHT
     FROM ST_DOC_OUT_DET D
     JOIN NOMENKLATURA N ON (D.NOMENKLATURA_N=N.N AND N.TD = KK_COMMON.GETTD)
     JOIN NOM_UNIT U ON (N.N=U.NOMENKLATURA_N AND N.UNIT=U.UNIT_TYP AND U.TD = KK_COMMON.GETTD)
     WHERE SQ_ST_DOC_OUT_N = J.N
   AND D.TD = KK_COMMON.GETTD;

  PMSG :=SUBSTR(PMSG ||CHR(13)||'ЗАКАЗ: '||J.DOC ||V1310 ||
        'ПОЛУЧ: '|| J.CC_NAME ||V1310||
        'АДРЕС: '|| J.DESTINATION||V1310||
         VWEIGHT|| ' Т.'
          ,1,3800);
END IF;

END LOOP;

IF PMSG IS NULL THEN
--ПОИСК ПАЛЛЕТА В НЕОПРИХОДОВАННЫХ ПРИХОДАХ
FOR J IN (
SELECT
N.CODE,N.NAME
,DECODE(VSHOWPART,0,NULL,SUBSTR(STRAGG(P.PART_NUM),1,50)) AS PART_NUM
,C.BRIEF
,A.ADDR
,SUM(DECODE(D.CNT_IN,0,D.CNT_BRAK,NULL,D.CNT_BRAK,D.CNT_IN)) AS CNT
,DECODE(D.CNT_IN,0,'БРАК!!!',NULL) AS KOND_TYPE
,DD_NOM_UNIT.TERM AS  UNIT_TERM
, DD.TERM AS TYP_TERM
, D.EXPIRE_DATE, D.EXPIRE_DATE - NVL(N.EXPIRE,0 ) AS EXPIRE_FROM
,D.NOMENKLATURA_N, I.NUM_ACT, I.NUM_INVOICE
FROM
/*ЗАПРОС ИЗ ШТРИХ КОДИРОВАНИЯ ПОКАЗЫВАЕТ ЧТО СОДЕРЖИТ ПАЛЛЕТА ГДЕ НАХОДИТСЯ НА ЭТАПЕ РАССТАНОВКИ*/
 ST_DOC_IN_DET D
 LEFT OUTER JOIN ST_PART P ON (   D.ST_PART_N = P.N AND SYSDATE BETWEEN P.FD AND P.TD)
 JOIN ST_DOC_IN I ON (D.SQ_ST_DOC_IN_N = I.N AND I.STATUS NOT IN 4)
 JOIN ST_DOC_IN_DET_ADDR DA ON (DA.ST_DOC_IN_DET_N = D.N AND SYSDATE BETWEEN DA.FD AND DA.TD)
 JOIN DIC_DATA DD ON (DD.UP =416  AND DD.CODE =  1 AND D.FD BETWEEN DD.FD AND DD.TD)
 JOIN NOMENKLATURA N ON (  N.N = D.NOMENKLATURA_N  AND D.FD BETWEEN N.FD AND N.TD)
 JOIN CONTRAGENT C ON (  C.N = I.CONTRAGENT_N AND D.FD BETWEEN C.FD AND C.TD)
 JOIN CELL_ADDRESS A ON (  A.N = DA.CELL_ADDRESS_N  AND DA.FD  BETWEEN A.FD AND A.TD)
 JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND D.FD BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
 WHERE 1=1
  AND SYSDATE BETWEEN D.FD AND  D.TD
  AND D.PALL_N = VPALLN
 GROUP BY
 N.CODE,N.NAME
,C.BRIEF
,A.ADDR
,DECODE(D.CNT_IN,0,'БРАК!!!',NULL)
,DD_NOM_UNIT.TERM
, DD.TERM
, D.EXPIRE_DATE, D.EXPIRE_DATE - NVL(N.EXPIRE,0 )
,D.NOMENKLATURA_N, I.NUM_ACT, I.NUM_INVOICE
  ) LOOP

PMSG := SUBSTR(PMSG ||CHR(13)|| 'ПАЛЕТ НЕ ОПРИХОДОВАН!!! '||V1310 ||
        'АКТ № '||J.NUM_ACT||' ('||J.NUM_INVOICE||')'||V1310 ||
        'КОНТРАГЕНТ: '||J.BRIEF ||V1310 ||
        J.CODE ||' '|| J.NAME ||V1310||
        J.CNT ||' '||J.UNIT_TERM||' '|| J.TYP_TERM||V1310||
         STOCKNBYNOMUNITS(J.NOMENKLATURA_N,J.CNT)||J.KOND_TYPE||V1310||
        'НА АДРЕСЕ: '|| J.ADDR ||V1310||
        CASE WHEN J.PART_NUM IS NULL THEN NULL ELSE 'ПАРТИЯ:' ||J.PART_NUM||V1310 END  ||
        'СРОК: '     || TO_CHAR(J.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
        'ИГОТОВЛ: '  || TO_CHAR(J.EXPIRE_FROM,'DD.MM.YYYY') || V1310
          ,1,2000);

END LOOP;
END IF; --IF PMSG IS NULL THEN

IF PMSG IS NULL THEN
FOR J IN (

  SELECT/*+ ORDERED INDEX_DESC(D ST_DOC_OUT_PICK_PALL_TD_FD) INDEX_DESC(ST ST_STOCK_N_FD_TD)
  INDEX_DESC(DOC ST_DOC_OUT_N_FD_TD) INDEX(C CONTRAGENT_N_FD_TD)*/
 N.CODE,N.NAME
,DECODE(VSHOWPART,0,NULL,SUBSTR(STRAGG(P.PART_NUM),1,50)) AS PART_NUM
,C.BRIEF
,A.ADDR
,SUM(ST.CNT) AS CNT
,DECODE(ST.NOM_TYP,3,'БРАК!!!',NULL) AS KOND_TYPE
, ST.EXPIRE_DATE, ST.EXPIRE_DATE - NVL(N.EXPIRE,0 ) AS EXPIRE_FROM
,ST.NOMENKLATURA_N, DOC.DOC

   FROM
    ST_DOC_OUT_PICK D
     JOIN ST_STOCK ST ON (ST.N = D.STOCK_N AND ST.TYP = 6)
     JOIN ST_DOC_OUT DOC ON (D.ST_DOC_OUT_N = DOC.N AND SYSDATE BETWEEN DOC.FD AND DOC.TD)
     JOIN CONTRAGENT C ON (  C.N = ST.CONTRAGENT_N AND D.FD BETWEEN C.FD AND C.TD)
      JOIN CELL_ADDRESS A ON (  A.N = ST.CELL_ADDRESS_N  AND ST.FD  BETWEEN A.FD AND A.TD)
       JOIN NOMENKLATURA N ON (  N.N = ST.NOMENKLATURA_N  AND D.FD BETWEEN N.FD AND N.TD)
       LEFT OUTER JOIN ST_PART P ON (   ST.ST_PART_N = P.N AND SYSDATE BETWEEN P.FD AND P.TD)
  WHERE
      SYSDATE BETWEEN D.FD AND  D.TD
  AND D.ST_PALL_N = VPALLN
 GROUP BY  N.CODE,N.NAME
,C.BRIEF
,A.ADDR
,DECODE(ST.NOM_TYP,3,'БРАК!!!',NULL)
, ST.EXPIRE_DATE, ST.EXPIRE_DATE - NVL(N.EXPIRE,0 )
,ST.NOMENKLATURA_N, DOC.DOC

) LOOP

PMSG := SUBSTR(PMSG ||V1310||'СОБРАН В ЗАКАЗ №'||J.DOC||V1310 ||
        'КОНТРАГЕНТ: '||J.BRIEF ||V1310 ||
        J.CODE ||' '|| J.NAME ||V1310||
        J.CNT ||'У.Е '||V1310||
         STOCKNBYNOMUNITS(J.NOMENKLATURA_N,J.CNT)||J.KOND_TYPE||V1310||
        'НА АДРЕСЕ: '|| J.ADDR ||V1310||
        CASE WHEN J.PART_NUM IS NULL THEN NULL ELSE 'ПАРТИЯ:' ||J.PART_NUM||V1310 END  ||
        'СРОК: '     || TO_CHAR(J.EXPIRE_DATE,'DD.MM.YYYY') || V1310||
        'ИГОТОВЛ: '  || TO_CHAR(J.EXPIRE_FROM,'DD.MM.YYYY') || V1310
          ,1,2000);

END LOOP;

END IF; --IF PMSG IS NULL THEN


IF PMSG IS NULL THEN

FOR J IN (
  SELECT 'MACRO PID-'||J.ST_PALL_N ||V1310||
        'ЗАДАНИЕ: '||DD.TERM||V1310||
        'ОТКУДА->'||AF.ADDR||V1310||
        'КУДА->'||ATT.ADDR||V1310||
        'ПРИХОДЫ P-'||STRAGG(P.PALL_N) AS MSG
       FROM
       ST_BAR_JOBS J
           JOIN ST_BAR_PID_JOBS_LINKS L ON (L.ST_BAR_PID_JOBS_N = J.N AND L.TD = KK_COMMON.GETTD)
           JOIN ST_DOC_IN_DET P ON (P.PALL_N = L.N2
                              AND P.TD = KK_COMMON.GETTD)
           JOIN DIC_DATA DD ON(DD.UP =21 AND DD.CODE =J.STATUS AND DD.TD = KK_COMMON.GETTD)
LEFT OUTER JOIN CELL_ADDRESS AF ON (AF.N = J.CELL_ADDRESS_N AND AF.TD = KK_COMMON.GETTD)
LEFT OUTER JOIN CELL_ADDRESS ATT ON (ATT.N = J.VAL2 AND ATT.TD = KK_COMMON.GETTD)
         WHERE  J.ST_PALL_N = VPALLN
         AND J.TYP = 33
        AND J.STATUS != 999
GROUP BY J.ST_PALL_N , DD.TERM,AF.ADDR,ATT.ADDR
 UNION ALL
  SELECT 'MACRO PID-'||J.ST_PALL_N ||V1310||
        'ЗАДАНИЕ: '||DD.TERM||V1310||
        'ОТКУДА->'||AF.ADDR||V1310||
        'КУДА->'||ATT.ADDR||V1310||
        'ЗАКАЗЫ P-'||STRAGG(P.ST_PALL_N)AS MSG
       FROM
       ST_BAR_JOBS J
           JOIN ST_BAR_PID_JOBS_LINKS L ON (L.ST_BAR_PID_JOBS_N = J.N AND L.TD = KK_COMMON.GETTD)
         JOIN ST_DOC_OUT_PICK P ON (P.ST_PALL_N = L.N2
                               AND P.TD = KK_COMMON.GETTD)
           JOIN DIC_DATA DD ON(DD.UP =21 AND DD.CODE =J.STATUS AND DD.TD = KK_COMMON.GETTD)
LEFT OUTER JOIN CELL_ADDRESS AF ON (AF.N = J.CELL_ADDRESS_N AND AF.TD = KK_COMMON.GETTD)
LEFT OUTER JOIN CELL_ADDRESS ATT ON (ATT.N = J.VAL2 AND ATT.TD = KK_COMMON.GETTD)
        WHERE  J.ST_PALL_N = VPALLN
        AND J.TYP = 33
        AND J.STATUS != 999
GROUP BY J.ST_PALL_N , DD.TERM,AF.ADDR,ATT.ADDR


) LOOP

PMSG := SUBSTR(PMSG ||V1310||J.MSG ,1,2000);

END LOOP;


END IF;




IF PMSG IS NULL THEN
   PMSG := 'СОСТАВ ПАЛЛЕТЫ НЕОБНАРУЖЕН';
END IF;


RETURN 1;
END WHATONPALL;

FUNCTION STBARCODECANCELJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VJOBN INTEGER;
VRD ROWID;
BEGIN
SELECT VAL1,ROWID INTO VJOBN,VRD
 FROM MCIS_NODES_PROC
 WHERE SYSDATE BETWEEN FD AND TD
       AND TYP =17
   CONNECT BY PRIOR UP = N
  START WITH N = PPROCN
  ;

KK_ST_BAR_JOBS.CANCELJOB(PROBJN ,0,VJOBN);

UPDATE MCIS_NODES_PROC
 SET TD = SYSDATE
  WHERE ROWID = VRD;

RETURN 1;

-- ОБРАБОТКА ОТКАЗА ОТ ЗАДАНИЙ, ПРИ ОТСУТСТВИИ АКТИВНЫХ
EXCEPTION
WHEN NO_DATA_FOUND THEN RAISE_APPLICATION_ERROR(-20000, 'НЕТ ЗАДАНИЙ.');

END;

FUNCTION STBARCODECANCELJOBINTOGATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VJOBN INTEGER :=    KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_BAR_JOBS.N');
VRET INTEGER;
BEGIN
   PMSG := NULL;
IF VJOBN <> 0 THEN
--   RAISE_APPLICATION_ERROR(-20000, VJOBN);
   UPDATE ST_BAR_JOBS S
   SET S.STATUS = 1
   , S.EMP_N = 0
   WHERE S.N = VJOBN
   AND S.STATUS = 2
   AND S.TYP = 16;

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_BAR_JOBS.N',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CELL_ADDRESS_N',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',NULL);

   VRET := 1;
ELSE
   VRET := -1;
END IF;

RETURN VRET;
END STBARCODECANCELJOBINTOGATE;


FUNCTION SETFILTERJOB_3(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_ORDER_TYPE',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_TYP',',3,');
   PMSG := 'ПЕРЕМЕЩЕНИЕ ЦЕЛЫХ ПАЛЛЕТ';
RETURN 1;
END SETFILTERJOB_3;

FUNCTION SETFILTERJOB_7(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_ORDER_TYPE',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_TYP',',7,');
   PMSG := 'ИНВЕНТАРИЗАЦИЯ';
RETURN 1;
END SETFILTERJOB_7;


FUNCTION SETFILTERJOB_5(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_ORDER_TYPE',5);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_TYP',',5,');
   PMSG := 'С КОНСОЛИДАЦИИ НА ОТГРУЗКУ';
RETURN 1;
END SETFILTERJOB_5;


FUNCTION SETFILTERJOB_32(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCANIGNOREINPUT INTEGER:=0;
BEGIN --11714 ЗАДАЧА, ПРОВЕРЯЕТ ДОСТУП, ЗАДАЕТ, МОЖНО ЛИ ИГНОРИРОВАТЬ ВВОД НАЧАЛЬНОЙ ЯЧЕЙКИ
  BEGIN
    VCANIGNOREINPUT:=KK_PERMIT.EXISTSPERMITACCESS(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'),
                                                  'STDOCOUT.JOB32.SKIPSCANADDRFROM',
                                                   SYSDATE);
   IF VCANIGNOREINPUT=3 THEN
      VCANIGNOREINPUT:=1;
   END IF;

  EXCEPTION
    WHEN OTHERS THEN VCANIGNOREINPUT:=0;
  END;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT',VCANIGNOREINPUT);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_ORDER_TYPE',0);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_TYP',',32,');
     PMSG := 'ЦЕЛЫЕ ПАЛЛЕТЫ В ЗАКАЗ';
RETURN 1;
END SETFILTERJOB_32;






FUNCTION GETSTBARCODEJOB_DEF(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VJOBN INTEGER;
VJOBTYP INTEGER;
VSTDOCTYP INTEGER;
VSTDOCN INTEGER;
VVAL INTEGER;
VVAL1 INTEGER;
VMSG VARCHAR2(255);
VRET INTEGER;
VCONTRAGENTNAME VARCHAR2(255);
XMSG VARCHAR2(500);
VADDRFROM VARCHAR2(255);
VADDRTO VARCHAR2(255);
VNOMN INTEGER;
VCONTRAGENTN INTEGER;
VSTOREN INTEGER;
VVAL2 INTEGER;
VBASEDOCN INTEGER;
VOUTCELL INTEGER;
--VSTDOCOUTRD ROWID;
VPALLN INTEGER;
VPALLN_INPUT INTEGER;
VSTSTOCKN INTEGER;
VCONSOLIDATIONCELLTYPN2 LIST_CONST.VAL%TYPE;
VJOBSTEP INTEGER DEFAULT 0;
VJOBTYPS VARCHAR2(20) := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB_TYP'),',3,32,');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

BEGIN
 SELECT CASE WHEN INSTR(PSTR,'P-')=1 THEN TO_NUMBER(NVL(SUBSTR(PSTR,3),'X')) ELSE TO_NUMBER(NVL(PSTR,'X')) END INTO  VPALLN FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
      VPALLN := 0;
END;

VPALLN := NVL(VPALLN,0);
VPALLN_INPUT := VPALLN;

 IF PKEYCODE = '00' THEN
  VJOBSTEP := -2; -- ПРЕДЫДУЩАЯ ЗАДАЧА
 END IF; --IF PKEYCODE = '00' THEN

--KK_COMMON.ACTION(0,'KK_ST_BARCODE',0,0,SYSDATE,VJOBTYPS);

       VJOBN := KK_ST_BAR_JOBS.GETNEXTJOB(PROBJN ,VJOBTYPS/*3- ПЕРЕМЕЩ 32-ЦЕЛЫЕ В ПОДБОРКУ*/,VSTDOCTYP,VSTDOCN,VVAL,VVAL1,VMSG,VVAL2,VPALLN,VJOBSTEP);

--RAISE_APPLICATION_ERROR(-20000,VSTDOCN||'/'||VJOBN);


 IF VJOBN = 0 THEN
   VCONTRAGENTNAME := KK_ST_BAR_JOBS.GETCONTEXTCONTRAGENTNAMEX(PROBJN) ;
   PMSG := 'ЗАДАНИЙ НЕТ' || '(ФИЛЬТР ='||VCONTRAGENTNAME||')';
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',NULL);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.N',0 );
  RETURN -1;
 ELSE

 SELECT ST_STOCK_N,TYP,BASE_DOC_N ,ST_PALL_N,CONTRAGENT_N
  INTO VSTSTOCKN,VJOBTYP,VBASEDOCN,VPALLN,VCONTRAGENTN
    FROM
  ST_BAR_JOBS WHERE
   N = VJOBN
AND SYSDATE BETWEEN FD AND TD ;


   BEGIN

  CASE

    WHEN VJOBTYP = 7 /*ИНВЕНТАРИЗАЦИЯ*/ THEN

 SELECT 'ИНВЕНТАРИЗИРУЙТЕ АДРЕС: ' || A.ADDR INTO PMSG
    FROM
  ST_BAR_JOBS J
   JOIN CELL_ADDRESS A ON (A.N = J.CELL_ADDRESS_N AND SYSDATE BETWEEN A.FD AND A.TD)
   WHERE
   J.N = VJOBN
    AND SYSDATE BETWEEN J.FD AND J.TD ;

     VNOMN := 0;
     VRET := 3;
    WHEN VJOBTYP = 3 /*ПЕРЕМЕЩЕНИЕ DIC 416*/ THEN


 WITH J AS (
     SELECT J.ST_DOC_N , J.VAL1,J.ST_STOCK_N , J.ST_PALL_N , J.NOMENKLATURA_N, J.VAL2
       FROM ST_BAR_JOBS J
         CONNECT BY PRIOR J.ST_STOCK_N = J.UP AND J.TYP = 3 AND  J.TD = KK_COMMON.GETTD
        START WITH J.N = VJOBN AND J.TYP = 3 AND  J.TD = KK_COMMON.GETTD
 )
 SELECT  'P-'||X.ST_PALL_N  ,
     STRAGG_SEP(T_STR_SEP(KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(X.NOMENKLATURA_N, X.CNT )||V1310|| DECODE( KK_CONST.GETCONSTN('STBARJOBS.SHOWNOMENKLATURACODEINTASK',SYSDATE,N.CONTRAGENT_N),1,N.CODE ||' ','')
      || SUBSTR(N.NAME, 1, KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH', SYSDATE, VCONTRAGENTN))
      ||' ' , V1310) ) AS PMSG

      , X.NOMENKLATURA_N
      , ADDR_F.ADDR  ||' ==> '|| MIN(ADDR_T.ADDR) AS F_ADDR
      , N.CONTRAGENT_N
      , X.STORE_N
  INTO PMSG,XMSG,VNOMN,VADDRFROM,VCONTRAGENTN,VSTOREN
  FROM
  (
      SELECT J.ST_PALL_N , DT.CELL_ADDRESS_N ,  DT.CELL_ADDRESS_NEW_N , ST.STORE_N ,J.NOMENKLATURA_N, J.VAL2
           , SUM( J.VAL1) AS CNT
           , COUNT(DISTINCT J.NOMENKLATURA_N) AS MIX
      FROM J
       JOIN ST_DOC_MOVE_DET DT ON (DT.N= J.ST_DOC_N    AND SYSDATE BETWEEN DT.FD AND DT.TD )
       LEFT JOIN ST_STOCK ST ON (ST.N = DT.STOCK_N /*AND SYSDATE BETWEEN ST.FD AND ST.TD AND ST.TYP = 3*/ )
         WHERE 1=1
         GROUP BY  J.ST_PALL_N , DT.CELL_ADDRESS_N ,  DT.CELL_ADDRESS_NEW_N , ST.STORE_N ,J.NOMENKLATURA_N, J.VAL2
   ) X
        JOIN CELL_ADDRESS ADDR_F ON (NVL(X.VAL2,X.CELL_ADDRESS_N) = ADDR_F.N AND  ADDR_F.TD = KK_COMMON.GETTD )
        JOIN CELL_ADDRESS ADDR_T ON (X.CELL_ADDRESS_NEW_N = ADDR_T.N AND  ADDR_T.TD = KK_COMMON.GETTD )
        LEFT JOIN NOMENKLATURA N ON (X.NOMENKLATURA_N = N.N AND  N.TD = KK_COMMON.GETTD)
  GROUP BY ADDR_F.ADDR ,X.ST_PALL_N    /*, ADDR_T.ADDR  */      , X.NOMENKLATURA_N , N.CONTRAGENT_N , X.STORE_N;

    PMSG := PMSG ||V1310|| VADDRFROM || V1310 ||XMSG|| V1310  ;

/*
     SELECT+ ORDERED INDEX_DESC(DT ST_DOC_MOVE_DET_N_FD_TD)
                 DECODE(MOD(VVAL,B.BLCK),0,'ЦЕЛАЯ','НЕ ЦЕЛАЯ!')||' P-'||ST.ST_PALL_N|| V1310||
                 VVAL||' У.Е. ' ||
            DECODE(TRUNC(VVAL/B.BLCK),0,'',TRUNC(VVAL/B.BLCK) ||' ПАЛЛЕТ ') ||
            DECODE(MOD(VVAL,B.BLCK),0,'',MOD(VVAL,B.BLCK) || ' ' || DD_NOM_UNIT.TERM) || V1310
            ,
            DECODE( KK_CONST.GETCONSTN('STBARJOBS.SHOWNOMENKLATURACODEINTASK',SYSDATE,N.CONTRAGENT_N),1,N.CODE ||' ','!!!') ||N.NAME ||' '|| TO_CHAR(ST.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
             V1310 ||'C ' || ADDR_F.ADDR ||
            ' ===> ' || ADDR_T.ADDR
           -- || V1310 || 'ПАЛЛЕТЕЗАЦИЯ ' || B.BLCK
            ,DT.NOMENKLATURA_N
            ,'C ' || ADDR_F.ADDR,ST.CONTRAGENT_N,ST.STORE_N
             INTO PMSG,XMSG,VNOMN,VADDRFROM,VCONTRAGENTN,VSTOREN
      FROM ST_DOC_MOVE_DET DT
       JOIN CELL_ADDRESS ADDR_F ON (VVAL2 = ADDR_F.N AND SYSDATE BETWEEN  ADDR_F.FD AND ADDR_F.TD)
       JOIN CELL_ADDRESS ADDR_T ON (DT.CELL_ADDRESS_NEW_N = ADDR_T.N AND SYSDATE BETWEEN  ADDR_T.FD AND ADDR_T.TD)
       JOIN NOMENKLATURA N ON (DT.NOMENKLATURA_N = N.N AND SYSDATE BETWEEN  N.FD AND N.TD)
       JOIN ST_STOCK ST ON (ST.N = DT.STOCK_N )
       JOIN NOM_BLCK B ON (B.NOMENKLATURA_N = DT.NOMENKLATURA_N AND B.PALL_TYPE = ST.PALL_TYPE AND SYSDATE BETWEEN B.FD AND B.TD)
       JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND SYSDATE BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
         WHERE DT.N = VSTDOCN
          AND SYSDATE BETWEEN DT.FD AND DT.TD
          AND ROWNUM <= 1
          ;

       PMSG := PMSG ||  STOCKNBYNOMUNITS(VNOMN,VVAL)||V1310 ||XMSG ;
*/

--    PMSG := VJOBN||'STBARCODENODEMOVE='||PNEXTNODE;
    VRET := 3;
     WHEN VJOBTYP = 5 /*С КОНСОЛИДАЦИИ НА ОТГРУЗКУ*/ THEN

DECLARE
VROUTEN INTEGER;
VROUTENUM TMS_ROUTE.NUM%TYPE;
VJOBBLOCK INTEGER;
VJOBSLEFT VARCHAR2(50);
BEGIN

    SELECT 'С КОНСОЛИДАЦИИ НА ОТГРУЗКУ', C.NAME, S.ST_PALL_N, A.ADDR, A2.ADDR , NVL(R.N,0) , R.NUM , S.JOB_BLOCK
      INTO PMSG,VCONTRAGENTNAME,VPALLN,VADDRFROM,VADDRTO  , VROUTEN, VROUTENUM , VJOBBLOCK
    FROM ST_BAR_JOBS S
           JOIN CONTRAGENT C ON (S.CONTRAGENT_N = C.N AND SYSDATE BETWEEN C.FD AND C.TD)
           JOIN CELL_ADDRESS A ON (S.CELL_ADDRESS_N = A.N AND SYSDATE BETWEEN A.FD AND A.TD)
           JOIN ST_DOC_OUT D ON (S.BASE_DOC_N = D.N AND D.TD = KK_COMMON.GETTD)
LEFT OUTER JOIN TMS_ORDER O ON (O.WMS_ST_DOC_OUT_N = S.BASE_DOC_N AND O.TD = KK_COMMON.GETTD)
LEFT OUTER JOIN TMS_ROUTE R ON (O.TMS_ROUTE_N = R.N AND R.TD = KK_COMMON.GETTD)
      JOIN CELL_ADDRESS A2 ON (D.GATE_CELL_N = A2.N AND SYSDATE BETWEEN A2.FD AND A2.TD)
   WHERE S.N = VJOBN;

   SELECT COUNT(1) ||' ОСТ:'|| SUM(DECODE(J.STATUS,3,0,1)) INTO VJOBSLEFT
    FROM ST_BAR_JOBS  J
     WHERE J.TYP = 5
     AND J.JOB_BLOCK = VJOBBLOCK
     AND J.STATUS IN (1,2,3);



       SELECT  PMSG||V1310||'КОНТРАГЕНТ: '||VCONTRAGENTNAME||V1310||
       DECODE(VROUTEN,0,NULL,'МАРШРУТ: '||VROUTENUM||V1310)||
       'P-'||VPALLN||V1310||'C '||VADDRFROM||' ==> '||VADDRTO||V1310
       ||VJOBSLEFT
        INTO PMSG
        FROM DUAL ;

END;

--    PMSG := VJOBN||'STBARCODENODEMOVE='||PNEXTNODE;
    VRET := 3;

    WHEN VJOBTYP = 32 /*ЗАКАЗЫ ЦЕЛЫЕ ПАЛЛЕТ*/ THEN

    DECLARE
     VMSG2 VARCHAR2(1000);
     VMSGCONST VARCHAR2(100);
    BEGIN
    VMSGCONST := NVL(KK_CONST.GETCONSTV('BARCODEJOBMSG',SYSDATE, VCONTRAGENTN ), '_') ;
      IF VMSGCONST = '_' THEN


        BEGIN
        WITH J AS (
        SELECT J.ST_DOC_N , J.VAL1,J.ST_STOCK_N , J.NOMENKLATURA_N ,J.BASE_DOC_N, J.VAL2
         FROM ST_BAR_JOBS J
                   CONNECT BY PRIOR J.ST_STOCK_N = J.UP AND J.TYP = 32 AND  J.TD   =KK_COMMON.GETTD
          START WITH J.N = VJOBN AND J.TYP = 32 AND  J.TD =KK_COMMON.GETTD
        )
        SELECT *
        INTO PMSG,XMSG, VADDRFROM,VSTOREN,VNOMN
        FROM (
        SELECT X.DOC, X.DOC2||V1310||STRAGG_SEP(T_STR_SEP(X.NOM,V1310))|| V1310
              , X.ADDR ,  X.STORE_N   , X.NOMENKLATURA_N
         FROM (
          SELECT/*+ ORDERED INDEX_DESC(DT ST_DOC_MOVE_DET_N_FD_TD)*/
             ADDR_F.ADDR || ' P-'||ST.ST_PALL_N  AS DOC
                     ,'ЗАКАЗ "'||NVL(D.DOC,D.NUM_ACT)||'"'     AS DOC2 ,
                  DECODE( KK_CONST.GETCONSTN('STBARJOBS.SHOWNOMENKLATURACODEINTASK',SYSDATE,ST.CONTRAGENT_N),1,N.CODE ||' ','!!!')
                  ||N.NAME ||' '||
                  KK_ST_BARCODE5.STOCKCNTCONVERTTOUNITDSC(DT.NOMENKLATURA_N, SUM(ST.CNT))||' '
                  || TO_CHAR(ST.EXPIRE_DATE,'DD.MM.YY')   AS NOM
                    ,'С ' || ADDR_F.ADDR AS ADDR ,ST.STORE_N , J.NOMENKLATURA_N

              FROM J
               JOIN ST_DOC_OUT_DET DT ON (DT.N = J.ST_DOC_N AND  DT.TD =KK_COMMON.GETTD AND DT.SQ_ST_DOC_OUT_N = J.BASE_DOC_N)
               JOIN ST_STOCK ST ON (ST.N = J.ST_STOCK_N AND ST.ST_DOC_N = DT.N AND ST.TYP IN (6,19) AND ST.TD = KK_COMMON.GETTD)
               JOIN CELL_ADDRESS ADDR_F ON (ADDR_F.N = J.VAL2 AND ADDR_F.TD=KK_COMMON.GETTD)
               JOIN ST_DOC_OUT D ON (D.N = DT.SQ_ST_DOC_OUT_N  AND SYSDATE BETWEEN D.FD AND D.TD )
               JOIN NOMENKLATURA N ON (DT.NOMENKLATURA_N = N.N AND N.TD=KK_COMMON.GETTD)
               JOIN NOM_BLCK B ON (B.NOMENKLATURA_N = DT.NOMENKLATURA_N AND B.PALL_TYPE = ST.PALL_TYPE AND B.TD=KK_COMMON.GETTD)
               JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND DD_NOM_UNIT.TD=KK_COMMON.GETTD)
                 WHERE 1=1
                 GROUP BY D.DOC,D.NUM_ACT,ST.ST_PALL_N,
                  N.CODE,N.NAME ,DT.NOMENKLATURA_N ,
                   ST.EXPIRE_DATE, ADDR_F.ADDR ,ST.STORE_N,ST.CONTRAGENT_N, J.NOMENKLATURA_N
                 ) X
        GROUP BY X.DOC ,X.DOC2 , X.ADDR , X.STORE_N , X.NOMENKLATURA_N
        ) WHERE ROWNUM <2;

        EXCEPTION
          WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
            RAISE_APPLICATION_ERROR(-20000,'VJOBN='||VJOBN||'; '||SQLERRM);
        END;
     ELSE
     EXECUTE IMMEDIATE 'BEGIN :PRESULT := '|| VMSGCONST ||'(:PJOBN,:PSTDOCN, :PSTSTOCKN,:PVAL2, :PXMSG, :PNOMN, :PADDRFROM, :PCONTRAGENTN, :PSTOREN  );  END;'
       USING OUT VMSG2, IN VJOBN, IN VSTDOCN ,IN VSTSTOCKN,IN VVAL2,OUT XMSG,OUT VNOMN, OUT VADDRFROM , OUT VCONTRAGENTN , OUT VSTOREN;
        PMSG := PMSG ||V1310|| VMSG2;

     END IF;


INSERT INTO ST_MESSAGES (GRP, VAL, VAL2, VAL3, VAL4 ) VALUES (32, VBASEDOCN, VJOBN, VJOBTYP, '' );

        VOUTCELL :=   KK_ST_BARCODE5.GETCONSOLIDATIONCELLN(VCONTRAGENTN,VBASEDOCN,VADDRTO , VPALLN ) ;
        IF NVL(VOUTCELL,0) = 0 THEN
         RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА КОНСОЛИДАЦИИ НЕ ОПРЕДЕЛЕНА! VPALLN='||VPALLN||'</ERR>');
        END IF;

        PMSG := PMSG ||' ==> '|| VADDRTO || V1310 || XMSG;


        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PID',VPALLN);

    VRET := 3;

 END;     --WHEN VJOBTYP = 32

  WHEN VJOBTYP = 11 /*ПОСТАВКА*/ THEN

        WITH J AS (
        SELECT J.ST_DOC_N , J.VAL1,J.ST_STOCK_N , J.NOMENKLATURA_N ,J.BASE_DOC_N
         FROM ST_BAR_JOBS J
          WHERE  J.N = VJOBN
           AND J.TYP = 11
           AND  J.TD =KK_COMMON.GETTD
        )
       SELECT 'ПОСТАВКА '|| I.NUM_INVOICE ||' '|| C.NAME ||V1310|| STRAGG(J2.ST_PALL_N)
        INTO PMSG
        FROM J
        JOIN ST_DOC_IN I ON (I.N = BASE_DOC_N AND I.TD = KK_COMMON.GETTD)
        LEFT OUTER JOIN C_CONTRAGENT C ON (C.N = I.CCONTRAGENT_N AND C.TD = KK_COMMON.GETTD)
        JOIN ST_BAR_JOBS J2 ON (J2.TYP = 11 AND J2.STATUS IN (1,2)
                            AND J2.TD = KK_COMMON.GETTD
                            AND J2.BASE_DOC_N =  J.BASE_DOC_N
        )
        WHERE 1=1
        GROUP BY I.NUM_INVOICE,C.NAME;


       VRET := 3;
  WHEN VJOBTYP = 33 /*MACRO PID*/ THEN

        WITH J AS (
        SELECT J.ST_PALL_N , J.CELL_ADDRESS_N,J.VAL2
         FROM ST_BAR_JOBS J
          WHERE  J.N = VJOBN
           AND J.TYP = 33
           AND  J.TD =KK_COMMON.GETTD
        )

SELECT 'P-'||J.ST_PALL_N ||V1310|| A_F.ADDR ||'==>'|| A_T.ADDR
  INTO PMSG
 FROM J
    JOIN CELL_ADDRESS A_F ON (A_F.N = J.CELL_ADDRESS_N AND A_F.TD = KK_COMMON.GETTD )
    JOIN CELL_ADDRESS A_T ON (A_T.N = J.VAL2           AND A_T.TD = KK_COMMON.GETTD )
   WHERE 1=1 ;


    VRET := 3;
  WHEN VJOBTYP = 17 THEN
    BEGIN
      IF NVL(PSTR, PKEYCODE) LIKE 'P-%' THEN
        VPALLN := TO_NUMBER(SUBSTR(NVL(PSTR, PKEYCODE),3, 25));
      ELSE
        VPALLN := TO_NUMBER(NVL(PSTR, PKEYCODE));
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
        VPALLN := 0;
    END;
    IF VPALLN = 0 THEN
      RAISE_APPLICATION_ERROR(-20000, '<ERR>ОШИБКА ОПРЕДЕЛЕНИЯ ПИД.</ERR>');
    END IF;
/*    IF VPALLN_INPUT != VPALLN AND VPALLN_INPUT != 0 THEN
      SELECT STRAGG(C.ADDR)
        INTO PMSG
        FROM ST_DOC_OUT_PICK P
        JOIN CELL_ADDRESS C ON (C.N = P.CELL_ADDRESS_N AND C.TD = KK_COMMON.GETTD)
        WHERE P.ST_PALL_N = VPALLN
          AND P.TD = KK_COMMON.GETTD;
      RAISE_APPLICATION_ERROR(-20000, '<ERR>У ВАС ЕСТЬ ЗАДАНИЕ НА ПАЛЛЕТУ P-'||VPALLN||', НА АДРЕСЕ:'||PMSG||'. ВЫПОЛНИТЕ ЕГО.</ERR>');
    END IF;*/
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'PID', VPALLN);
    BEGIN
      SELECT STRAGG_SEP(T_STR_SEP( N.CODE||' - '|| SUBSTR(N.NAME, 1, KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH', SYSDATE, N.CONTRAGENT_N))||': '||SUM(P.CNT)||DD.TERM, CHR(13)||CHR(10)))
        INTO PMSG
        FROM ST_DOC_OUT_PICK P
        LEFT JOIN NOMENKLATURA N ON (N.N = P.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
        LEFT JOIN DIC_DATA DD ON (DD.UP = 362 AND DD.CODE = N.UNIT AND DD.TD = KK_COMMON.GETTD)
        WHERE P.ST_PALL_N = VPALLN
          AND P.TD = KK_COMMON.GETTD
        GROUP BY N.CODE, N.NAME, N.CONTRAGENT_N, DD.TERM;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20000, '<ERR>СОБРАННЫЕ ПОЗИЦИИ ПО ПИД=P-'||VPALLN||' НЕ НАЙДЕНЫ.</ERR>');
    END;
    PMSG := 'НАДО РАЗЛОЖИТЬ:'||CHR(13)||CHR(10)||PMSG;
    VRET := 3;
  ELSE
  PMSG := '<ERR>ДЛЯ ДАННОГО ТИПА ЗАДАНИЙ НИЧЕГО НЕ РАЗРАБОТАНО! VJOBTYP="'||VJOBTYP||'"</ERR>';
   VRET := -1;
  END CASE;


     EXCEPTION
         WHEN NO_DATA_FOUND THEN
      --    RAISE_APPLICATION_ERROR(-20000,VSTDOCN||' '||VJOBN);
      KK_COMMON.ERR_LOG('GETSTBARCODEJOB',VJOBN, 'СОДЕРЖАНИЕ ЗАДАНИЯ ИЗМЕНЕНО. VSTDOCTYP='||VSTDOCTYP ||' DOC_DET_N='||VSTDOCN||' VSTSTOCKN='||VSTSTOCKN);
        PMSG := '<ERR>СОДЕРЖАНИЕ ЗАДАНИЯ ИЗМЕНЕНО. ВОЗЬМИТЕ ДРУГОЕ ЗАДАНИЕ!VJOBN='||VJOBN||'</ERR>';
         KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,VJOBN,0,0,NULL,NULL,NULL,999,SYSDATE,NULL,0);


           VRET := -2;
        END;

  IF VRET > 0 THEN

     --ДОПИСЫВАЕМ КОММЕНТАРИЙ К PMSG ЕСЛИ ЭТО НЕОБХОДИМО (ПО КОНСТАНТЕ И ПОЛЬЗОВАТЕЛЬСКОЙ ФУНКЦИИ)
   DECLARE
     VSTBARJOBSCOMMENTPROC LIST_CONST.VAL%TYPE;
     VSTBARJOBSCOMMENT VARCHAR2(2500);
   BEGIN
     VSTBARJOBSCOMMENTPROC := KK_CONST.GETCONSTV('STBARJOBSCOMMENT',SYSDATE);

     IF VSTBARJOBSCOMMENTPROC <> '_' THEN
       EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VSTBARJOBSCOMMENTPROC||'(:PJOBN, :PJOBTYP, :PCONTRAGENTN, :PSTOREN, :PNOMENKLATURAN, :PDOCTYP, :PCELADDRESS);  END;'
       USING OUT VSTBARJOBSCOMMENT, IN VJOBN, IN 12, IN VCONTRAGENTN, IN VSTOREN, IN VNOMN, IN VSTDOCTYP, IN 0;
       PMSG := PMSG ||V1310|| VSTBARJOBSCOMMENT;
     END IF;

   EXCEPTION
    WHEN OTHERS THEN
     NULL;
   END;
   -----------------------------------------------------------------------------------------------

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',SUBSTR(PMSG,1,500) );
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.N',VJOBN );
--  RAISE_APPLICATION_ERROR(-20000, PROBJN||' /'||PMSG||'/'||KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB.DSC'));
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP,VAL4,VAL5,VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,17/*ЗАПОМНИЛИ НОМЕР ЗАДАНИЯ!!!*/,VJOBN,VSTDOCN,VSTDOCTYP,SYSDATE,KK_COMMON.GETTD,VVAL,0,SUBSTR(PMSG,1,500),VCONTRAGENTN,VSTOREN)
   RETURNING N INTO PPROCN;
  PMSG := PMSG /*||V1310*/ ||' ФИЛЬТР:'||KK_ST_BAR_JOBS.GETCONTEXTCONTRAGENTNAMEX(PROBJN);

  ELSE
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',0);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',NULL);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.N',0 );
  END IF;--IF VRET = 0 THEN

  RETURN  VRET;
 END IF;



END GETSTBARCODEJOB_DEF;



FUNCTION GETSTBARCODEJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONST VARCHAR2(1000);
VRET INTEGER;
BEGIN
VCONST := KK_CONST.GETCONSTV('GETSTBARCODEJOBPROC' , SYSDATE,KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'));
SELECT DECODE(VCONST,'_','KK_ST_BARCODE.GETSTBARCODEJOB_DEF',NULL,'KK_ST_BARCODE.GETSTBARCODEJOB_DEF',VCONST ) INTO VCONST FROM DUAL;
EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VCONST ||'(:PKEYCODE , :PSTR, :PMSG,:PNEXTNODE,:PPROCN,:PROBJN);  END;'
USING  OUT VRET, IN PKEYCODE , IN PSTR, IN OUT PMSG,IN OUT PNEXTNODE, IN OUT PPROCN,IN OUT PROBJN;
--RAISE_APPLICATION_ERROR(-20000,VRET);
RETURN VRET;
END GETSTBARCODEJOB;


FUNCTION SHOWSTBARCODEJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VPALLN INTEGER;
    VORDTYPE INTEGER;
    VRET INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
PMSG := NULL;

 SELECT KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB.DSC') INTO PMSG FROM DUAL;
 SELECT KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB_ORDER_TYPE') INTO VORDTYPE FROM DUAL;
 PROBJN  := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB_NUM',0);
    BEGIN
     SELECT CASE WHEN INSTR(PSTR,'P-')=1 THEN TO_NUMBER(NVL(SUBSTR(PSTR,3),'X')) ELSE TO_NUMBER(NVL(PSTR,'X')) END INTO  VPALLN FROM DUAL;
    EXCEPTION
      WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
          VPALLN := 0;
    END;
    VPALLN := NVL(VPALLN,0);

 IF NVL(VORDTYPE,0) = 5 AND NVL(VPALLN,0) !=0 THEN

    -- ЗАДАНИЕ НА ПОДВОЗ С КОНСОЛИДАЦИИ ДО ОТГРУЗКИ , ПИД УЖЕ ВВЕДЕН, ПРОПУСКАЕМ ВВОД ПИД, ПЕРЕХОД В СКАНИРОВАНИЕ АДРЕСА
    VRET := INPUTPALLNINTOGATE(PKEYCODE, PSTR, PMSG ,PNEXTNODE,PPROCN,PROBJN);


  SELECT SUBSTR(PMSG ||V1310||  STRAGG_SEP(T_STR_SEP( 'P-'||NVL(J2.ST_PALL_N , J.ST_PALL_N)||CHR(9)|| A.ADDR ,CHR(13)||CHR(10))),1,2000)
    INTO PMSG
   FROM ST_BAR_JOBS J
  LEFT OUTER JOIN TMS_ORDER R ON (R.WMS_ST_DOC_OUT_N = J.BASE_DOC_N AND R.TD = KK_COMMON.GETTD )
  LEFT OUTER JOIN TMS_ROUTE T ON (R.TMS_ROUTE_N = T.N AND T.TD = KK_COMMON.GETTD )
  LEFT OUTER JOIN TMS_ORDER R2 ON (R2.TMS_ROUTE_N = T.N AND R2.TD = KK_COMMON.GETTD )
  LEFT OUTER JOIN ST_BAR_JOBS J2 ON (J2.BASE_DOC_N = R2.WMS_ST_DOC_OUT_N  AND J2.TD = KK_COMMON.GETTD  AND J2.STATUS IN (1,2) )
  LEFT OUTER JOIN CELL_ADDRESS A ON (A.N = NVL(J2.CELL_ADDRESS_N,J.CELL_ADDRESS_N) AND A.TD = KK_COMMON.GETTD  )
   WHERE
      J.TYP = 5
  AND J.TD = KK_COMMON.GETTD
  AND J.ST_PALL_N = VPALLN
  AND J.STATUS IN (1,2);





   IF VRET = 1 THEN RETURN 3; END IF;
 END IF; --IF NVL(VORDTYPE,0) = 5 AND NVL(,0) !=0 THEN

IF PMSG IS NULL THEN
PMSG := 'ЗАДАНИЕ НЕ ВЫБРАНО!';
RETURN 2;
ELSE
PMSG := PMSG;
RETURN 1;
END IF;


END;

FUNCTION GETSTBARCODENEARJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VJOBN INTEGER;
VSTDOCTYP INTEGER;
VSTDOCN INTEGER;
VVAL INTEGER;
VRET INTEGER;
VCELLADDRN INTEGER;
VVAL1 INTEGER;
VMSG VARCHAR2(255);
XMSG VARCHAR2(500);
VADDRFROM VARCHAR2(255);
VADDRTO VARCHAR2(255);
VNOMN INTEGER;
VCONTRAGENTN INTEGER;
VSTOREN INTEGER;
VVAL2 INTEGER;
VOUTCELL INTEGER;
VBASEDOCN INTEGER;
--VSTDOCOUTRD ROWID;
VSTSTOCKN INTEGER;
VPALLN INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

FOR J IN (       SELECT VAL1
             FROM MCIS_NODES_PROC
        CONNECT BY PRIOR UP= N
         START WITH N =PPROCN
          ORDER BY LEVEL
) LOOP

VCELLADDRN := J.VAL1;
EXIT ;

END LOOP;

       VJOBN := KK_ST_BAR_JOBS.GETNEARJOB(PROBJN ,',3,32,'/*3-ПЕРЕМЕЩ 32-ЦЕЛЫЕ В ПОДБОРКУ*/,VSTDOCTYP,VSTDOCN,VVAL,VCELLADDRN,VVAL1,VMSG,VVAL2);



 IF VJOBN = 0 THEN
   PMSG := 'ЗАДАНИЙ НЕТ';
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',NULL);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.N',0 );
  RETURN -1;
 ELSE

 SELECT ST_STOCK_N,BASE_DOC_N,ST_PALL_N INTO VSTSTOCKN,VBASEDOCN,VPALLN
    FROM
  ST_BAR_JOBS WHERE
   N = VJOBN
AND SYSDATE BETWEEN FD AND TD ;

   BEGIN

  CASE
    WHEN VSTDOCTYP = 3 /*ПЕРЕМЕЩЕНИЕ DIC 416*/ THEN


     SELECT/*+ ORDERED INDEX_DESC(DT ST_DOC_MOVE_DET_N_FD_TD)*/
                 DECODE(MOD(VVAL,B.BLCK),0,'ЦЕЛАЯ','НЕ ЦЕЛАЯ!')|| ' P-'||ST.ST_PALL_N|| V1310||
                 VVAL||' У.Е. ' ||
            DECODE(TRUNC(VVAL/B.BLCK),0,'',TRUNC(VVAL/B.BLCK) ||' ПАЛЛЕТ ') ||
            DECODE(MOD(VVAL,B.BLCK),0,'',MOD(VVAL,B.BLCK) || ' ' || DD_NOM_UNIT.TERM) || V1310
            ,
            N.CODE ||' '||N.NAME ||' '|| TO_CHAR(DT.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
            'ПЕРЕМЕСТИТЬ С АДРЕСА ' || ADDR_F.ADDR || V1310 ||
            'НА АДРЕС ' || ADDR_T.ADDR || V1310 ||
            'ПАЛЛЕТЕЗАЦИЯ ' || B.BLCK
            ,DT.NOMENKLATURA_N
            ,'ПЕРЕМЕСТИТЬ С АДРЕСА ' || ADDR_F.ADDR,ST.CONTRAGENT_N,ST.STORE_N
             INTO PMSG,XMSG,VNOMN,VADDRFROM,VCONTRAGENTN,VSTOREN
      FROM ST_DOC_MOVE_DET DT
       JOIN CELL_ADDRESS ADDR_F ON (VVAL2 = ADDR_F.N AND DT.FD BETWEEN  ADDR_F.FD AND ADDR_F.TD)
       JOIN CELL_ADDRESS ADDR_T ON (DT.CELL_ADDRESS_NEW_N = ADDR_T.N AND DT.FD BETWEEN  ADDR_T.FD AND ADDR_T.TD)
       JOIN NOMENKLATURA N ON (DT.NOMENKLATURA_N = N.N AND DT.FD BETWEEN  N.FD AND N.TD)
       JOIN ST_STOCK ST ON (ST.N = DT.STOCK_N)
       JOIN NOM_BLCK B ON (B.NOMENKLATURA_N = DT.NOMENKLATURA_N AND B.PALL_TYPE = ST.PALL_TYPE AND DT.FD BETWEEN B.FD AND B.TD)
       JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND ST.FD BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
         WHERE DT.N = VSTDOCN
          AND SYSDATE BETWEEN DT.FD AND DT.TD ;

       PMSG := PMSG ||  STOCKNBYNOMUNITS(VNOMN,VVAL)||V1310 ||XMSG ;

    VRET := 3;

    WHEN VSTDOCTYP = 1 /*ЗАКАЗЫ ЦЕЛЫЕ ПАЛЛЕТ*/ THEN


     SELECT/*+ ORDERED INDEX_DESC(DT ST_DOC_MOVE_DET_N_FD_TD)*/
     'ПОДБОР ПАЛЛЕТ С АДРЕСА ДЛЯ ЗАКАЗА №'||D.DOC||'('||D.NUM_ACT||')'||
                DECODE(MOD(VVAL,B.BLCK),0,'ЦЕЛАЯ','НЕ ЦЕЛАЯ!')|| ' P-'||ST.ST_PALL_N|| V1310||
                 VVAL||' У.Е. ' ||
            DECODE(TRUNC(VVAL/B.BLCK),0,'',TRUNC(VVAL/B.BLCK) ||' ПАЛЛЕТ ') ||
            DECODE(MOD(VVAL,B.BLCK),0,'',MOD(VVAL,B.BLCK) || ' ' || DD_NOM_UNIT.TERM) || V1310
            ,
            N.CODE ||' '||N.NAME ||' '|| TO_CHAR(DT.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
            'ПЕРЕМЕСТИТЬ С АДРЕСА ' || ADDR_F.ADDR || V1310 ||
      --      DECODE(ADDR_T.ADDR,NULL,NULL,'НА АДРЕС ' || ADDR_T.ADDR || V1310 ) ||
            'ПАЛЛЕТЕЗАЦИЯ ' || B.BLCK
            ,DT.NOMENKLATURA_N
            ,'ПЕРЕМЕСТИТЬ С АДРЕСА ' || ADDR_F.ADDR,ST.CONTRAGENT_N,ST.STORE_N
             INTO PMSG,XMSG,VNOMN,VADDRFROM,VCONTRAGENTN,VSTOREN
      FROM ST_DOC_OUT_DET DT
       JOIN ST_STOCK ST ON (ST.ST_DOC_N = DT.N AND ST.TYP =6  AND SYSDATE BETWEEN ST.FD AND ST.TD AND ST.N =VSTSTOCKN )
       JOIN CELL_ADDRESS ADDR_F ON (VVAL2 = ADDR_F.N AND DT.FD BETWEEN  ADDR_F.FD AND ADDR_F.TD)
       JOIN ST_DOC_OUT D ON (D.N = DT.SQ_ST_DOC_OUT_N  AND SYSDATE BETWEEN D.FD AND D.TD )
       JOIN NOMENKLATURA N ON (DT.NOMENKLATURA_N = N.N AND DT.FD BETWEEN  N.FD AND N.TD)
       JOIN NOM_BLCK B ON (B.NOMENKLATURA_N = DT.NOMENKLATURA_N AND B.PALL_TYPE = ST.PALL_TYPE AND DT.FD BETWEEN B.FD AND B.TD)
       JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND ST.FD BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
         WHERE DT.N = VSTDOCN
          AND SYSDATE BETWEEN DT.FD AND DT.TD ;

  INSERT INTO ST_MESSAGES (GRP, VAL, VAL2, VAL3, VAL4 ) VALUES (32, VBASEDOCN, VJOBN, 32, '' );
   VOUTCELL :=   KK_ST_BARCODE5.GETCONSOLIDATIONCELLN(VCONTRAGENTN,VBASEDOCN,VADDRTO , VPALLN ) ;

           VADDRTO := 'НА АДРЕС ' ||VADDRTO;


       PMSG := PMSG ||  STOCKNBYNOMUNITS(VNOMN,VVAL)||V1310 ||
                           XMSG ||V1310 ||
                           VADDRTO ;

    VRET := 3;


  ELSE
  PMSG := '<ERR>ДЛЯ ДАННОГО ТИПА ЗАДАНИЙ НИЧЕГО НЕ РАЗРАБОТАНО! VSTDOCTYP="'||VSTDOCTYP||'"</ERR>';
   VRET := -1;
  END CASE;


       EXCEPTION
         WHEN NO_DATA_FOUND THEN
      --    RAISE_APPLICATION_ERROR(-20000,VSTDOCN||' '||VJOBN);
      KK_COMMON.ERR_LOG('GETSTBARCODEJOB',VJOBN, 'СОДЕРЖАНИЕ ЗАДАНИЯ ИЗМЕНЕНО. VSTDOCTYP='||VSTDOCTYP ||' DOC_DET_N='||VSTDOCN||' VSTSTOCKN='||VSTSTOCKN);
        PMSG := '<ERR>СОДЕРЖАНИЕ ЗАДАНИЯ ИЗМЕНЕНО. ВОЗЬМИТЕ ДРУГОЕ ЗАДАНИЕ!VJOBN='||VJOBN||'</ERR>';
         KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,VJOBN,0,0,NULL,NULL,NULL,999,SYSDATE,NULL,0);

            VRET := -2;
        END;



  IF VRET > 0 THEN

    --ДОПИСЫВАЕМ КОММЕНТАРИЙ К PMSG ЕСЛИ ЭТО НЕОБХОДИМО (ПО КОНСТАНТЕ И ПОЛЬЗОВАТЕЛЬСКОЙ ФУНКЦИИ)
   DECLARE
     VSTBARJOBSCOMMENTPROC LIST_CONST.VAL%TYPE;
     VSTBARJOBSCOMMENT VARCHAR2(2500);
   BEGIN
     VSTBARJOBSCOMMENTPROC := KK_CONST.GETCONSTV('STBARJOBSCOMMENT',SYSDATE);

     IF VSTBARJOBSCOMMENTPROC <> '_' THEN
       EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VSTBARJOBSCOMMENTPROC||'(:PJOBN, :PJOBTYP, :PCONTRAGENTN, :PSTOREN, :PNOMENKLATURAN, :PDOCTYP, :PCELADDRESS);  END;'
       USING OUT VSTBARJOBSCOMMENT, IN VJOBN, IN 12, IN VCONTRAGENTN, IN VSTOREN, IN VNOMN, IN VSTDOCTYP, IN 0;
       PMSG := PMSG ||V1310|| VSTBARJOBSCOMMENT;
     END IF;

   EXCEPTION
    WHEN OTHERS THEN
     NULL;
   END;
   -----------------------------------------------------------------------------------------------

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',SUBSTR(PMSG,1,500) );
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.N',VJOBN );


  PMSG := PMSG ||V1310 ||'ФИЛЬТР:'||KK_ST_BAR_JOBS.GETCONTEXTCONTRAGENTNAMEX(PROBJN);
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP,VAL4,VAL5,VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,17/*ЗАПОМНИЛИ НОМЕР ЗАДАНИЯ!!!*/,VJOBN,VSTDOCN,VSTDOCTYP,SYSDATE,KK_COMMON.GETTD,VVAL,0,SUBSTR(PMSG,1,500),VCONTRAGENTN,VSTOREN)
   RETURNING N INTO PPROCN;

   PMSG := PMSG /*||V1310*/ ||' ФИЛЬТР:'||KK_ST_BAR_JOBS.GETCONTEXTCONTRAGENTNAMEX(PROBJN);

 ELSE
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.DSC',NULL);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.N',0 );
  END IF;--IF VRET = 0 THEN



  RETURN  VRET;
 END IF;



END GETSTBARCODENEARJOB;


--KK_ST_BARCODE.INPUTPALLORNOM
FUNCTION INPUTPALLN(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VSTDOCN INTEGER;
VSTDOCTYP INTEGER;
VCELLADDRTO INTEGER;
VCNT INTEGER;
VPALLN INTEGER;
VJOBN INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VSTBARCODEMANUALPIDINPUT INTEGER := KK_PERMIT.EXISTSPERMIT(VEMPN,'STBARCODEMANUALPIDINPUT',SYSDATE);
VCHANGEJOBRESERVEPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CHANGEJOBRESERVE.USERPROC', SYSDATE);
BEGIN

IF VSTBARCODEMANUALPIDINPUT != 3 THEN
     IF PSTR IS NULL THEN
      RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ PID, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
     END IF;
END IF;


SELECT CASE WHEN INSTR(NVL(PSTR,'P-'||PKEYCODE),'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(NVL(PSTR,UPPER(PKEYCODE)),'P-','') ) INTO  VPALLN FROM DUAL;


SELECT VAL1,VAL2,VAL3,VAL4 INTO VJOBN,VSTDOCN,VSTDOCTYP,PMSG
  FROM MCIS_NODES_PROC P
   WHERE TYP = 17
    CONNECT BY PRIOR P.UP = P.N
      START WITH N = PPROCN ;



 BEGIN
   SELECT  ST.CELL_ADDRESS_N,ST.CNT
    INTO VCELLADDRTO ,VCNT
    FROM ST_STOCK ST
      WHERE ST.TD = KK_COMMON.GETTD
         AND ST.ST_PALL_N = VPALLN
         AND (ST.N IN
          (SELECT ST_STOCK_N
             FROM ST_BAR_JOBS
              WHERE N = VJOBN
                AND TD = KK_COMMON.GETTD))
   UNION ALL

   SELECT J.CELL_ADDRESS_N, J.CNT
   FROM ST_BAR_JOBS J
   WHERE J.ST_STOCK_N = -2
   AND J.N = VJOBN
   AND J.TD = KK_COMMON.GETTD
   AND J.ST_PALL_N = VPALLN;



--   PMSG := VTASKDSC;

 EXCEPTION
  WHEN NO_DATA_FOUND THEN

  IF PKEYCODE = '99' THEN
    IF VCHANGEJOBRESERVEPROC = '_' THEN
      KK_ST_BARCODE5.CHANGEJOBRESERVE(VJOBN ,VPALLN ,PROBJN ,1 );
    ELSE
      EXECUTE IMMEDIATE 'BEGIN '||VCHANGEJOBRESERVEPROC||'(:PJOBN, :PPALLN, :PROBJN, :PMAKECHANGE);END;'
        USING IN VJOBN ,IN VPALLN ,IN OUT PROBJN ,1;
    END IF;
    PMSG := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB.DSC');
  ELSE
  RAISE_APPLICATION_ERROR(-20000,'ДАННЫЕ НЕ НАЙДЕНЫ; VSTDOCN='||VSTDOCN||' VJOBN='||VJOBN);
--   PMSG := '<ERR>ПАЛЛЕТА '||VPALLN ||' НЕ ИЗ ЗАДАНИЯ! ''99'' ПЕРЕНЕСТИ РЕЗЕРВ НА ВЫБРАННУЮ ПАЛЛЕТУ VSTDOCN='||VSTDOCN||'; VPALLN='||VPALLN||'; VJOBN='||VJOBN||'</ERR>' || V1310 ||PMSG;
--   KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,VJOBN,0,0,NULL,NULL,NULL,999,SYSDATE,NULL,0);
    RETURN -1;
  END IF;


 END;

  INSERT INTO MCIS_NODES_PROC
    (N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP )
    VALUES
    (SQ_MCIS_NODES_PROC.NEXTVAL,18/*ЗАПОМНИЛИ НОМЕР ПАЛЛЕТЫ!!!*/,VCELLADDRTO,VSTDOCN,VCNT,VPALLN,SYSDATE,KK_COMMON.GETTD,'НОМЕР ПАЛЛЕТЫ',PPROCN)
    RETURNING N INTO PPROCN;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'PID', VPALLN);
  RETURN  1;

END;


FUNCTION INPUTPALLNINTOGATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VSTDOCN INTEGER;
VSTDOCTYP INTEGER;
VCELLADDRTO INTEGER;
VCNT INTEGER;
VPALLN INTEGER;
VJOBN INTEGER :=    KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_BAR_JOBS.N');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

SELECT CASE WHEN INSTR(NVL(PSTR,'P-'||PKEYCODE),'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


 SELECT TO_NUMBER(REPLACE(NVL(PSTR,UPPER(PKEYCODE)),'P-','') ) INTO  VPALLN FROM DUAL;


SELECT VAL1,VAL2,VAL3,VAL4 INTO VJOBN,VSTDOCN,VSTDOCTYP,PMSG
  FROM MCIS_NODES_PROC P
   WHERE TYP = 17
    CONNECT BY PRIOR P.UP = P.N
      START WITH N = PPROCN ;



 BEGIN

     SELECT GATE_CELL_N
     INTO VCELLADDRTO
     FROM ST_BAR_JOBS S
     JOIN ST_DOC_OUT D ON (S.BASE_DOC_N = D.N AND D.TD = KK_COMMON.GETTD)
     WHERE S.N = VJOBN
       AND S.STATUS = 2
       AND S.TD = KK_COMMON.GETTD
       AND S.ST_PALL_N = VPALLN;
--     SQ_ST_DOC_OUT_N

/*   SELECT  ST.CELL_ADDRESS_N,ST.CNT
    INTO VCELLADDRTO ,VCNT
    FROM ST_STOCK ST
      WHERE ST.ST_DOC_N =  VSTDOCN
         AND SYSDATE BETWEEN ST.FD AND ST.TD
         AND ST.ST_PALL_N = VPALLN
         AND ST.N IN
          (SELECT ST_STOCK_N
             FROM
             ST_BAR_JOBS
            WHERE
                 N = VJOBN
             AND SYSDATE BETWEEN FD AND TD)  ; */





--   PMSG := VTASKDSC;

 EXCEPTION
  WHEN NO_DATA_FOUND THEN

--  IF PKEYCODE = '99' THEN
--   KK_ST_BARCODE5.CHANGEJOBRESERVE(VJOBN ,VPALLN ,PROBJN ,1 );
--    PMSG := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB.DSC');
--  ELSE
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТА ПАЛЛЕТА НЕ ИЗ ЗАДАНИЯ!</ERR>');
   PMSG := '<ERR>ПАЛЛЕТА '||VPALLN ||' НЕ ИЗ ЗАДАНИЯ! </ERR>' || V1310 ||PMSG;
    RETURN -1;
--  END IF;


 END;

 INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,18/*ЗАПОМНИЛИ НОМЕР ПАЛЛЕТЫ!!!*/,VCELLADDRTO,VSTDOCN,VCNT,VPALLN,SYSDATE,KK_COMMON.GETTD,'НОМЕР ПАЛЛЕТЫ',PPROCN)
   RETURNING N INTO PPROCN;

  RETURN  1;

END INPUTPALLNINTOGATE;


FUNCTION CHEQUEFORNOMONADDR(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
--VCNTN INTEGER;
VCELLADDRESSN INTEGER;
VDOCTYP INTEGER;
VDOCN INTEGER;
VRET INTEGER := 1;
VCNT INTEGER;
VCELL_ADDRESS_N INTEGER;
VCELL_ADDRESS_NEW_N INTEGER;
VEXPIRE_DATE DATE;
VNEWADDRESSNAME VARCHAR2(255);
VNOMNAME VARCHAR2(255);
VSTOREN INTEGER;
VST_PALL_N INTEGER;
VVAL4 MCIS_NODES_PROC.VAL4%TYPE;
VCELLADDRESSNAME MCIS_NODES_PROC.VAL4%TYPE;
VJOBN INTEGER;
VDSC VARCHAR2(500);
VJOBNOMENKLATURAN INTEGER;
VNOMENKLATURAN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VCONTRAGENTN INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
PMSG := NULL;
--RAISE_APPLICATION_ERROR(-20000,PPROCN);
FOR J IN (
      SELECT TYP,VAL1,VAL2,VAL3,DSC,VAL4
         FROM   MCIS_NODES_PROC
           CONNECT BY PRIOR UP = N
  START WITH N= PPROCN
  ORDER BY LEVEL DESC ) LOOP
CASE
  WHEN J.TYP = 13 THEN VCELLADDRESSN := J.VAL1;
                       VCELLADDRESSNAME := J.VAL4;
                       VSTOREN := J.VAL2;
  WHEN J.TYP = 17 THEN VDOCN   := J.VAL2;
                       VDOCTYP := J.VAL3;
                       VCNT    := J.DSC;
                       VVAL4 := J.VAL4;
                       VJOBN:= J.VAL1;
  ELSE
                      NULL;
END CASE;

END LOOP;

--RAISE_APPLICATION_ERROR(-20000,VDOCTYP||PPROCN);
BEGIN

CASE
  WHEN VDOCTYP = 3 THEN -- ПЕРЕМЕЩЕНИЕ

     SELECT DT.NOMENKLATURA_N
           ,J.VAL2 AS CELL_ADDRESS_N
           ,DT.CELL_ADDRESS_NEW_N
           ,DT.EXPIRE_DATE
           ,'НОМ:'||N.CODE ||' КОЛ-ВО'|| DT.CNT
           ,J.CONTRAGENT_N
           INTO
            VJOBNOMENKLATURAN
           ,VCELL_ADDRESS_N
           ,VCELL_ADDRESS_NEW_N
           ,VEXPIRE_DATE
           ,VDSC
           ,VCONTRAGENTN
      FROM ST_DOC_MOVE_DET DT
       JOIN ST_BAR_JOBS J ON (J.TYP = 3 AND J.STATUS = 2 AND SYSDATE BETWEEN J.FD AND J.TD AND J.ST_DOC_N = VDOCN AND J.N= VJOBN)
       JOIN NOMENKLATURA N ON (N.N = DT.NOMENKLATURA_N AND SYSDATE BETWEEN N.FD AND N.TD)
         WHERE DT.N = VDOCN
          AND SYSDATE BETWEEN DT.FD AND DT.TD;
      IF KK_CONST.GETCONSTN('REPLENISHMENT.NEEDINPUTNOM', SYSDATE, VCONTRAGENTN) = 1 AND VNOMENKLATURAN != VJOBNOMENKLATURAN THEN
           RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТОN ТОВАР НЕ ИЗ ЗАДАНИЯ!</ERR>');
      END IF;

 ------------------------------------WHEN VDOCTYP = 3 THEN -- ПЕРЕМЕЩЕНИЕ
  WHEN VDOCTYP = 1 THEN -- ПОДБОРКА ЗАКАЗОВ

     SELECT
          DT.NOMENKLATURA_N ,J.VAL2 AS CELL_ADDRESS_N
           ,D.OUT_CELL_N AS CELL_ADDRESS_NEW_N
           ,ST.EXPIRE_DATE
           ,'НОМ:'||N.CODE ||' КОЛ-ВО'|| DT.CNT
           INTO
            VJOBNOMENKLATURAN
           ,VCELL_ADDRESS_N
           ,VCELL_ADDRESS_NEW_N
           ,VEXPIRE_DATE
           ,VDSC
      FROM ST_DOC_OUT_DET DT
       JOIN ST_BAR_JOBS J ON (J.TYP = 32 AND J.STATUS = 2 AND SYSDATE BETWEEN J.FD AND J.TD
                         AND J.ST_DOC_N = VDOCN
                         AND J.N= VJOBN)
      JOIN NOMENKLATURA N ON (N.N = DT.NOMENKLATURA_N AND SYSDATE BETWEEN N.FD AND N.TD)
       JOIN ST_STOCK ST ON (ST.TYP = 6 AND  SYSDATE BETWEEN ST.FD AND ST.TD AND ST.ST_DOC_N = DT.N AND ST.N = J.ST_STOCK_N )
       JOIN ST_DOC_OUT D ON (DT.SQ_ST_DOC_OUT_N = D.N AND SYSDATE BETWEEN D.FD AND D.TD )
         WHERE DT.N = VDOCN
          AND SYSDATE BETWEEN DT.FD AND DT.TD;


 ------------------------------------WHEN VDOCTYP = 1 THEN-- ПОДБОРКА ЗАКАЗОВ
  WHEN VDOCTYP = 500 THEN
    SELECT J.CELL_ADDRESS_NEW_N INTO VCELL_ADDRESS_NEW_N
    FROM ST_BAR_JOBS J
    WHERE J.N = VJOBN
    AND J.TD = KK_COMMON.GETTD;
END CASE;

    EXCEPTION
        WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
        PMSG := PMSG ||V1310||
          'ОШИБКА'||SQLERRM;
        VRET := -1;
    END;
    -- RAISE_APPLICATION_ERROR(-20000,'<ERR>22222-'||KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT')||'</ERR>');

          IF NOT ( VCELL_ADDRESS_N  = VCELLADDRESSN OR /*ЛИБО СКАНИРОВАЛИ ЧТО НУЖНО, ЛИБО СКАНИРОВАЛИ 0, НО МОЖНО ИГНОРИРОВАТЬ ВВОД - ТОГДА НОРМ.*/
                    ( VCELLADDRESSN=0 AND (1=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT')))
                  )
          THEN
           RAISE_APPLICATION_ERROR(-20000,'<ERR>ВЫ СКАНИРОВАЛИ НЕ ТОТ АДРЕС НАЧАЛЬНЫЙ АДРЕС!</ERR>');
          END IF;


         IF VRET > 0 THEN
           SELECT ADDR INTO VNEWADDRESSNAME
              FROM  CELL_ADDRESS
                WHERE N =VCELL_ADDRESS_NEW_N
                 AND SYSDATE BETWEEN FD AND TD;

          PMSG := PMSG ||V1310||
              VVAL4 ||V1310||
              VDSC  ||V1310||
          'НА АДРЕС '||VNEWADDRESSNAME;
          VRET := 1;
         END IF;




  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,28,VCELL_ADDRESS_NEW_N,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ПРОВЕРЯЕМ НОМЕНКЛАТУРУ НА АДРЕСЕ',PPROCN)
   RETURNING N INTO PPROCN;


RETURN  VRET;
END CHEQUEFORNOMONADDR;


FUNCTION CELLEXISTSANDCANGET(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
 VCELLEXISTSANDCANGETPROC VARCHAR2(255);
 VRET INTEGER;
BEGIN

 VCELLEXISTSANDCANGETPROC:= NVL(KK_CONST.GETCONSTV('CELLEXISTSANDCANGET.USERPROC',SYSDATE, NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0)),'_');
  IF NVL(VCELLEXISTSANDCANGETPROC, '_') = '_'  THEN
        VRET := KK_ST_BARCODE.CELLEXISTSANDCANGET_DEF(PKEYCODE,PSTR, PMSG,PNEXTNODE,PPROCN,PROBJN);
     ELSE
        EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VCELLEXISTSANDCANGETPROC||'(:PKEYCODE,:PSTR ,:PMSG ,:PNEXTNODE,:PPROCN,:PROBJN);  END;'
  USING OUT VRET, IN PKEYCODE, IN PSTR, IN OUT PMSG, IN OUT PNEXTNODE,IN OUT PPROCN,IN OUT PROBJN;
     END IF;

RETURN VRET;

END CELLEXISTSANDCANGET;

FUNCTION CELLEXISTSANDCANGET_DEF(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNEWCELL INTEGER := NULL;
VNEWCELLDT INTEGER;
VJOBN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_BAR_JOBS.N');
VSTDOCN INTEGER;
VCELL_TYP_N INTEGER;
VCELLADDR CELL_ADDRESS.ADDR%TYPE;
VOUTADDRNAME CELL_ADDRESS.ADDR%TYPE;
VJOBTYP INTEGER;
VSTOREN INTEGER;
VSTORENX INTEGER;
VRET INTEGER;
VPRINTERN INTEGER;
VBASEDOCN INTEGER;
VCONTRAGENTN INTEGER;
VCNT INTEGER;
VSTSTOCKN INTEGER;
VSTPALLN INTEGER;
VNOMENKLATURAN INTEGER;
VCELLADDRN INTEGER;
VJOBBLOCK INTEGER;
VEMPN  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VPICKCNT INTEGER;
VSTOCKCNT INTEGER;
VSTDOCOUTCANPUTONTRANSIT INTEGER;
/*ЕСЛИ ВВЕЛИ ВЕС ПАЛЛЕТЫ 0 - ТО МОЖЕМ ПОСТАВИТЬ НА ТРАНЗИТНУЮ ЯЧЕЙКУ
+ СОЗДАЕМ ЗАДАНИЕ НА ПЕРЕМЕЩЕНИЕ МАКРОПИДА */
VPALLN INTEGER    :=NVL( KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID'),0);
VPALLWEIGHT NUMBER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PALL.WEIGHT');
VJOBPIDN INTEGER;
VJOBPACKPALL INTEGER;
VSTDOCMOVEN INTEGER;
VEXPIREDATE DATE;
VCELLTYPS VARCHAR2(255);
VPALL_TYP INTEGER;
VSIZE_ NUMBER;
VEMPTY NUMBER;
VPALLCNT INTEGER;
VJOBCELLTYP INTEGER;
VTASKPRIORITY INTEGER ;
VLEFTOFADDRESS NUMBER;
VJOBN_NEW NUMBER;
VSTATUS NUMBER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
VLEFTJOBSCNT NUMBER;
VPICKJOBGRP NUMBER;
BEGIN

FOR J IN (      SELECT TYP,VAL1,VAL2
          FROM   MCIS_NODES_PROC
           WHERE TYP  IN (17,13,111)
           CONNECT BY PRIOR UP = N
  START WITH N= PPROCN
  ORDER BY LEVEL  ) LOOP

CASE WHEN J.TYP = 13 AND VNEWCELL IS NULL  THEN
            VNEWCELL :=J.VAL1;
            VSTOREN :=J.VAL2;

     WHEN J.TYP = 17 AND VSTDOCN IS NULL THEN
            VSTDOCN := J.VAL2;
            EXIT;

     WHEN J.TYP = 111 AND VPRINTERN IS NULL THEN
            VJOBTYP := J.VAL1;
            VPRINTERN :=J.VAL2;
     ELSE
          NULL;
     END CASE;

END LOOP;


--RAISE_APPLICATION_ERROR(-20000,VNEWCELL||'_'||VJOBN);

IF (VNEWCELL IS NOT NULL) AND (VJOBN IS NOT NULL) THEN

    DECLARE
    VMOVEPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCMOVE.MOVECOMPLETE.USERCHEQUEPROC',SYSDATE,VCONTRAGENTN);
    BEGIN






     IF LENGTH(VMOVEPROC) >1 THEN
       EXECUTE IMMEDIATE 'BEGIN '||VMOVEPROC||'(:VCONTRAGENTN , :VJOBN , :VNEWCELL); END;'
          USING IN VCONTRAGENTN , IN VJOBN , IN VNEWCELL ;
     END IF ; --IF LENGTH(VMOVEPROC) >1 THEN

    END;

    --RAISE_APPLICATION_ERROR(-20000,'_'||VJOBN||'_');
SELECT J.TYP, J.BASE_DOC_N, J.CONTRAGENT_N , ST.CNT , J.ST_STOCK_N, J.ST_PALL_N, J.NOMENKLATURA_N, J.VAL2, J.JOB_BLOCK ,ST.STORE_N , ST.EXPIRE_DATE , J.PRIORITY, J.STATUS, N.PICK_JOB_GRP
INTO
    VJOBTYP ,   VBASEDOCN ,   VCONTRAGENTN ,   VCNT,VSTSTOCKN,VSTPALLN,VNOMENKLATURAN,VCELLADDRN,VJOBBLOCK , VSTORENX ,VEXPIREDATE ,VTASKPRIORITY, VSTATUS, VPICKJOBGRP
 FROM ST_BAR_JOBS J
  LEFT JOIN ST_STOCK ST ON ( ST.N = J.ST_STOCK_N AND SYSDATE BETWEEN ST.FD AND ST.TD)
  LEFT JOIN NOMENKLATURA N ON (N.N = J.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
  WHERE J.N = VJOBN
   --AND SYSDATE BETWEEN FD AND TD
   ;


  CASE
    WHEN VJOBTYP =3 THEN
      SELECT D.CELL_ADDRESS_NEW_N, A.CELL_TYP_N INTO VNEWCELLDT, VJOBCELLTYP
        FROM ST_DOC_MOVE_DET D
        JOIN CELL_ADDRESS A ON (A.N = D.CELL_ADDRESS_NEW_N AND A.TD = KK_COMMON.GETTD)
        WHERE D.N = VSTDOCN
          AND SYSDATE BETWEEN D.FD AND D.TD;
      VRET := 1; -- MOVE DOC
    WHEN VJOBTYP  IN (32,12) THEN
      VNEWCELLDT := KK_ST_BARCODE5.GETCONSOLIDATIONCELLN(VCONTRAGENTN,VBASEDOCN,VOUTADDRNAME,VSTPALLN);


      IF KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOBBYDOC.DOC_N')>0 THEN
       VRET:=4; --ЗАДАНИЕ ПО КОНКРЕТНОМУ ЗАКАЗУ
      ELSE
       VRET := 2;-- ST_DOC_OUT
      END IF;
      SELECT COUNT(*)
        INTO VLEFTJOBSCNT
        FROM ST_BAR_JOBS J
        WHERE J.BASE_DOC_N = VBASEDOCN
          AND J.JOB_BLOCK = VJOBBLOCK
          AND J.STATUS IN (1,2);
      IF VLEFTJOBSCNT = 0 AND KK_CONST.GETCONSTN('STDOCOUT.FINEPICK.TO6MENU', SYSDATE, VPICKJOBGRP) = 1 THEN
        VRET := 3;
      END IF;
    ELSE
      RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕИЗВЕСТНЫЙ ТИП ЗАДАНИЯ '||VJOBTYP||'</ERR>');
    END CASE;



-------------ПРОВЕРКА РАЗМЕРА ЯЧЕЙКИ.
     IF (KK_CONST.GETCONSTN('STDOCMOVE.CHECKCELLSIZE',SYSDATE, VCONTRAGENTN) = 1) AND (KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CHECKINPUTCELLADDRESS',SYSDATE) != 3) THEN

      --(PCELLADDRESSN,PSIZE,PCEILCELL,PCELLADDRPALLTYP,PSTOREN,PNOMENKLATURAN,PSTDOCMOVEN,PRAISE,PPALLN,PVALUETOALLOC)
         SELECT
         KK_ST_ALLOC.GETLEFTOFADDRESS(CA.N,CA.SIZE_,0,CA.PALL_TYP,CA.STORE_N,0,VSTDOCN,0,VPALLN,0/*,1*/) INTO VLEFTOFADDRESS
           FROM CELL_ADDRESS CA
            WHERE CA.N = VNEWCELL
              AND CA.TD = KK_COMMON.GETTD;

                   IF VLEFTOFADDRESS  + KK_CONST.GETCONSTN('STDOCMOVE.LEFTOFADDRFILLLIMITPCT',SYSDATE,VCONTRAGENTN ) < 1  THEN
            RAISE_APPLICATION_ERROR(-20000,'<ERR> ЯЧЕЙКА ЗАПОЛНЕНА! </ERR>');
         END IF;
    END IF;
---------------------------------
  IF VNEWCELLDT != VNEWCELL THEN

   IF VJOBTYP  IN (32,12,3) THEN

   SELECT CELL_TYP_N,ADDR
    INTO VCELL_TYP_N,VCELLADDR
     FROM CELL_ADDRESS
      WHERE
        N =VNEWCELL
     AND SYSDATE BETWEEN FD AND TD ;

   --  COMMIT;
  --   RAISE_APPLICATION_ERROR(-20000,PPROCN||' '||VNEWCELLDT ||' '|| VNEWCELL||' '||VSTOREN||' '||VSTORENX);

      IF VSTORENX != VSTOREN THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА ПРИНАДЛЕЖИТ ДРУГОМУ СКЛАДУ!</ERR>');
      END IF; --  IF VSTORENX != VSTOREN THEN -- ТРАНЗИТНАЯ

      IF VCELL_TYP_N = -5 THEN
        --РМ.ЗАКАЗЫ.ПОДБОР ПО ТЕРМИНАЛУ.ВОЗМОЖНОСТЬ ВВЕСТИ ДРУГУЮ ЯЧЕЙКУ КОНСОЛИДАЦИИ
        IF KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCOUTSUBMITOTHERCONSOLIDATIONCELL',SYSDATE) != 3 THEN
          RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕ ТА ЯЧЕЙКА КОНСОЛИДАЦИИ! СКАНИРУЙТЕ ЯЧЕЙКУ '||VOUTADDRNAME||'; STDOCOUTSUBMITOTHERCONSOLIDATIONCELL='
            ||KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCOUTSUBMITOTHERCONSOLIDATIONCELL',SYSDATE)||'</ERR>'||VNEWCELLDT ||' '|| VNEWCELL);
        END IF;
        IF VJOBTYP  IN (32,12) THEN
           UPDATE ST_DOC_OUT_PICK
            SET CELL_ADDRESS_N = VNEWCELL
             WHERE ST_DOC_OUT_N = VBASEDOCN
           AND ST_PALL_N = VSTPALLN
           AND TD = KK_COMMON.GETTD;
        END IF;
      END IF;


      --МОЛОЧНИКОВ, ДОБАВЛЕНА КОНСТАНТА НА ВЫБОР ТИПОВ ЯЧЕЕК ДЛЯ КОНСОЛИДАЦИИ
      SELECT KK_CONST.GETCONSTV('CELLTYPFORCONSOLIDATIONCELL',SYSDATE,VCONTRAGENTN) INTO VCELLTYPS FROM DUAL;

     IF VJOBCELLTYP != VCELL_TYP_N AND VJOBTYP =3
      AND VCELL_TYP_N != -2 THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>ТИП ЯЧЕЙКИ ДОЛЖЕН БЫТЬ ТЕМ ЖЕ ЧТО И В ЗАДАНИИ ИЛИ ТРАНЗИТНОЙ VJOBCELLTYP='||VJOBCELLTYP||'; VCELL_TYP_N='||VCELL_TYP_N||'<ERR>');
      END IF;

      IF
      -- МОЛОЧНИКОВ
      --VCELL_TYP_N NOT IN( -2, -5)
      INSTR(VCELLTYPS,','||VCELL_TYP_N||',')=0
      AND
      (VJOBTYP =3 AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCMOVEPUTONOTHERCELL',SYSDATE) != 3
      OR VJOBTYP  IN(12,32) )
       THEN -- НЕ ТРАНЗИТНАЯ
       RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА '||VCELLADDR||' ОТЛИЧАЕТСЯ ОТ ЯЧЕЙКИ В ЗАДАНИИ, И НЕ ЯВЛЯЕТСЯ ТРАНЗИТНОЙ ИЛИ НЕТ ДОСТУПА STDOCMOVEPUTONOTHERCELL "'||KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCMOVEPUTONOTHERCELL',SYSDATE)||'"!!</ERR>'||VNEWCELLDT ||' '|| VNEWCELL);
      END IF; --  IF VCELL_TYP_N != -2 THEN -- ТРАНЗИТНАЯ

--RAISE_APPLICATION_ERROR(-20001,VJOBN);
      IF VCELL_TYP_N = -2 THEN -- ТРАНЗИТНАЯ
      /*ЕСЛИ ВВЕЛИ ВЕС ПАЛЛЕТЫ 0 - ТО МОЖЕМ ПОСТАВИТЬ НА ТРАНЗИТНУЮ ЯЧЕЙКУ
        + СОЗДАЕМ ЗАДАНИЕ НА ПЕРЕМЕЩЕНИЕ МАКРОПИДА */
       IF NVL(VPALLWEIGHT,0) = 0  THEN
          IF NVL(VPALLN,-999) > 0 THEN
             KK_ST_BARCODE9.CREATEMACROPIDJOB(VBASEDOCN,VPALLN,VNEWCELL ,VNEWCELLDT ,VEMPN);
          END IF;

        ---------------------------------------
        -- ПРИ ПЕРЕМЕЩЕНИИ И СКАНИРОВАНИИ ТРАНЗИТА СТАВИТЬ СТОК НА ТРАНЗИТ, СОЗДАВАТЬ ЗАДАНИЕ С ТРАНЗИТА НА АДРЕС НАЗНАЧЕНИЯ
--RAISE_APPLICATION_ERROR(-20001,VNEWCELL||'-'||VNEWCELLDT);
        ------------------------------------------------------------------------

       ELSE
          VSTDOCOUTCANPUTONTRANSIT := KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCOUTCANPUTONTRANSITCELL',SYSDATE) ;
          IF  VSTDOCOUTCANPUTONTRANSIT !=3 AND
           INSTR(KK_CONST.GETCONSTV('STDOCOUT.FINEPICK.TRANSIT.ALLOWEDLIST',SYSDATE,VCONTRAGENTN),','||VNEWCELL||',')  = 0
          THEN
            RAISE_APPLICATION_ERROR(-20000,'<ERR>У ВАС НЕТ ДОСТУПА ПОМЕЩЕНИЯ НА ТРАНЗИТНУЮ ЯЧЕЙКУ STDOCOUTCANPUTONTRANSITCELL !</ERR>');
          END IF;

---------------------------------------------------------------
       KK_ST_BARCODE9.CREATEMACROPIDJOB(VBASEDOCN  ,VPALLN ,VNEWCELL ,VNEWCELLDT ,VEMPN );

------------------------------------------------------------------
/*

        SELECT CA.SIZE_ , CA.CELL_TYP_N INTO VSIZE_, VCELL_TYP_N  FROM CELL_ADDRESS CA WHERE CA.N = VNEWCELL AND SYSDATE BETWEEN CA.FD AND CA.TD;
        SELECT P.PALL_TYPE_N  INTO  VPALL_TYP  FROM  PALL P WHERE P.N = VPALLN AND SYSDATE BETWEEN P.FD AND P.TD;
        IF VSIZE_ <> 0  THEN
            SELECT  KK_ST_ALLOC.GETLEFTOFADDRESS(VNEWCELL, VSIZE_,0,VPALL_TYP,VSTOREN, 0, 1, 0, VPALLN)
                 INTO  VEMPTY FROM DUAL;
        END IF;
*/
      END IF;
      IF VJOBTYP  IN (3, 32) THEN
        KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN =>PROBJN, PJOBN =>VJOBN, PJOBTYP =>0, PJOBDOCN =>0, PVAL1 =>NULL
                                , PDSC =>'ТРАНЗИТНАЯ '||VCELLADDR, PVAL2 =>VNEWCELL, PSTATUS=> 1, PTD =>KK_COMMON.GETTD, PEMPN=>0
                                , PRECREATESTATUS=>3, PCELLADDRESSN=>VNEWCELL);
        VJOBN_NEW:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOBNEW.N');
      END IF;
        PMSG := 'ЗАДАНИЕ УСПЕШНО ВЫПОЛНЕНО'||V1310||
        'ВЫ ПОМЕСТИЛИ НА ТРАНЗИТНУЮ ЯЧЕЙКУ '||VCELLADDR||V1310||
        'СОЗДАНО ДОПОЛНИТЕЛЬНОЕ ЗАДАНИЕ НА ПЕРЕМЕЩЕНИЕ С ТРАНЗИТНОЙ ЯЧЕЙКИ';

        SELECT NVL(DT.ST_DOC_MOVE_N,0) INTO VSTDOCMOVEN
        FROM ST_BAR_JOBS J
            LEFT OUTER JOIN ST_DOC_MOVE_DET DT ON(DT.N = J.ST_DOC_N AND SYSDATE BETWEEN DT.FD AND DT.TD)
        WHERE J.N =VJOBN;

        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_MOVE.N',VSTDOCMOVEN);

      END IF; --IF VCELL_TYP_N = -2 THEN -- ТРАНЗИТНАЯ


     IF VJOBTYP  IN (3) AND VCELL_TYP_N NOT IN( -2, -5) THEN
      KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN =>PROBJN,PJOBN =>VJOBN
      ,PJOBTYP =>0,PJOBDOCN =>0,PVAL1 =>NULL,PDSC =>'НА ДРУГОЙ '||VCELLADDR,PSTATUS=> 3
      ,PTD =>SYSDATE,PEMPN=>VEMPN,PRECREATESTATUS=>0,PCELLADDRESSN=>VNEWCELL);

     PMSG := 'ЗАДАНИЕ УСПЕШНО ВЫПОЛНЕНО'||V1310||
     'ВЫ ПОМЕСТИЛИ НА ДРУГОЙ АДРЕС '||VCELLADDR||V1310;

     SELECT NVL(DT.ST_DOC_MOVE_N,0) INTO VSTDOCMOVEN
     FROM ST_BAR_JOBS J
            LEFT OUTER JOIN ST_DOC_MOVE_DET DT ON(DT.N = J.ST_DOC_N AND SYSDATE BETWEEN DT.FD AND DT.TD)
     WHERE J.N =VJOBN;

     PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_MOVE.N',VSTDOCMOVEN);

     END IF;

    ELSE -- IF VJOBTYP  IN (32,3,12) THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ТИП ЗАДАНИЯ НЕ ОПИСАН VJOBTYP ='||VJOBTYP ||'</ERR>' );
--     RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕ ТА ЯЧЕЙКА!!! СКАНИРУЙТЕ '||VOUTADDRNAME||'</ERR> VJOBTYP ='||VJOBTYP);
    END IF ;  -- IF VJOBTYP  IN (32,3,12) THEN

  END IF; --IF VNEWCELLDT != VNEWCELL THEN

--  RAISE_APPLICATION_ERROR(-20000, 'TEST'||KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCOUTSUBMITOTHERCONSOLIDATIONCELL',SYSDATE));
  IF VNEWCELLDT = VNEWCELL OR
  (    VNEWCELLDT != VNEWCELL
   AND VJOBTYP IN (32,12)
   AND (KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCOUTSUBMITOTHERCONSOLIDATIONCELL',SYSDATE) = 3
       --РМ.ЗАКАЗЫ.ПОДБОР ПО ТЕРМИНАЛУ.ВОЗМОЖНОСТЬ ВВЕСТИ ДРУГУЮ ЯЧЕЙКУ КОНСОЛИДАЦИИ
      OR INSTR(KK_CONST.GETCONSTV('STDOCOUT.FINEPICK.TRANSIT.ALLOWEDLIST',SYSDATE,VCONTRAGENTN),','||VNEWCELL||',') > 0
        -- МОЖНО НА ДРУГУЮ ЭТУ ЯЧЕЙКУ
       )
   ) THEN

        IF (VJOBTYP IN (32,12))
        AND (VPRINTERN = 0)
        AND KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STDOCOUT.SKIPPRINTBLANKOUT',SYSDATE) <> 3
         THEN
         PMSG := '<ERR>ВЫ ОБЯЗАННЫ РАСПЕЧАТАТЬ НАКЛЕЙКУ НА ПАЛЛЕТУ! KK_ST_BARCODE</ERR>';
         RETURN -2;
        END IF;


    IF VJOBTYP  IN (32,12) THEN
      IF VSTATUS != 3 THEN
        KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN =>PROBJN,PJOBN =>VJOBN,PJOBTYP =>0,PJOBDOCN =>0,PVAL1 =>VCNT,PDSC =>NULL,PVAL2 =>VNEWCELL);
      END IF;



FOR J IN (

WITH J AS (

   SELECT J.ST_STOCK_N , J.BASE_DOC_N, J.N , J.NOMENKLATURA_N ,J.VAL1
       FROM ST_BAR_JOBS J
    CONNECT BY PRIOR J.ST_STOCK_N = J.UP AND J.STATUS != 999 AND J.TYP = VJOBTYP --AND J.TD=KK_COMMON.GETTD
        START WITH
            J.N = VJOBN
         AND J.TYP = VJOBTYP
         AND J.UP = 0
    UNION ALL
SELECT J.ST_STOCK_N ,  J.BASE_DOC_N, J.N , J.NOMENKLATURA_N ,J.VAL1
       FROM ST_BAR_JOBS J
        WHERE
            J.N = VJOBN
         AND J.TYP = VJOBTYP
         AND J.UP = -1

)
 SELECT J.ST_STOCK_N ,  J.BASE_DOC_N , J.N , J.NOMENKLATURA_N, P.ROWID AS RD ,S.EXPIRE_DATE ,S.MAKE_DATE,J.VAL1
        ,P.N AS PICK_N
  FROM J
              JOIN ST_STOCK S ON (S.N = J.ST_STOCK_N)
   LEFT OUTER JOIN ST_DOC_OUT_PICK P ON (P.ST_DOC_OUT_N =  J.BASE_DOC_N
    AND P.STOCK_N = J.ST_STOCK_N
    AND P.TD = KK_COMMON.GETTD )
   WHERE 1=1

) LOOP

DECLARE
 VPICKN INTEGER ;
BEGIN

 IF J.RD IS NULL THEN

             INSERT INTO ST_DOC_OUT_PICK
              (N,ST_DOC_OUT_N,EXPIRE_DATE,MAKE_DATE,CNT,STOCK_N,ST_PALL_N,FD,TD,NOMENKLATURA_N,ST_JOB_N,CELL_ADDRESS_N,CHEQUE_EMP_N,CHEQUE_DATE)
             VALUES
              (SQ_ST_DOC_OUT_PICK.NEXTVAL,J.BASE_DOC_N,J.EXPIRE_DATE,J.MAKE_DATE,J.VAL1,J.ST_STOCK_N,VSTPALLN,SYSDATE,KK_COMMON.GETTD,J.NOMENKLATURA_N,J.N,VNEWCELL,0,NULL)
              RETURNING N INTO VPICKN;

   KK_COMMON.ACTION(VEMPN,'ST_DOC_OUT_PICK',VPICKN,1,SYSDATE,'CELLEXISTSANDCANGET 1');
 ELSE --IF J.RD IS NULL THEN

   UPDATE ST_DOC_OUT_PICK
            SET CELL_ADDRESS_N = VNEWCELL
             WHERE ROWID = J.RD;

   KK_COMMON.ACTION(VEMPN,'ST_DOC_OUT_PICK',J.PICK_N,3,SYSDATE,'CELLEXISTSANDCANGET 2');

 END IF; --IF J.RD IS NULL THEN
END; --DECLARE

END LOOP; --FOR J IN (

           UPDATE ST_DOC_OUT_PICK
            SET CELL_ADDRESS_N = VNEWCELL
             WHERE ST_DOC_OUT_N = VBASEDOCN
           AND ST_PALL_N = VSTPALLN
           AND TD = KK_COMMON.GETTD;

/*
        SELECT COUNT(1) INTO VPICKCNT
         FROM ST_DOC_OUT_PICK
          WHERE ST_DOC_OUT_N = VBASEDOCN
           AND STOCK_N = VSTSTOCKN
        --   AND ST_PALL_N = VSTPALLN  --ИНАЧЕ РВЕТ ПРОВЕРКА УНИКАЛЬНОСТИ ПРИ ВСТАВКЕ НИЖЕ
           AND SYSDATE BETWEEN FD AND TD;



         IF VPICKCNT = 0 THEN


           SELECT COUNT(1) INTO VSTOCKCNT  --ВОЗМОЖНО ТАКОЕ ЧТО В UNRESERVEANDJOBCOMPLETE
           FROM ST_STOCK                   --УДАЛИЛИ ST_STOCK У ЗАДАНИЯ ПРИ ЕГО ОТМЕНЕ
           WHERE N = VSTSTOCKN;            --НА УДАЛЕННЫЙ СТОК ПОДБОРКУ НЕ СОЗДАЕМ

           IF VSTOCKCNT > 0 THEN

             INSERT INTO ST_DOC_OUT_PICK
              (N,ST_DOC_OUT_N,EXPIRE_DATE,CNT,STOCK_N,ST_PALL_N,FD,TD,NOMENKLATURA_N,ST_JOB_N,CELL_ADDRESS_N,CHEQUE_EMP_N,CHEQUE_DATE)
             VALUES
              (SQ_ST_DOC_OUT_PICK.NEXTVAL,VBASEDOCN,VEXPIREDATE,VCNT,VSTSTOCKN,VSTPALLN,SYSDATE,KK_COMMON.GETTD,VNOMENKLATURAN,VJOBN,VNEWCELL,0,NULL);

           END IF;

         ELSE -- IF VPICKCNT = 0 THEN

           UPDATE ST_DOC_OUT_PICK
            SET CELL_ADDRESS_N = VNEWCELL
             WHERE ST_DOC_OUT_N = VBASEDOCN
           AND ST_PALL_N = VSTPALLN
           AND SYSDATE BETWEEN FD AND TD;



          END IF; --  IF VPICKCNT = 0 THEN

*/

  IF VJOBTYP  IN (12) THEN

     UPDATE ST_STOCK S
      SET S.CELL_ADDRESS_N = VNEWCELL
      , S.ST_PALL_N = VSTPALLN
        WHERE S.N IN
        ( SELECT J.ST_STOCK_N
             FROM ST_BAR_JOBS J
              WHERE J.BASE_DOC_N = VBASEDOCN
                AND J.JOB_BLOCK  = VJOBBLOCK
                AND J.TYP = 12
                AND J.STATUS IN (3) )
           AND S.TYP IN (6,17,7);

          UPDATE ST_BAR_JOBS J
           SET J.VAL2 =   VNEWCELL
              WHERE J.BASE_DOC_N = VBASEDOCN
                AND J.JOB_BLOCK  = VJOBBLOCK
                AND J.TYP = 12
                AND J.STATUS IN (3)
                 ;

    END IF; -- IF VJOBTYP  IN (12) THEN

  IF VJOBTYP  IN (32) THEN

            FOR K IN (SELECT J.N,J.VAL1,J.ST_STOCK_N,J.BASE_DOC_N , J.UP
            ,J.NOMENKLATURA_N
                     FROM ST_BAR_JOBS J
                     CONNECT BY PRIOR J.ST_STOCK_N = J.UP AND J.TYP = 32
                      START WITH J.N = VJOBN AND J.TYP = 32)
            LOOP

            UPDATE ST_STOCK S
              SET S.CELL_ADDRESS_N = VNEWCELL
                WHERE S.N = K.ST_STOCK_N
                   AND S.TYP IN (6,17,7);

              UPDATE ST_BAR_JOBS J
               SET J.VAL2 =   VNEWCELL
                  WHERE J.N = K.N
                    AND J.TYP = 32
                    AND J.STATUS IN (3);
            END LOOP;


    END IF; -- IF VJOBTYP  IN (32) THEN



    BEGIN
     UPDATE ST_DOC_OUT O
            SET OUT_CELL_N = VNEWCELL
            WHERE N = VBASEDOCN
           AND SYSDATE BETWEEN FD AND TD
           AND NVL(OUT_CELL_N,0) != VNEWCELL;

                     KK_ST_BAR_JOBS.CREATEJOBPALLTOCONSOLIDATION(PCONTRAGENTN => VCONTRAGENTN,PBASEDOCN => VBASEDOCN);
    VJOBPACKPALL :=  KK_ST_BAR_JOBS.CREATEJOBSPACKPALL(PDOCN => VBASEDOCN,PFD => SYSDATE,PPRIORITY => VTASKPRIORITY,PWHO => VEMPN,PCONTRAGENTN => VCONTRAGENTN,PPALLN => VSTPALLN,PCELLN => VNEWCELL);
                     KK_ST_BARCODE5. STDOCOUTSETSTATUSCOMPLETE(VBASEDOCN ,VCONTRAGENTN,VEMPN );
    END;

    END IF; --  IF VJOBTYP  IN (32,3) THEN

    IF VJOBTYP  IN (3) THEN
     KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN =>PROBJN,PJOBN =>VJOBN
      ,PJOBTYP =>0,PJOBDOCN =>0,PVAL1 =>NULL,PDSC =>NULL/*,PVAL2 =>VNEWCELL*/);
    END IF;

     PMSG := 'ЗАДАНИЕ УСПЕШНО ВЫПОЛНЕНО';
     IF VRET=4 THEN
       PMSG := PMSG||V1310||'ЗАКАЗ №'||VBASEDOCN||' ПОДОБРАН!';
     END IF;
     IF VRET=6 THEN
       PMSG := PMSG||V1310||'ВНИМАНИЕ!!!'||V1310||' ЗАКАЗ №'||VBASEDOCN||' НЕ ПОЛНОСТЬЮ ПОДОБРАН!!!'||V1310||'ВЫ ПРИСТУПАЕТЕ К ПОДБОРУ СЛЕДУЮЩЕГО ЗАКАЗА'||V1310||' ОБРАТИТЕСЬ К ОПЕРАТОРУ!!!';
     END IF;
     SELECT NVL(DT.ST_DOC_MOVE_N,0) INTO VSTDOCMOVEN
     FROM ST_BAR_JOBS J
        LEFT OUTER JOIN ST_DOC_MOVE_DET DT ON(DT.N = J.ST_DOC_N AND SYSDATE BETWEEN DT.FD AND DT.TD)
     WHERE J.N =VJOBN;

     PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_MOVE.N',VSTDOCMOVEN);
  END IF;-- IF VNEWCELLDT = VNEWCELL THEN


ELSE --IF (VNEWCELL IS NOT NULL) AND (VJOBN IS NOT NULL) THEN
--RAISE_APPLICATION_ERROR(-20000,-1);
RETURN -1;
END IF; --IF (VNEWCELL IS NOT NULL) AND (VJOBN IS NOT NULL) THEN

DECLARE
VPROCNAME LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOC.PALLJOBCOMPLETE.USERPROC',SYSDATE,VCONTRAGENTN,VJOBTYP);
VROBJN INTEGER := PROBJN;
BEGIN

IF VPROCNAME != '_' THEN

 /*IF VEMPN = 1 THEN
 RAISE_APPLICATION_ERROR(-20000,'VPROCNAME='||VPROCNAME||'; VCONTRAGENTN='||VCONTRAGENTN||'; VBASEDOCN='||VBASEDOCN
 ||'; VJOBN='||VJOBN||'; VJOBTYP='||VJOBTYP||'; VEMPN='||VEMPN||'; VNEWCELL='||VNEWCELL);
 END IF ;
*/

   EXECUTE IMMEDIATE 'BEGIN '||VPROCNAME||'(:PROBJN , :PCONTRAGENTN ,   :PBASEDOCN   ,:PJOBN     , :PTYP  , :PNEWCELL   ,:PNEWCELLDT   ,:PEMPN );  END;'
                                  USING  IN PROBJN, IN VCONTRAGENTN,  IN VBASEDOCN, IN VJOBN, IN VJOBTYP, IN VNEWCELL, IN VNEWCELLDT, IN VEMPN;
END IF ; --IF VPROCNAME != '_' THEN


END; --DECLARE

--RAISE_APPLICATION_ERROR(-20000,VRET);

IF VJOBTYP != 12 THEN
DECLARE
VRETURN INTEGER := KK_CONST.GETCONSTN('STBARJOBS.UNIONPULLJOBS',SYSDATE);
BEGIN
 SELECT DECODE(VRETURN,0,VRET,22) INTO VRET FROM DUAL;
END;
END IF;

RETURN VRET;

END CELLEXISTSANDCANGET_DEF;


FUNCTION INPUTSIMPLENOM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
VCODE NOMENKLATURA.CODE%TYPE;
VNAME NOMENKLATURA.NAME%TYPE;
VRET INTEGER := 1 ;
VEXPDAYS INTEGER ;
VCONTRAGENTN INTEGER :=  NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0);
VBARCODE VARCHAR2(255);
VNOMUNIT INTEGER;
VCNT INTEGER := 0 ;
BEGIN

IF NVL(VCONTRAGENTN,0) = 0 THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>КОНТРАГЕНТ НЕ ОПРЕДЕЛЕН!</ERR>');
END IF ;

PMSG := NULL;

SELECT NVL(LOWER(PKEYCODE), PSTR) INTO VBARCODE  FROM DUAL ;

FOR J IN (

SELECT ROWNUM AS RN, N AS NOMENKLATURA_N,NAME, EXPIRE , CONTRAGENT_N , COUNT(1) OVER (PARTITION BY 1) AS CNT
  ,CODE , BARCODE , UNIT
 FROM
 (
 SELECT/*+ ORDERED*/  N.N,N.CODE,N.CODE ||' ' ||N.NAME AS NAME ,N.EXPIRE ,B.CONTRAGENT_N , B.BAR_CODE AS BARCODE , N.UNIT
     FROM NOM_BARCODE B
        JOIN NOMENKLATURA N ON (  B.NOMENKLATURA_N = N.N  AND N.TD = KK_COMMON.GETTD )
   WHERE (
          (LOWER(TRIM(B.BAR_CODE)) = LOWER(TRIM(VBARCODE)) AND VBARCODE IS NOT NULL) -- ЕСЛИ В ДРУГ ПОПАЛИ НЕ EAN UCC
       OR (LOWER(TRIM(B.BAR_CODE)) = LOWER(TRIM(PSTR    )) AND PSTR     IS NOT NULL)-- ТОГДА ПРОСТО ПО ТОМУ ЧТО СКАНИРОВАЛИ
          )
      AND B.TD = KK_COMMON.GETTD
      AND B.CONTRAGENT_N = VCONTRAGENTN
     UNION
  SELECT N.N ,N.CODE, N.CODE ||' ' ||N.NAME AS NAME ,N.EXPIRE , N.CONTRAGENT_N , N.CODE AS BARCODE , N.UNIT
     FROM  NOMENKLATURA N
      WHERE  N.TD = KK_COMMON.GETTD
         AND (
              (LOWER(N.CODE) LIKE '%'||LOWER(VBARCODE)||'%' AND VBARCODE IS NOT NULL) -- ЕСЛИ В ДРУГ ПОПАЛИ НЕ EAN UCC
           OR (LOWER(N.CODE) LIKE '%'||LOWER(PSTR    )||'%' AND PSTR     IS NOT NULL) -- ТОГДА ПРОСТО ПО ТОМУ ЧТО СКАНИРОВАЛИ
              )
         AND N.CONTRAGENT_N = VCONTRAGENTN
      UNION
  SELECT N.N ,N.CODE, N.CODE ||' ' ||N.NAME AS NAME ,N.EXPIRE , N.CONTRAGENT_N , N.CODE AS BARCODE , N.UNIT
     FROM  NOMENKLATURA N
       WHERE  N.N IN (SELECT  N1 FROM TABLE(CAST( KK_ST_BARCODE.GETNOMCURSORBYUSERPROC(VCONTRAGENTN,PKEYCODE,PSTR) AS TCWMS_TABLE))   )
       AND N.TD = KK_COMMON.GETTD
       AND N.CONTRAGENT_N = VCONTRAGENTN

   )


) LOOP

 PROBJN:=KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',J.NOMENKLATURA_N);

 IF J.CNT = 1 THEN

  VNOMN := J.NOMENKLATURA_N;
  VNAME := J.NAME;
  VEXPDAYS := J.EXPIRE;
  VNOMUNIT := J.UNIT;
   PMSG :=  VNAME;
   VCNT := 1 ;

 END IF; --IF J.CNT = 1 THEN

 IF J.CNT > 1 THEN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5, VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,27/*ЗАПОМНИЛИ СПИСОК КОДОВ НОМЕНКЛАТУРЫ*/,J.NOMENKLATURA_N,J.RN,J.BARCODE,J.CODE,SYSDATE,KK_COMMON.GETTD,J.UNIT,PPROCN,J.EXPIRE,J.CONTRAGENT_N)
   RETURNING N INTO PPROCN;

     SELECT SUBSTR(PMSG ||J.RN ||' - ' || /*J.CODE || */  J.NAME   ||CHR(13)|| CHR(10),1,2000) INTO PMSG FROM DUAL ;
      VCNT := VCNT +1 ;

      EXIT WHEN LENGTH(PMSG) >= 2000;

 END IF;

END LOOP;


IF VCNT = 0 THEN
RAISE_APPLICATION_ERROR(-20002,'НОМЕНКЛАТУРА ПО ШТРИХКОДУ *'||VBARCODE||'* НЕ НАЙДЕНА. ПОПРОБУЙТЕ ВВЕСТИ КОД ТОВАРА!');
END IF;

IF VCNT IN (1) THEN --IF VCNT IN (0,1) РЕБЯТ ЕСЛИ ПРИХОДИТ 0, ТО ЭТО ПУСТОТА! ОШИБКА В НЦП ПРИ ОПРЕДЕЛЕНИИ НОМЕНКЛАТУРЫ!


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 ,VAL4, FD , TD , DSC, UP ,VAL5, VAL6)  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4/*ЗАПОМНИЛИ БАР КОД НОМЕНКЛАТУРЫ*/,VNOMN,PKEYCODE,VBARCODE,VNAME,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР СОСКАНИРОВАННОГО НАИМЕНОВАНИЯ',PPROCN,VEXPDAYS,VCONTRAGENTN)
   RETURNING N INTO PPROCN;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',VNOMN);

VRET := 1;
ELSE
    PMSG := 'НАЙДЕНО '|| VCNT ||' НОМЕНКЛАТУР ПРОИЗВЕДИТЕ ВЫБОР'  ||CHR(13)|| CHR(10)|| PMSG;
VRET := 2;
END IF;


RETURN VRET;
END INPUTSIMPLENOM;


FUNCTION  INPUTSIMPLENOMLIST(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER;
VNOMBAR VARCHAR2(50);
VNOMCODE VARCHAR2(250);
VCOUNT INTEGER := 0;
VRET INTEGER := 0;
VNOMDOCCNT INTEGER;
VDIMEXISTS INTEGER ;
VNOMUNIT INTEGER;
VDIM VARCHAR2(500);
VNOMUNITCNT INTEGER;
BEGIN

 PMSG := NULL;

FOR J IN (
SELECT VAL1,VAL2,VAL3,VAL4,VAL5,VAL6,DSC
   FROM MCIS_NODES_PROC
   WHERE TYP = 27
    AND SYSDATE BETWEEN FD AND TD
 CONNECT BY PRIOR UP= N AND SYSDATE BETWEEN FD AND TD
  START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD ) LOOP

  IF J.VAL2 = TO_NUMBER(PKEYCODE) THEN

  IF J.VAL1 IS NULL THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЗНАЧЕНИЕ В СПИСКЕ НЕТ</ERR>');
  END IF;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA_N',J.VAL1);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',J.VAL6);
   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5, VAL6 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,4,J.VAL1,J.VAL4,J.VAL3,J.VAL4,SYSDATE,KK_COMMON.GETTD,PKEYCODE,PPROCN,J.VAL5,J.VAL6)
   RETURNING N INTO PPROCN;

    VRET :=1 ;
   EXIT;
  END IF; ---IF J.VAL2 = TO_NUMBER(PKEYCODE) THEN



END LOOP;
--RAISE_APPLICATION_ERROR(-20000,'SSS');

IF VRET = 0 THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>ЗНАЧЕНИЕ НЕ ИЗ СПИСКА</ERR>');
END IF;

IF VRET = 1 THEN
 UPDATE MCIS_NODES_PROC SET TD = SYSDATE
  WHERE ROWID IN
  (SELECT ROWID
    FROM MCIS_NODES_PROC
      WHERE TYP = 27
       AND SYSDATE BETWEEN FD AND TD
       CONNECT BY PRIOR UP= N AND SYSDATE BETWEEN FD AND TD
         START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD) ;

RETURN 1;
END IF;

END INPUTSIMPLENOMLIST;

FUNCTION  SETDEFAULTDATA(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    DD INTEGER := NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0);
BEGIN
--  RAISE_APPLICATION_ERROR(-20001,NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0));
IF DD = 0
    THEN PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEFAULTDATA',1);
--        PMSG := 'УСТ:'|| NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0);
        RETURN 1;
    ELSE PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEFAULTDATA',NULL);
--        PMSG := 'УСТ:'|| NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0);
         RETURN 2;
END IF;
END;

FUNCTION  CLEARDEFAULTDATA(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_PALL_TYPE',NULL);
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_NOM_TYP',NULL);
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_NOM_SUB_TYP',NULL);
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_NOM_TYP_RESPONSE',NULL);
 --   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEFAULTDATA',NULL);
    RETURN 1;
END;
FUNCTION  SHOWDEFAULTDATA(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VPALL INTEGER :=   NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_PALL_TYPE'),0);
    VPALLTYPNAME DIC_DATA.TERM%TYPE;
    VNOM_TYP INTEGER :=   NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP'),0);
    VNOM_TYP_NAME DIC_DATA.TERM%TYPE;
    VNOM_SUB_TYP INTEGER :=  NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_SUB_TYP'),0);
    VNOM_SUB_TYP_NAME DIC_DATA.TERM%TYPE;
    VNOM_TYP_RESPONSE INTEGER :=   NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEF_NOM_TYP_RESPONSE'),0);
    VNOM_TYP_RESPONSE_NAME DIC_DATA.TERM%TYPE;
    VRESPONSESTR VARCHAR2(100);
BEGIN
    BEGIN
            SELECT DD.TERM
            INTO VPALLTYPNAME
             FROM DIC_DATA DD
                WHERE DD.UP= 359
                   AND SYSDATE BETWEEN DD.FD AND DD.TD
                   AND DD.CODE = VPALL;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN VPALLTYPNAME := '';
    END;
    BEGIN
            SELECT DECODE(VNOM_TYP
                            ,1,'КОНДИЦИЯ'
                            ,3,'БРАК'
                            ,'НЕОПРЕДЕЛЕНО')
            INTO VNOM_TYP_NAME
             FROM DUAL;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN VPALLTYPNAME := '';
    END;
    BEGIN
            SELECT DD.TERM
            INTO VNOM_SUB_TYP_NAME
             FROM DIC_DATA DD
                WHERE DD.UP= 496
                   AND SYSDATE BETWEEN DD.FD AND DD.TD
                   AND DD.CODE = VNOM_SUB_TYP;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN VPALLTYPNAME := '';
    END;
    IF KK_CONST.GETCONSTN('STBARJOBS.RESPONSE.NEED', SYSDATE) = 1 THEN
      BEGIN
            SELECT DD.TERM
            INTO VNOM_TYP_RESPONSE_NAME
             FROM DIC_DATA DD
                WHERE DD.UP= 521
                   AND SYSDATE BETWEEN DD.FD AND DD.TD
                   AND DD.CODE = VNOM_TYP_RESPONSE;
        VRESPONSESTR := '     ОТВЕТСТВЕННЫЙ: '||VNOM_TYP_RESPONSE_NAME ||'('||VNOM_TYP_RESPONSE||')'||CHR(13)|| CHR(10);
      EXCEPTION
        WHEN NO_DATA_FOUND THEN VPALLTYPNAME := '';
      END;
    END IF;



        PMSG :=   'ЗНАЧЕНИЯ ПОУМОЛЧАНИЮ:'||CHR(13)|| CHR(10)
              ||'     ТИП ПАЛЛЕТЫ: '||VPALLTYPNAME||'('||VPALL||')'||CHR(13)|| CHR(10)
              ||'     СОСТОЯНИЕ: '||VNOM_TYP_NAME ||'('||VNOM_TYP||')'||CHR(13)|| CHR(10)
              ||'     ГРАДАЦИЯ: '||VNOM_SUB_TYP_NAME ||'('||VNOM_SUB_TYP||')'||CHR(13)|| CHR(10)
              ||VRESPONSESTR;

 RETURN 1;
END SHOWDEFAULTDATA;





FUNCTION  SHOWSIMPLENOMUNIT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VCNT INTEGER := 0 ;
BEGIN

SELECT CODE ||' '|| NAME ||' '|| VNOMN INTO PMSG
 FROM
 NOMENKLATURA WHERE
  N = VNOMN
  AND SYSDATE BETWEEN FD AND TD ;


       FOR J IN (
       SELECT/*+ ORDERED*/ U.UNIT_TYP,POWER(U.UNIT_CNT,DECODE(U.CNT_EXPONENT,0,1,U.CNT_EXPONENT)) AS UNIT_CNT
        ,U.UNIT_TYP ||'.'||DD.TERM||'('||

CASE WHEN NVL(DECODE(U.CNT_EXPONENT,0,1,U.CNT_EXPONENT),1) =  1 THEN U.UNIT_CNT||' '||LOWER(DD_NOM_UNIT.TERM)
     WHEN NVL(DECODE(U.CNT_EXPONENT,0,1,U.CNT_EXPONENT),1) = -1 THEN U.UNIT_CNT||' '||DD.TERM ||' В '||LOWER(DD_NOM_UNIT.TERM)
           END

        ||DECODE(U.UNIT_TYP,N.UNIT,' УЧ. ЕД.',N.UNIT_OP,' ОПЕР. ЕД.',NULL ) ||   ')'  AS MSG
        , COUNT(1) OVER (PARTITION BY 1) AS CNT
        ,LOWER(DD.TERM) AS DD_TERM
        ,DECODE(NVL(U.WEIGHT_NETTO,U.WEIGHT),0,U.WEIGHT,U.WEIGHT_NETTO) AS WEIGHT
               FROM NOM_UNIT U
               JOIN NOMENKLATURA N ON (N.N = VNOMN AND SYSDATE BETWEEN N.FD AND N.TD)
               JOIN DIC_DATA DD ON (DD.UP = 362 AND DD.CODE = U.UNIT_TYP AND SYSDATE BETWEEN DD.FD AND DD.TD)
               JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND SYSDATE BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
               WHERE   U.NOMENKLATURA_N = VNOMN
                   AND SYSDATE BETWEEN U.FD AND U.TD

                    ) LOOP

   IF NVL(J.UNIT_CNT,0) = 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЕДИНИЦА ИЗМЕРЕНИЯ ПУСТА!! ПРОВЕРЬТЕ СПРАВОЧНИК НОМЕНКЛАТУР</ERR>');
   END IF;

  IF J.CNT = 1 THEN
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,48/*ЗАПОМНИЛИ СПИСОК ЕД ИЗМЕР*/,VNOMN,J.UNIT_TYP,J.UNIT_CNT,J.DD_TERM,SYSDATE,KK_COMMON.GETTD,J.MSG,PPROCN,J.WEIGHT)
   RETURNING N INTO PPROCN;
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.NOM_UNIT_SEL',48);
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP',J.UNIT_TYP);

      PMSG := PMSG  ||CHR(13)|| CHR(10)||J.MSG;
  -- RETURN 2;
   END IF; --IF J.CNT = 1 THEN


  IF J.CNT >1 THEN
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP , VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,47/*ЗАПОМНИЛИ СПИСОК ЕД ИЗМЕР*/,VNOMN,J.UNIT_TYP,J.UNIT_CNT,J.DD_TERM,SYSDATE,KK_COMMON.GETTD,J.MSG,PPROCN,J.WEIGHT)
   RETURNING N INTO PPROCN;
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.NOM_UNIT_SEL',47);
      PMSG := PMSG  ||CHR(13)|| CHR(10)||J.MSG;
  END IF; --IF J.CNT >1 THEN

  VCNT := 1;
       END LOOP;

IF VCNT = 0 THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>ДЛЯ НОМЕНКЛАТУРЫ '||PMSG||' НЕОПРЕДЕЛЕНЫ ЕДИНИЦЫ ИЗМЕРЕНИЯ!</ERR>');
END IF;

 RETURN 1;

END SHOWSIMPLENOMUNIT;

FUNCTION INPUTSIMPLENOMUNIT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VUNIT_TYP INTEGER ;
VNOM_UNIT_SEL INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.NOM_UNIT_SEL');
BEGIN

PMSG := NULL;
VUNIT_TYP := TO_NUMBER(PKEYCODE);

FOR J IN (SELECT ROWID AS RD,P.VAL1,P.VAL2,P.VAL3 ,P.DSC,P.VAL4,P.VAL5
               FROM MCIS_NODES_PROC P
                WHERE  TYP = VNOM_UNIT_SEL
           CONNECT BY PRIOR  UP =N  AND SYSDATE BETWEEN FD AND TD
               START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD
               ORDER BY LEVEL DESC ) LOOP

 IF  J.VAL2 = VUNIT_TYP THEN

   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP , VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,48/*ЗАПОМНИЛИ СПИСОК ЕД ИЗМЕР*/,J.VAL1,J.VAL2,J.VAL3,J.VAL4,SYSDATE,KK_COMMON.GETTD,J.DSC,PPROCN,J.VAL5)
   RETURNING N INTO PPROCN;
  PMSG := J.DSC;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP',J.VAL2);
  EXIT;
 END IF;


 END LOOP;

IF PMSG IS NULL THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>НИЧЕГО НЕ ВЫБРАНО!</ERR>');
END IF;

RETURN 1;

END INPUTSIMPLENOMUNIT;

FUNCTION PRINTNOMSTICKERS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)  RETURN INTEGER IS
VPRINTERN INTEGER ;
VCNT INTEGER;
VEMPN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VNOMN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VNOMUNIT     INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP');
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VREPMODULE VARCHAR2(50) :=  KK_CONST.GETCONSTV('R_NOMSTICKERPALL.MODULE',SYSDATE,VCONTRAGENTN) ||'.DLL';
VPRINTERNAME R_PRINTERS.NAME%TYPE;
BEGIN

BEGIN
  SELECT CASE WHEN INSTR(LOWER(PSTR),'PR-') = 1 THEN TO_NUMBER(SUBSTR(PSTR,4)) ELSE 0 END INTO VPRINTERN FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    VPRINTERN := 0;
END;

IF VPRINTERN = 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПРИНТЕР!</ERR>');
ELSE

BEGIN
 SELECT N,NAME INTO VPRINTERN,VPRINTERNAME
  FROM R_PRINTERS
   WHERE N = VPRINTERN
    AND SYSDATE BETWEEN FD AND TD;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ПРИНТЕР НЕ ЗАРЕГИСТРИРОВАН В СИСТЕМЕ! '||VPRINTERN||'</ERR>');
END;

END IF; --IF VPRINTERN = 0 THEN

BEGIN
VCNT := TO_NUMBER(NVL(PKEYCODE,1));
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ОШИБКА В КОЛИЧЕСТВЕ! "'||PKEYCODE||'"</ERR>');
END;


 KK_R.BUILDPRINTJOBTYP(VEMPN ,VPRINTERN,2/*:PDOCTYP*/,0/*PLOCAL*/,0,VREPMODULE,
 'PDOCN=0;COPIES='||VCNT||';PRINTFROM=-14;PCONTRAGENTN='||VCONTRAGENTN||';PNOMENKLATURAN='||VNOMN||';PTARIFGRP=-1;PWHO=-14'  );


 PMSG := 'ЗАДАНИЕ ОТПРАВЛЕНО НА ПРИНТЕР '|| VPRINTERNAME;

RETURN 1;

END PRINTNOMSTICKERS;

--//////////////////////////////////////////////////////////////////////////////////////////////////////
--//////////////////////////////////ИНВЕНТАРИЗАЦИЯ////////////////////////////////////////////////
--//////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION INPUTNOM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VX INTEGER;
VCONTRAGENTN INTEGER :=  NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0);
BEGIN

IF PKEYCODE IS NOT NULL THEN
VX := 1;
SELECT N.N,N.CODE ||' '||N.NAME ,CONTRAGENT_N INTO VN,PMSG,VCONTRAGENTN
 FROM
     NOMENKLATURA N
   WHERE LOWER(N.CODE) LIKE '%' || LOWER(PKEYCODE)
    AND SYSDATE BETWEEN  N.FD  AND N.TD
    AND (CONTRAGENT_N =VCONTRAGENTN OR VCONTRAGENTN = 0) ;

       IF PSTR IS NOT NULL THEN
          BEGIN

         SELECT NOMENKLATURA_N INTO VX
           FROM NOM_BARCODE B
            WHERE BAR_CODE  = PSTR
             AND SYSDATE BETWEEN  B.FD  AND B.TD
             AND B.CONTRAGENT_N = VCONTRAGENTN;

          EXCEPTION
                WHEN NO_DATA_FOUND THEN
                   INSERT INTO  NOM_BARCODE
                      (N , FD , TD , CONTRAGENT_N , NOMENKLATURA_N , BAR_CODE )  VALUES
                     (SQ_NOMENKLATURA.NEXTVAL,SYSDATE,KK_COMMON.GETTD,VCONTRAGENTN,VN,PSTR);
          END;
       END IF;

ELSE
VX :=2;
 IF PSTR IS NULL THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА НЕ СОСКАНИРОВАНА</ERR>');
 END IF;

SELECT B.NOMENKLATURA_N,N.CODE ||' '||N.NAME INTO VN,PMSG
 FROM NOM_BARCODE B,
     NOMENKLATURA N
   WHERE BAR_CODE  = PSTR
    AND SYSDATE BETWEEN  B.FD  AND B.TD
    AND B.NOMENKLATURA_N = N.N
    AND SYSDATE BETWEEN  N.FD  AND N.TD ;

END IF;

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,21/*ЗАПОМНИЛИ НОМЕНКЛАТУРУ ЯЧЕЙКИ*/,VN,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ НОМЕНКЛАТУРУ',PPROCN)
   RETURNING N INTO PPROCN;



RETURN 1;

EXCEPTION
  WHEN TOO_MANY_ROWS THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НАЙДЕНО БОЛЕЕ ОДНОЙ НОМЕНКЛАТУРЫ ПО КОДУ, УТОЧНИТЕ КОД *' ||  PSTR  ||  '* *' || PKEYCODE||  '* ' ||VX||'</ERR>');
  WHEN NO_DATA_FOUND THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕРКЛАТУРА ПО ШТРИХКОДУ НЕ ОБНАРУЖЕНА *' ||  PSTR  ||  '* *' || PKEYCODE||  '* ' ||VX||'</ERR>');


END;


FUNCTION INPUTQUANTUMCNT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VCNT INTEGER;
    VRET NUMBER := 0;
BEGIN
 PMSG := NULL;

SELECT TO_NUMBER(PKEYCODE) INTO VCNT  FROM DUAL ;

/*INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,22,VCNT,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ КОЛИЧЕСТВО',PPROCN)
   RETURNING N INTO PPROCN;*/

IF VCNT <= 0 THEN RAISE_APPLICATION_ERROR(-20001,'ОБРАТИТЕСЬ К РАЗРАБОТЧИКУ!!!!'); END IF;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'QUANTUM.CNT',VCNT);
    KK_REP.ASSIGN('QUANTUM.CNT',VCNT);

  PMSG := PMSG || CHR(13)||CHR(10)
        ||' ВЛОЖЕННОСТЬ:'||VCNT;

VRET := 1;
-- RAISE_APPLICATION_ERROR(-20001,KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N'));

IF KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N') != 0 THEN VRET := 2; END IF;

RETURN VRET;


END;



FUNCTION INPUTCNT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCNT INTEGER;
VNOMN INTEGER :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VUNITCNT NUMBER :=KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_CNT');
VBLCK INTEGER;
VCODE VARCHAR2(200);
BEGIN
  PMSG := NULL;
  SELECT TO_NUMBER(PKEYCODE) INTO VCNT  FROM DUAL ;
  IF VCNT IS NULL THEN
    RAISE_APPLICATION_ERROR(-20000, '<ERR>ВВЕДИТЕ КОЛИЧЕСТВО</ERR>');
  END IF;
  
  SELECT MAX(BLCK) INTO VBLCK FROM NOM_BLCK WHERE NOMENKLATURA_N = VNOMN AND TD = KK_COMMON.GETTD;

IF VCNT*VUNITCNT > VBLCK THEN
SELECT CODE INTO VCODE FROM NOMENKLATURA WHERE N = VNOMN;
RAISE_APPLICATION_ERROR(-20123,'КОД '||VCODE||' КОЛ-ВО ДОЛЖНО БЫТЬ МЕНЬШЕ ПАЛЕТИЗАЦИИ '||VBLCK);
END IF;
  
  
  INSERT INTO MCIS_NODES_PROC
    (N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )
    VALUES
    (SQ_MCIS_NODES_PROC.NEXTVAL,22,VCNT,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ КОЛИЧЕСТВО',PPROCN)
    RETURNING N
    INTO PPROCN;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CNT',VCNT);
  RETURN 1;
END INPUTCNT;

FUNCTION INPUTINVDOC(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VCONTRAGENTN INTEGER;
BEGIN


SELECT TO_NUMBER(NVL(PKEYCODE, PSTR))
  INTO VN
  FROM DUAL ;

-- ОПРЕДЕЛЯЕМ ПОСЛЕДНЮЮ ИНВЕНТАРИЗАЦИЮ ДЛЯ ЦИКЛИЧЕСКОЙ ИНВЕНТАРИЗАЦИИ
SELECT NVL(MAX(N), VN)
  INTO VN
  FROM ST_DOC_INV
  WHERE UP = VN
    AND TD = KK_COMMON.GETTD;

SELECT N,CONTRAGENT_N INTO VN,VCONTRAGENTN
 FROM ST_DOC_INV
  WHERE N = VN
   AND SYSDATE BETWEEN FD AND TD
   AND STATUS IN (4,5)
   ;

 PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N',VCONTRAGENTN);
 PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'FILTER.CONTRAGENT_N',VCONTRAGENTN);
 PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_INV.N',VN);

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,23/*ЗАПОМНИЛИ ДОКУМЕНТ*/,VN,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ВЫБРАЛИ ДОКУМЕНТ',PPROCN)
   RETURNING N INTO PPROCN;

 PMSG := 'ИНВЕНТАРИЗАЦИЯ: '||VN;

RETURN 1;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕР ИНВЕНТАРИЗАЦИИ НЕ ВЕРЕН! '||VN||' ИЛИ АКТ НЕ В ДРУГОМ СТАТУСЕ</ERR>');

END;



FUNCTION  INPUTINVENTORYEND(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCNT INTEGER :=0;
VNOMN INTEGER := 0;
VCELLADDRN INTEGER := 0 ;
VN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VDETN INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VPARTN INTEGER := 0;
VNOMTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
VBRAKTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_SUB_TYP');
VRESPONSE INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP_RESPONSE');
VEXPIREDATE DATE := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'DATE');
VPALLTYPE INTEGER := 0;
VSTPALLN INTEGER := 0;
VNOMUNIT INTEGER := 1;
VWHATISDATE INTEGER := 0;
VEXPIRE INTEGER;
VCONTRAGENTN INTEGER;
VSTOREN  INTEGER;
VFLOR  INTEGER;
VLINE  INTEGER;
VSTAGE  INTEGER;
VPLACE  INTEGER;
VWEIGHT NUMBER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PWEIGHT_NETTO');
VWEIGHT2 NUMBER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PWEIGHT');
VPRD ROWID;
VDIML INTEGER; VDIMW INTEGER; VDIMH INTEGER;
VTOTALEXPIRE DATE;
VUNIT_TYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP');
VUNIT_TYP_MSG VARCHAR2(100) := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP.TERM');
VUNIT_CNT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_CNT');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

IF NVL(VN,0) = 0 THEN
  PMSG := 'НОМЕР ДОКУМЕНТА ИНВЕНТАРИЗАЦИИ НЕИЗВЕСТЕН!';
  RETURN -2;
END IF; --IF  SYS_CONTEXT('CTX_ST_BARCODE','ST_DOC_N') IS NULL THEN

PMSG := '.';

FOR J IN (SELECT VAL1,TYP,VAL2,VAL3,DSC,VAL4,VAL5,VAL6
  FROM MCIS_NODES_PROC
    CONNECT BY PRIOR UP = N
      START WITH N = PPROCN
      ORDER BY LEVEL
) LOOP

/*
 CASE WHEN J.TYP = 22 AND VCNT =0        THEN VCNT := J.VAL1;PMSG := PMSG ||V1310||'КОЛИЧЕСТВО :'||J.VAL1;
      WHEN J.TYP = 4  AND VNOMN =0       THEN VEXPIRE := J.VAL5; VNOMN := J.VAL1;PMSG := PMSG ||V1310||'НОМЕНКЛАТУРА :'||J.VAL4;
      WHEN J.TYP = 13 AND VCELLADDRN = 0 THEN VCELLADDRN := J.VAL1; PMSG := PMSG ||V1310||'ЯЧЕЙКА :'||J.DSC;
      WHEN J.TYP = 19 AND VPARTN =0      THEN VPARTN := J.VAL1;PMSG := PMSG ||V1310||'ПАРТИЯ :'||J.VAL4;
      WHEN J.TYP = 12 AND VNOMTYP = 0    THEN VNOMTYP := J.VAL1;PMSG := PMSG ||V1310||'СОСТОЯНИЕ :'||J.VAL4;
      WHEN J.TYP =10  AND VWHATISDATE = 0   THEN VWHATISDATE := J.VAL1;  SELECT PMSG ||V1310||DECODE(VWHATISDATE,0,'СРОК ГОДНОСТИ ДО',9,'ДАТА ИЗГОТОВЛЕНИЯ','БЕЗ ОГРАНИЧЕНИЯ ДАТЫ') INTO PMSG FROM DUAL;
      WHEN J.TYP =11  AND VEXPIREDATE = KK_COMMON.GETTD THEN VEXPIREDATE := TO_DATE(J.VAL3,'DDMMYYYY');PMSG := PMSG ||V1310||'СРОК ГОДНОСТИ :'||J.VAL3;
      WHEN J.TYP =6   AND VPALLTYPE = 0  THEN VPALLTYPE := J.VAL2;PMSG := PMSG ||V1310||'ТИП ПАЛЛЕТА :'||J.VAL4;
      WHEN J.TYP =26  AND VSTPALLN = 0   THEN VSTPALLN := J.VAL2;PMSG := PMSG ||V1310||'ПАЛЛЕТ ID :'||J.VAL2;
      WHEN J.TYP =48  AND VNOMUNIT = 1   THEN VNOMUNIT := J.VAL3;PMSG := PMSG ||V1310||'ЕД. ИЗМЕР :'||J.DSC;
*/

 CASE WHEN J.TYP = 22 AND VCNT =0        THEN VCNT := J.VAL1;PMSG := SUBSTR( PMSG ||'КОЛ-ВО :'||J.VAL1||' ВЕС: '||VWEIGHT,1,2000)||V1310;PMSG := SUBSTR(PMSG ||'ЕД. ИЗМЕР :'||VUNIT_TYP_MSG,1,2000)||V1310;
      WHEN J.TYP = 4  AND VNOMN =0       THEN VCONTRAGENTN := J.VAL6; VEXPIRE := J.VAL5; VNOMN := J.VAL1;PMSG := SUBSTR(PMSG||'НОМЕНКЛАТУРА :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP = 13 AND VCELLADDRN = 0 THEN VCELLADDRN := J.VAL1; PMSG := SUBSTR(PMSG ||'ЯЧЕЙКА :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP = 19 AND VPARTN =0      THEN VPARTN := J.VAL1;PMSG := SUBSTR(PMSG ||'ПАРТИЯ :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP = 12 AND VNOMTYP = 0    THEN VNOMTYP := J.VAL1;PMSG := SUBSTR(PMSG ||'СОСТОЯНИЕ :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP =10  AND VWHATISDATE = 0   THEN VWHATISDATE := J.VAL1;  SELECT SUBSTR(PMSG ||DECODE(VWHATISDATE,0,'СРОК ГОДНОСТИ ДО',9,'ДАТА ИЗГ.:'),1,2000)||V1310 INTO PMSG FROM DUAL;
 -- DVE     WHEN J.TYP =11  AND VEXPIREDATE = KK_COMMON.GETTD THEN VEXPIREDATE := TO_DATE(J.VAL3,'DDMMYYYY');PMSG := SUBSTR(PMSG ||'СРОК ГОДНОСТИ :'||J.VAL3,1,2000)||V1310;
  /* ЗАЧЕМ ЭТО ЗАКОМЕТИРОВАНО! ДВЕ !! ЕСЛИ НУЖНО БУДЕТ СКАЖИТЕ ЗАЧЕМ !!!*/
      WHEN J.TYP =6   AND VPALLTYPE = 0  THEN VPALLTYPE := J.VAL2;PMSG := SUBSTR(PMSG ||'ТИП ПАЛЛЕТА :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP =26  AND VSTPALLN = 0   THEN VSTPALLN := J.VAL2; SELECT DECODE(J.VAL2,'0',NULL, SUBSTR(PMSG ||'ПАЛЛЕТ ID :'||J.VAL2,1,2000)||V1310) INTO PMSG FROM DUAL;
/*      WHEN J.TYP =48  AND VNOMUNIT = 1   THEN VNOMUNIT := J.VAL3;PMSG := SUBSTR(PMSG ||'ЕД. ИЗМЕР :'||J.DSC,1,2000)||V1310;  ИСПОЛЬЗУЮТСЯ ПЕРЕМЕННЫЕ NOMENKLATURA.UNIT_CNT, NOMENKLATURA.UNIT_TYP, NOMENKLATURA.UNIT_TYP.TERM*/
      WHEN J.TYP =191 AND VWEIGHT = 1    THEN VWEIGHT := J.VAL1;PMSG := SUBSTR(PMSG ||'ВЕС :'||J.VAL1,1,2000)||V1310;
 ELSE
      NULL;
 END CASE;

 EXIT WHEN J.TYP= 68;

END LOOP;


IF VUNIT_CNT > 1 THEN
    VNOMUNIT := VUNIT_CNT;
END IF;
  IF NVL(VCELLADDRN,0) != 0  THEN
        BEGIN

       DECLARE -- ДЛЯ ТРАФАРЕТНЫХ ВЕСОВ ПОСЧИТАТЬ ВЕ
        VGRP   LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NOMWEIGHT.NOMGRP.NOREQUESTWEIGHT',SYSDATE,VCONTRAGENTN,1) ;
        VWUNIT LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEWEIGHT.NOMUNIT'               ,SYSDATE,VCONTRAGENTN) ;
       BEGIN
        SELECT U.UNIT_CNT *  VCNT * VNOMUNIT
           INTO VWEIGHT
         FROM NOMENKLATURA N
          JOIN NOM_UNIT U ON (U.NOMENKLATURA_N =  VNOMN
                          AND U.TD = KK_COMMON.GETTD
                          AND VWUNIT LIKE '%,'|| U.UNIT_TYP || ',%'
                          )
          WHERE  N.N =  VNOMN
             AND N.TD = KK_COMMON.GETTD
             AND (VGRP LIKE '%,'|| N.GROUP_N || ',%' OR VGRP = '0')
             AND ROWNUM <= 1;

       EXCEPTION
          WHEN NO_DATA_FOUND THEN
               NULL;
       END;


        INSERT INTO ST_DOC_INV_DET
        (N                        , ST_DOC_INV_N, NOMENKLATURA_N , CELL_ADDRESS_N , CNT , STATUS , FD    , TD            , TERMINAL_N , EMP_N                                        ,ST_PART_N ,NOM_TYP
        ,EXPIRE_DATE,MAKE_DATE
        ,PALL_TYPE,ST_PALL_N,WEIGHT)      VALUES
        (SQ_ST_DOC_INV_DET.NEXTVAL,           VN,           VNOMN,VCELLADDRN,VCNT * VNOMUNIT,1   ,SYSDATE,KK_COMMON.GETTD,0           ,NVL(KK_ST_BARCODE.SESSIONVARGET(0,'EMP_N'),0) ,VPARTN,VNOMTYP
        ,DECODE(VWHATISDATE,9,VEXPIREDATE+VEXPIRE, VEXPIREDATE)
        ,DECODE(VWHATISDATE,9,VEXPIREDATE, VEXPIREDATE - VEXPIRE)
        ,DECODE(VPALLTYPE,0,1,VPALLTYPE),VSTPALLN,VWEIGHT)
         RETURNING N , EXPIRE_DATE INTO VDETN,VTOTALEXPIRE;


        DECLARE
        VCONTRN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
        VINVDETPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCINV.DETSUBMIT.USERCHECKPROC',SYSDATE,VCONTRN);
       BEGIN
        IF LENGTH(VINVDETPROC) > 1 THEN
           EXECUTE IMMEDIATE 'BEGIN '||VINVDETPROC||'(:PCONTRN,:PNOMN,:PCNT,:PEXPIREDATE,:PPARTN,:PNOMTYP,:PINVDET); END;'
            USING VCONTRN,VNOMN , VCNT * VNOMUNIT ,  VTOTALEXPIRE
              ,  VPARTN,VNOMTYP , VDETN ;
          END IF;
       END;




        KK_ST_NOM_TYP.SETVALUES(PSTDOCTYP => 14, PSTDOCN => VDETN, PSUBNOMTYP => NVL(VBRAKTYP, 0), PRESPONSE => NVL(VRESPONSE, 0) );
-- ОБНОВЛЕНИЕ ВЕСА ПАЛЛЕТА
      BEGIN
           SELECT ROWID , DIMENSION_L,DIMENSION_W,DIMENSION_H
                INTO VPRD, VDIML,VDIMW,VDIMH
           FROM PALL P
           WHERE P.N = VSTPALLN
                 AND SYSDATE BETWEEN P.FD AND P.TD;
       EXCEPTION
          WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001,'ПАЛЛЕТ НЕ ЗАРЕГИСТРИРОВАН. '||VSTPALLN);
      END;

      UPDATE PALL
        SET TD = SYSDATE - 1/86400
        WHERE ROWID = VPRD;

     INSERT INTO PALL
        (N,PALL_TYPE_N,FD,TD,WEIGHT,WEIGHT2,KIND_WEIGHT,DIMENSION_L,DIMENSION_W,DIMENSION_H)
     VALUES
        (VSTPALLN,VPALLTYPE,SYSDATE,KK_COMMON.GETTD,VWEIGHT,VWEIGHT2,DECODE(VWEIGHT2,0,1,0),VDIML,VDIMW,VDIMH)  ;
    KK_COMMON.ACTION(0,'PALL',VSTPALLN,1,SYSDATE,'НОВЫЙ ВЕС ='||VWEIGHT ||'; VDETN='||VDETN );


       SELECT A.STORE_N ,A.FLOR,A.LINE ,A.STAGE ,A.PLACE
         INTO
       VSTOREN ,   VFLOR, VLINE, VSTAGE, VPLACE
       FROM CELL_ADDRESS A
        WHERE A.N =    VCELLADDRN
        AND SYSDATE BETWEEN A.FD AND A.TD;

    --     KK_ST_DOC.SETCELLBLOCK(VSTOREN, VFLOR, VLINE, VSTAGE, VPLACE , 5 , VDETN, VCONTRAGENTN, VNOMN, 0, KK_COMMON.GETTD,'ИНВЕНТАРИЗАЦИЯ');

        KK_COMMON.ACTION(VEMPN,'ST_DOC_INV_DET',VDETN,1,SYSDATE,'НОВЫЙ ВЕС ='||VWEIGHT ||'; VDETN='||VDETN);
        EXCEPTION
         WHEN UNIQUE_CONSTRAINT_EXCEPT THEN -- CAUTION HANDLES ALL EXCEPTIONS
            RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАННЫЙ ПАЛЛЕТ УЖЕ ИНВЕНТАРИЗИРОВАН!</ERR>') ;
        END;
       ELSE
       RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС ПРИ ИНВЕНТАРИЗАЦИИ НЕ ОПРЕДЕЛЕН! '||NVL(VCELLADDRN,0)||'</ERR>') ;
  END IF;

-- // ЗАКРЫВАЕМ ЗАДАНИЕ ЕСЛИ ОНО БЫЛО
DECLARE
VJOBN INTEGER;
BEGIN

SELECT N INTO VJOBN
  FROM ST_BAR_JOBS
 WHERE TYP = 7
 AND SYSDATE BETWEEN FD AND TD
 AND STATUS IN (1,2)
 AND CELL_ADDRESS_N = VCELLADDRN
 AND BASE_DOC_N = VN
 AND ROWNUM <=1 ;

   KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,VJOBN,7,VN,0,NULL,0,3,SYSDATE);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
        NULL;
END;

--PMSG := 'ИНВЕНТАРИЗАЦИЯ ЗАВЕРШЕНА';
PPROCN := 0;
PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PWEIGHT_NETTO', 0);

RETURN 1;

END;

FUNCTION  INPUTINVENTORYWHATINPUT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCNT INTEGER :=0;
VNOMN INTEGER := 0;
VCELLADDRN INTEGER := 0 ;
VN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VCONTRN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VPARTN INTEGER := 0;
VNOMTYP INTEGER := 0;
VEXPIREDATE DATE;
VMAKEDATE DATE;
PSTR_ VARCHAR2(100);
VWHATISDATE NUMBER := 0;
VPALLTYPE INTEGER := 0;
VSTPALLN INTEGER := 0;
VNOMUNIT INTEGER := 1;
VWEIGHT NUMBER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PWEIGHT_NETTO');
VSTOREN NUMBER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PWEIGHT_NETTO'),0); -- СКЛАД
VSTOREAREAS VARCHAR2(50) := NVL(KK_CONST.GETCONSTV('STOREAREASCANZEROPID',SYSDATE,VCONTRN,VSTOREN),'_');
VSTOREAREA NUMBER;
VUNIT_TYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP');
VUNIT_TYP_MSG VARCHAR2(100) := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP.TERM');
VUNIT_CNT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_CNT');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);

BEGIN

IF NVL(VN,0) = 0 THEN
  PMSG := 'НОМЕР ДОКУМЕНТА ИНВЕНТАРИЗАЦИИ НЕИЗВЕСТЕН!';
  RETURN -2;
END IF; --IF  SYS_CONTEXT('CTX_ST_BARCODE','ST_DOC_N') IS NULL THEN

BEGIN
SELECT VAL1 INTO VWHATISDATE
  FROM MCIS_NODES_PROC
    WHERE TYP = 10 AND ROWNUM = 1
    CONNECT BY PRIOR UP = N
      START WITH N = PPROCN
      ORDER BY LEVEL;
SELECT DECODE(NVL(VWHATISDATE,0),0,' СРОК ГОДНОСТИ ДО ',9,' ДАТА ИЗГ.: ') INTO PSTR_ FROM DUAL;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
  PSTR_ := ' СРОК ГОДНОСТИ ДО ';
END;

FOR J IN (SELECT VAL1,TYP,VAL2,VAL3,DSC,VAL4
  FROM MCIS_NODES_PROC
    CONNECT BY PRIOR UP = N
      START WITH N = PPROCN
      ORDER BY LEVEL
) LOOP
/*

CASE WHEN J.TYP = 22 AND VCNT =0        THEN VCNT := J.VAL1;PMSG := PMSG ||V1310||';  КОЛ-ВО :'||J.VAL1;
      WHEN J.TYP = 4  AND VNOMN =0       THEN VNOMN := J.VAL1;PMSG := PMSG ||V1310||';  НОМЕНКЛАТУРА :'||J.VAL4;
      WHEN J.TYP = 13 AND VCELLADDRN = 0 THEN VCELLADDRN := J.VAL1; PMSG := PMSG ||V1310||';  ЯЧЕЙКА :'||J.VAL4;
      WHEN J.TYP = 19 AND VPARTN =0      THEN VPARTN := J.VAL1;PMSG := PMSG ||V1310||';  ПАРТИЯ :'||J.VAL4;
      WHEN J.TYP = 12 AND VNOMTYP = 0    THEN VNOMTYP := J.VAL1;PMSG := PMSG ||V1310||';  СОСТОЯНИЕ :'||J.VAL4;
      WHEN J.TYP =11  AND VEXPIREDATE IS NULL THEN VEXPIREDATE := TO_DATE(J.VAL3,'DDMMYYYY');PMSG := PMSG ||V1310||';  СРОК ГОДНОСТИ :'||J.VAL3;
      WHEN J.TYP =6   AND VPALLTYPE = 0  THEN VPALLTYPE := J.VAL2;PMSG := PMSG ||V1310||';  ТИП ПАЛЛЕТА :'||J.VAL4;
      WHEN J.TYP =26  AND VSTPALLN = 0   THEN VSTPALLN := J.VAL2;PMSG := PMSG ||V1310||';  ПАЛЛЕТ ID :'||J.VAL2;
      WHEN J.TYP =48  AND VNOMUNIT = 1   THEN VNOMUNIT := J.VAL3;PMSG := PMSG ||V1310||';  ЕД.:'||J.DSC;


*/
  CASE WHEN J.TYP = 22 AND VCNT =0        THEN VCNT := J.VAL1;PMSG := SUBSTR(PMSG ||'КОЛ-ВО :'||J.VAL1 ||'; ВЕС=' ||VWEIGHT,1,2000) ||V1310;PMSG := SUBSTR(PMSG ||'ЕД. ИЗМЕР :'||VUNIT_TYP_MSG,1,2000)||V1310;
      WHEN J.TYP = 4  AND VNOMN =0       THEN VNOMN := J.VAL1;PMSG := SUBSTR(PMSG ||'НОМЕНКЛАТУРА :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP = 13 AND VCELLADDRN = 0 THEN VCELLADDRN := J.VAL1; PMSG := SUBSTR(PMSG ||'ЯЧЕЙКА :'||J.VAL4,1,2000)||V1310; EXIT;
 --     WHEN J.TYP = 19 AND VPARTN =0      THEN VPARTN := J.VAL1;PMSG := SUBSTR(PMSG ||'ПАРТИЯ :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP = 12 AND VNOMTYP = 0    THEN VNOMTYP := J.VAL1;PMSG := SUBSTR(PMSG ||'СОСТОЯНИЕ :'||J.VAL4,1,2000)||V1310;

      WHEN J.TYP =11  AND VEXPIREDATE IS NULL THEN VEXPIREDATE := TO_DATE(J.VAL3,'DDMMYYYY');PMSG := SUBSTR(PMSG ||PSTR_||J.VAL3,1,2000)||V1310;

 --   WHEN J.TYP =6   AND VPALLTYPE = 0  THEN VPALLTYPE := J.VAL2;PMSG := SUBSTR(PMSG ||'ТИП ПАЛЛЕТА :'||J.VAL4,1,2000)||V1310;
      WHEN J.TYP =26  AND VSTPALLN = 0   THEN VSTPALLN := J.VAL2;SELECT DECODE(J.VAL2,'0',NULL, SUBSTR(PMSG ||'ПАЛЛЕТ ID :'||J.VAL2,1,2000)||V1310 ) INTO PMSG FROM DUAL ;
      WHEN J.TYP =48  AND VNOMUNIT = 1   THEN VNOMUNIT := J.VAL3;PMSG := SUBSTR(PMSG ||'ЕД.:'||J.DSC,1,2000)||V1310;
 ELSE
      NULL;
 END CASE;

END LOOP;

DECLARE
 VSTAGE INTEGER ;
BEGIN
 SELECT STAGE, NVL(STORE_AREA,0) INTO VSTAGE, VSTOREAREA
  FROM CELL_ADDRESS
   WHERE N = VCELLADDRN  AND TD = KK_COMMON.GETTD ;

   IF VSTAGE > 1 AND  VSTPALLN = 0
                 AND VSTOREAREAS NOT LIKE '%,'||VSTOREAREA||',%'   THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>PID ДОЛЖЕН БЫТЬ!!!!!</ERR>');
   END IF;
END ;

IF  KK_CONST.GETCONSTN('STDOCINV.FULLINV.NEEDPARTEXPIRE',SYSDATE,VCONTRN) = 0 THEN
   RETURN 1;
ELSE
   RETURN 5;
END IF;


END;

--//////////////////////////////////КОНЕЦ...../////////////////////////////////////////////////////
--//////////////////////////////////ИНВЕНТАРИЗАЦИЯ////////////////////////////////////////////////
--//////////////////////////////////////////////////////////////////////////////////////////////////////


FUNCTION  INPUTPALLIDONCELL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
VCELLN INTEGER;
VOK INTEGER := -999;
VRET INTEGER := -999;
VTERM VARCHAR2(255);
VCNT INTEGER;
VINCNT INTEGER;
VCONTRAGENTN INTEGER;
VNOMENKLATURAN INTEGER;
VKEYCODE VARCHAR(1000);
VTYP INTEGER;
VNUMACT VARCHAR2(255);
VACTCNT INTEGER;
VFILTERCONTRN INTEGER :=NVL(  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'FILTER.CONTRAGENT_N'  ),0);
VDOCNUM ST_DOC_OUT.DOC%TYPE;
VCANIGNOREINPUT INTEGER:= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT'); --ЕСЛИ 1, ДОЛЖЕН БЫТЬ УКАЗАН НОМЕР ПАЛЛЕТЫ БЕЗ УЧЕТА ЯЧЕЙКИ -- ФУНКЦИЯ МОЖЕТ ВЕРНУТЬ ТОЛЬКО 0 ИЛИ ОШИБКУ
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VSTBARCODEMANUALPIDINPUT INTEGER := KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'STBARCODEMANUALPIDINPUT',SYSDATE);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN


 IF PSTR IS NULL AND NVL(VSTBARCODEMANUALPIDINPUT,0) != 3 THEN
  RAISE_APPLICATION_ERROR(-20000,'СКАНИРУЙТЕ PID, РУЧНОЙ ВВОД ЗАПРЕЩЕН!');
 END IF;

IF PKEYCODE IS NOT NULL THEN
VKEYCODE := 'P-'||PKEYCODE;
END IF;


SELECT CASE WHEN INSTR(NVL(PSTR,VKEYCODE),'P-')=1 THEN 1 ELSE 0 END INTO VPALLN FROM DUAL;


IF VPALLN != 1 THEN
  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
 END IF;


BEGIN
 SELECT TO_NUMBER(REPLACE(NVL(PSTR,PKEYCODE),'P-','') ) INTO  VPALLN FROM DUAL;
EXCEPTION
    WHEN OTHERS THEN -- CAUTION:HANDLES ALL EXCEPTIONS
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕР ПАЛЛЕТА НЕ ОПРЕДЕЛЕН!</ERR>');
END;

IF VPALLN <= 0 THEN
 IF VCANIGNOREINPUT=0 THEN
    RETURN -1; -- НУЖЕН ДАЛЬНЕЙШИЙ ВВОД НОМЕНКЛАТУРЫ И ВВОД КОЛИЧЕСТВА
 ELSE
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ПРОПУЩЕН ВВОД АДРЕСА ЯЧЕЙКИ, НЕОБХОДИМ ВВОД НОМЕРА ПАЛЛЕТЫ!</ERR>');
 END IF;
--  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЭТО НЕ ПАЛЛЕТА!</ERR>');
END IF;

SELECT VAL1 INTO VCELLN FROM MCIS_NODES_PROC WHERE N = PPROCN ;

BEGIN
SELECT COUNT(J.N), STRAGG(NUM_ACT) INTO VACTCNT, VNUMACT FROM ST_BAR_JOBS J
JOIN ST_DOC_MOVE D ON( J.BASE_DOC_N = D.N AND J.ST_DOC_TYP =3 AND D.TD>SYSDATE)
WHERE J.STATUS IN (1,2) AND (VCANIGNOREINPUT=1 OR J.CELL_ADDRESS_N = VCELLN) AND J.ST_PALL_N = VPALLN;
IF VACTCNT <> 0 THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>УЖЕ СУЩЕСТВУЕТ ЗАДАНИЕ НА ПЕРЕМЕЩЕНИЕ ЭТОЙ ПАЛЛЕТЫ!! АКТ №'||VNUMACT||'</ERR>');
END IF;
END;

BEGIN
 SELECT/*+ INDEX_DESC(S ST_STOCK_PALL_TD_FD_TYP)*/  1,S.CONTRAGENT_N,S.NOMENKLATURA_N , S.TYP
  ,DECODE(S.TYP,6,'ЗАКАЗ:'||D.DOC,NULL)
  INTO VCNT , VCONTRAGENTN,VNOMENKLATURAN , VTYP , VDOCNUM
   FROM ST_STOCK S
    LEFT OUTER JOIN ST_DOC_OUT_DET DT ON ( S.TYP IN (6) AND   DT.N = S.ST_DOC_N AND S.TD>SYSDATE)
    LEFT OUTER JOIN ST_DOC_OUT D ON ( S.TYP IN (6) AND D.N = DT.SQ_ST_DOC_OUT_N AND D.TD>SYSDATE)
    WHERE S.ST_PALL_N = VPALLN
     AND S.TD>SYSDATE
     AND (VCANIGNOREINPUT=1 OR S.CELL_ADDRESS_N = VCELLN)
     AND (VFILTERCONTRN = S.CONTRAGENT_N OR VFILTERCONTRN = 0 AND VPALLN >0 )
     AND ROWNUM < 2 ;

    IF VTYP IN (6,7,8,17) THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА В ЗАРЕЗЕРВИРОВАНА "'||VDOCNUM||'", ДЕЙСТВИЕ НЕВОЗМОЖНО!</ERR>');
    END IF;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА В СТОКЕ НЕ ОБНАРУЖЕНА!</ERR>');
END;

  FOR REC IN
    (SELECT  1
      FROM  ST_STOCK ST
       JOIN ST_STOCK_BLOCKED B ON ST.N = B.ST_STOCK_N AND SYSDATE BETWEEN B.FD AND B.TD
      WHERE ST.ST_PALL_N = VPALLN
        AND ST.CELL_ADDRESS_N = VCELLN
        AND ((NVL(KK_CONST.GETCONSTV('ALLOWEDBLOCKTYPES',SYSDATE,VCONTRAGENTN),0) NOT LIKE '%,'||B.BLOCK_TYP||',%') OR
             (NVL(KK_CONST.GETCONSTV('ALLOWEDBLOCKTYPES',SYSDATE,VCONTRAGENTN),'_')='_'))
    )
  LOOP
    RETURN 3;
  END LOOP;
/*ЗАДАНИЕ НА ПЕРЕМЕЩЕНИЕ ПО ИНИЦИАТИВЕ*/
--  PROCEDURE CREATEJOBONEMP(PDOCN INTEGER,PDOCTYP INTEGER ,PTYP INTEGER,PPRIORITY INTEGER,PVAL1 INTEGER,PSTATUS INTEGER DEFAULT 1/*СОЗДАНО*/,PTD DATE DEFAULT TO_DATE('01013000','DDMMYYYY')
-- ,PCONTRAGENTN INTEGER DEFAULT 0
--,PNOMENCLATURAN INTEGER DEFAULT 0);

KK_ST_BAR_JOBS.CREATEJOBONEMP (PROBJN ,VPALLN,13 ,13,1,VCELLN,1,TO_DATE('01013000','DDMMYYYY'),VCONTRAGENTN,VNOMENKLATURAN);



FOR J IN (
SELECT/*+ INDEX_DESC(S ST_STOCK_PALL_TD_FD_TYP)*/
  S.N AS STOCK_N, S.NOMENKLATURA_N,S.EXPIRE_DATE,S.CNT,S.PART_IN_N,S.ST_PART_N,S.CELL_ADDRESS_N,S.TYP,S.FD,S.ST_PALL_N
  , S.CONTRAGENT_N , N.CODE,S.CNT AS IN_CNT
     FROM V_ST_STOCK_ACTIVE S
     JOIN NOMENKLATURA N ON (S.NOMENKLATURA_N = N.N AND SYSDATE BETWEEN N.FD AND N.TD)
     WHERE 1=1
    AND  S. ST_PALL_N = VPALLN
     AND (VCANIGNOREINPUT =1 OR S.CELL_ADDRESS_N = VCELLN)
     AND SYSDATE BETWEEN  S.FD AND  S.TD
     AND (VFILTERCONTRN = S.CONTRAGENT_N OR VFILTERCONTRN = 0 AND VPALLN >0 )
     ORDER BY  S.NOMENKLATURA_N, S.EXPIRE_DATE, S.CNT
 ) LOOP

 IF VCANIGNOREINPUT=0 AND J.CELL_ADDRESS_N != VCELLN AND VOK = -999 THEN
   PMSG := 'ВЫ ВЗЯЛИ ПАЛЛЕТУ С АДРЕСА ОТЛИЧНОГО ОТ ЗАРЕГИСТРИРОВАНОГО В СТОКЕ ' ||V1310;
 END IF;

 IF (VOK =1) OR (/*J.I_R = J.A_R AND J.I_R =J.I_ADDR AND J.TYP >0 AND J.CNT = J.IN_CNT AND*/ VOK = -999 )  THEN
  VOK := 1;

  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3, VAL4,VAL5 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,29,J.STOCK_N/*STOCKN*/,J.NOMENKLATURA_N,J.CELL_ADDRESS_N,J.STOCK_N,VPALLN,J.FD,KK_COMMON.GETTD,NULL,PPROCN)
   RETURNING N INTO PPROCN;

  PROBJN:= KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PID', VPALLN);
  PROBJN:= KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CONTRAGENT_N', VCONTRAGENTN);

 VRET := 1;
 ELSE
   VOK := 0;

   VRET := 2;
 END IF;

IF J.TYP > 0 AND VRET = 1 THEN

 SELECT TERM INTO VTERM
  FROM DIC_DATA WHERE
   UP = 416
    AND CODE = J.TYP
    AND SYSDATE BETWEEN FD  AND TD ;
END IF;

IF(NVL(LENGTH(PMSG),0) < 3000) THEN
  PMSG := PMSG || J.CODE ||' ' ||TO_CHAR(J.EXPIRE_DATE,'DD-MM-YYYY')||' '|| STOCKNBYNOMUNITS(J.NOMENKLATURA_N,J.CNT)||J.CNT ||' У.Е. ' ||VTERM ||V1310;
END IF;

VCNT :=J.CNT;
VINCNT:=J.IN_CNT;

END LOOP;

  IF VOK =1 THEN
  PMSG := 'ПАЛЛЕТА СОДЕРЖИТ ' ||V1310||PMSG;
  ELSE
  PMSG := 'ПАЛЛЕТА РАЗРОЗНЕНА . ДЕЙСТВИЯ С ПАЛЛЕТОЙ НЕВОЗМОЖНЫ. ПРИХОДОВАНО: '||VINCNT ||' В СТОКЕ: '||VCNT ||V1310||PMSG;
  END IF;

/*WORK*/

/*
INSERT INTO CELL_ADDRESS_BLOCKED
(N,FD,TD,STORE_N,FLOR,LINE,STAGE_FROM,STAGE_TO,PLACE_FROM,PLACE_TO,CONTRAGENT_N,NOMENKLATURA_N,CNT,ST_DOC_TYP,ST_DOC_N,DSC,EMP_N,TYP)
VALUES
(SQ_CELL_ADDRESS_BLOCKED.NEXTVAL,SYSDATE,SYSDATE + 5/1440,VSTOREN,VFLOR,VLINE,VSTAGE_FROM,0,VPLACE_FROM,0,VCONTRAGENT_N,VNOMENKLATURA_N,VCNT,0,0,'ЗАБЛОКИРОВАНО С ТЕРМИНАЛА ПОД ПЕРЕМЕЩЕНИЕ',VEMPN,0)
*/



RETURN VRET;
END INPUTPALLIDONCELL;


FUNCTION STDOCINPUTONSTOREJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER;
VSTOCKN INTEGER;
VCELLN INTEGER := -999;
VPALLN INTEGER;
VCELLTYPS VARCHAR2(2000);
VCELLADDR VARCHAR2(50);
VCODE  VARCHAR2(100);
VCELLTYP INTEGER;
VPART_IN_N INTEGER;
VCNT INTEGER;
VCNTFREE INTEGER;
VADDRCNT INTEGER;
VSTOREN INTEGER;
VST_DOC_N INTEGER;
VNOMENKLATURAN INTEGER;
VWEIGHT FLOAT;
VCOEFFICIENT FLOAT;
VCONTRAGENTN INTEGER;
VAUTOREFILLING INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VJOBN INTEGER;
VADDRNLIST VARCHAR2(3500) := ',';
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

PMSG := NULL;

UPDATE MCIS_NODES_PROC
 SET TD = SYSDATE - 1/86400
  WHERE ROWID IN
  (SELECT ROWID FROM MCIS_NODES_PROC
      WHERE N != PPROCN
   CONNECT BY PRIOR UP = N AND SYSDATE BETWEEN FD AND TD
 START WITH N = PPROCN AND SYSDATE BETWEEN FD AND TD
 );


SELECT VAL2 INTO VPALLN
 FROM MCIS_NODES_PROC WHERE N = PPROCN
  AND SYSDATE BETWEEN FD AND TD
  AND TYP =26;


   SELECT MAX(DISTRIB_ON_CELL) INTO VCNT
     FROM
   ST_DOC_IN_DET D
    WHERE D.PALL_N = VPALLN
        AND SYSDATE BETWEEN D.FD AND D.TD
       ;

-- IF VCNT = 2 THEN
--   RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА УЖЕ ПОСТАВЛЕНА!</ERR>');
-- END IF;

 IF VCNT NOT IN (1,2) THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА ПРИНЯТА НЕ ПО ШТРИХКОДИРОВАНЮ!</ERR>');
 END IF;

/*SELECT MIN(CONTRAGENT_N) INTO VCONTRAGENTN FROM ST_STOCK WHERE VPALLN = ST_PALL_N AND SYSDATE BETWEEN FD AND TD;
IF VCONTRAGENTN IS NULL THEN
    RETURN 3;
END IF;
SELECT KK_CONST.GETCONSTN ('STDOCMOVEAUTOREFILLINGSMALLCELL',SYSDATE,VCONTRAGENTN) INTO VAUTOREFILLING FROM DUAL;
*/

VCNT := 0 ;
FOR J IN (

SELECT
 A.CELL_ADDRESS_N
  ,CASE WHEN ST.N IS NULL THEN 1
        WHEN SYSDATE BETWEEN ST.FD AND ST.TD THEN 1
            ELSE 0 END AS OK
       ,D.SQ_ST_DOC_IN_N AS PART_IN_N
       ,A.N AS ST_DOC_N
       ,D.NOMENKLATURA_N
       ,I.CONTRAGENT_N
       ,A.CNT
       ,A.N
       ,J.N AS JOBN
       ,J.STATUS
 FROM ST_DOC_IN_DET D
              JOIN ST_DOC_IN_DET_ADDR A  ON (A.ST_DOC_IN_DET_N = D.N AND SYSDATE BETWEEN A.FD AND A.TD)
              JOIN ST_BAR_JOBS J ON (J.TYP = 11 AND J.BASE_DOC_N = D.SQ_ST_DOC_IN_N
               AND J.ST_DOC_N = A.N AND J.STATUS IN (1,2/*,3*/))
   LEFT OUTER JOIN ST_STOCK ST ON (ST.ST_DOC_N = A.N AND ST.UP = 0)
   LEFT OUTER JOIN ST_DOC_IN I ON (D.SQ_ST_DOC_IN_N = I.N)
 WHERE D.TYP =1
AND D.PALL_N = VPALLN
AND SYSDATE BETWEEN D.FD AND D.TD
       ) LOOP

       /*IF J.STATUS = 3 THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>УЖЕ РАССТАВЛЕНА!</ERR>');
       END IF;*/ --У КПД ЕСТЬ РАССТАНОВКА НА ТРАНЗИТНЫЕ АДРЕСА

SELECT KK_CONST.GETCONSTN ('STDOCMOVEAUTOREFILLINGSMALLCELL',SYSDATE,J.CONTRAGENT_N) INTO VAUTOREFILLING FROM DUAL;

VCNT := 1;



 IF ((VCELLN = -999) OR (VCELLN = J.CELL_ADDRESS_N)) AND J.OK = 1 THEN
      VCELLN := J.CELL_ADDRESS_N ;
      VPART_IN_N := J.PART_IN_N;
      VST_DOC_N := J.ST_DOC_N;
      VNOMENKLATURAN := J.NOMENKLATURA_N;
      VADDRCNT := J.CNT ;
     VADDRNLIST := VADDRNLIST || J.N ||',';

  /*СТАТУС ЗАДАНИЯ В РАБОТЕ*/
  KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,J.JOBN,0,0,NULL,NULL,NULL,2,KK_COMMON.GETTD,NULL,VEMPN,0);



 ELSE

   EXIT;

--   IF VAUTOREFILLING <> 1 THEN
--     RETURN 2;
--   END IF;
 END IF;


END LOOP;

  IF VCNT = 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'ЗАДАНИЯ ДЛЯ ПАЛЛЕТА НЕТ!');
  END IF;


  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ADDRNLIST',VADDRNLIST); -- ПЕРЕМЕННАЯ КТО ЮЗЕР


-- УХОДИМ НА ВЕТКУ ПРОЦЕДУРЫ С АВТОПОПОЛНЕНИЕМ МЕЛКОЯЧЕЕСТОЙ ПОДБОРКИ
--IF VAUTOREFILLING = 1 THEN
--  RETURN 4;
--END IF;

SELECT KK_CONST.GETCONSTV('CELLTYPFORUNADDRESSSTORAGE',SYSDATE,0) INTO VCELLTYPS FROM DUAL;

IF VCELLN = -999 THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>РАССТАНОКА НЕВОЗМОЖНА, ПАЛЛЕТА УЖЕ В СТОКЕ!!!</ERR>');
ELSE
BEGIN
SELECT ADDR,CELL_TYP_N,STORE_N INTO VCELLADDR,VCELLTYP,VSTOREN
 FROM CELL_ADDRESS WHERE
       N = VCELLN
   AND SYSDATE BETWEEN FD AND TD;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
          RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА НЕ НАЙДЕНА CELL_ADDRESS.N = '||VCELLN||'</ERR>');
END;

END IF; --IF VCELLN = -999 THEN


 IF INSTR(VCELLTYPS,','||VCELLTYP||',')=0 THEN
 PMSG :=  'ПАЛЛЕТА '||VPALLN||' НА АДРЕС '||VCELLADDR || V1310;


INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,24/*ВЫЯСНЯЕМ ЧТО И КУДА ПОСТАВИТЬ*/,VPALLN,VCELLN,VPART_IN_N,VSTOREN,SYSDATE,KK_COMMON.GETTD,VCELLADDR,PPROCN,VST_DOC_N)
   RETURNING N INTO PPROCN;

 ELSE

--- ВЕС ПАЛЛЕТЫ

BEGIN

SELECT SUM(WEIGHT) INTO VWEIGHT
FROM (
SELECT S.CONTRAGENT_N, S.NOMENKLATURA_N, SUM(S.CNT * NU.WEIGHT) AS WEIGHT
    FROM ST_STOCK S
    LEFT OUTER JOIN (
         SELECT N.N, NU.WEIGHT
           FROM NOMENKLATURA N, NOM_UNIT NU
           WHERE N.N = NU.NOMENKLATURA_N AND N.UNIT = NU.UNIT_TYP AND SYSDATE BETWEEN N.FD AND N.TD
                    ) NU ON (S.NOMENKLATURA_N = NU.N)
    WHERE S.ST_PALL_N = VPALLN AND SYSDATE BETWEEN S.FD AND S.TD
    GROUP BY S.CONTRAGENT_N, S.NOMENKLATURA_N);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
   VWEIGHT := 0;
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА В ЗАДАНИЯХ НА РАССТАНОВКУ НЕ ЧИСЛИТСЯ!</ERR>');
END;

 PMSG := VADDRCNT || 'У.Е. PID-'||VPALLN||'(ВЕС -'||VWEIGHT||'КГ) НА АДРЕС '||VCELLADDR||CHR(13)||' УЖЕ НА АДРЕСАХ.';

  FOR J IN (SELECT ADDR FROM
(
SELECT/*+ ORDERED*/ A.ADDR||'  '||SUBSTR(T.NAME,1,10) AS ADDR
               FROM
                  (SELECT DISTINCT CELL_ADDRESS_N
                      FROM V_ST_STOCK_ACTIVE
                       WHERE NOMENKLATURA_N = VNOMENKLATURAN
                         ) N ,
                   CELL_ADDRESS A,
                   CELL_TYP T
                       WHERE N.CELL_ADDRESS_N = A.N
                            AND SYSDATE BETWEEN A.FD AND A.TD
                            AND T.N = A.CELL_TYP_N2
                            AND SYSDATE BETWEEN T.FD AND T.TD
                            ORDER BY DECODE(T.TYP,5,-1,T.TYP)
                       ) WHERE  ROWNUM <5
              ORDER BY ROWNUM) LOOP
     PMSG :=  PMSG ||V1310|| J.ADDR ;
    END LOOP;





INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,25/*ВЫЯСНЯЕМ ЧТО И КУДА ПОСТАВИТЬ*/,VPALLN,VCELLN,VPART_IN_N,VSTOREN,SYSDATE,KK_COMMON.GETTD,VCELLADDR,PPROCN,VST_DOC_N)
   RETURNING N INTO PPROCN;

 END IF;

/*ПРИ ВЗЯТИИ ЗАДАНИЯ С ТЕРПИНАЛА НА РАССТАНОВКУ ПРИХОДА ПОКАЗЫВАТЬ ЧТО НА ЭТОЙ ПАЛЛЕТЕ BEGIN
*/
FOR J IN (
        SELECT X.CODE, X.CNT, ROWNUM AS RN FROM
        (
        SELECT /*+ ORDERED*/
          N.CODE||' ('||SUBSTR(REPLACE(N.NAME,N.CODE,''),1,10)||') ' AS CODE,
          SUM(A.CNT) AS CNT
        FROM ST_DOC_IN_DET D
              JOIN ST_DOC_IN_DET_ADDR A  ON (A.ST_DOC_IN_DET_N = D.N AND SYSDATE BETWEEN A.FD AND A.TD
              AND A.CELL_ADDRESS_N = VCELLN)
              JOIN ST_BAR_JOBS J ON (J.TYP = 11 AND J.BASE_DOC_N = D.SQ_ST_DOC_IN_N
                                 AND J.ST_DOC_N = A.N AND J.STATUS IN (1,2,3))
              JOIN NOMENKLATURA N ON (N.N = A.NOMENKLATURA_N AND SYSDATE BETWEEN N.FD AND N.TD)
        WHERE D.TYP =1
        AND D.PALL_N = VPALLN
         AND SYSDATE BETWEEN D.FD AND D.TD
        GROUP BY  N.CODE,N.NAME
        ) X
       ) LOOP

       PMSG :=  SUBSTR(PMSG ,1,2000) || J.CODE||' '||J.CNT||'У.Е'||V1310 ;

       END LOOP;
/*ПРИ ВЗЯТИИ ЗАДАНИЯ С ТЕРПИНАЛА НА РАССТАНОВКУ ПРИХОДА ПОКАЗЫВАТЬ ЧТО НА ЭТОЙ ПАЛЛЕТЕ END
*/





RETURN 1;

END;

FUNCTION STDOCINPUTONEMPTYCELL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS

VFD DATE := SYSDATE;
BEGIN
-- RAISE_APPLICATION_ERROR(-20000,'ASDFASDF');
FOR J IN (SELECT ROWID AS RD
    FROM MCIS_NODES_PROC P
               WHERE TYP = 24
           CONNECT BY PRIOR  UP =N  AND VFD BETWEEN FD AND TD
               START WITH N= PPROCN AND VFD BETWEEN FD AND TD
) LOOP

UPDATE MCIS_NODES_PROC
 SET TYP = 25 WHERE
  ROWID = J.RD ;

END LOOP;



RETURN 1;

EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
     RAISE_APPLICATION_ERROR(-20000,'STDOCINPUTONEMPTYCELL PPROCN:'||PPROCN||' '||SQLERRM);

END;


FUNCTION STDOCINPUTONTRANSITCELL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
VRET INTEGER := 5;
VOK INTEGER;
BEGIN

FOR J IN (SELECT VAL1,VAL2,VAL3,VAL4,VAL5,DSC,TYP
    FROM MCIS_NODES_PROC
 CONNECT BY PRIOR UP = N
  START WITH N =PPROCN
   ORDER BY  LEVEL DESC
) LOOP


  IF J.TYP = 26 THEN
   VPALLN :=  J.VAL2;
  END IF;

  IF J.TYP = 13  THEN

--RAISE_APPLICATION_ERROR(-20000,J.VAL1);

    BEGIN -- ПРОВЕРЯЕМ ТИП ЯЧЕЙКИ ТРАНЗИТНЫЙ ЛИ
  SELECT CASE WHEN KK_CONST.GETCONSTV ('CELLTYPFORTRANSITCELLADDRESS',SYSDATE,0)  LIKE '%,' || CELL_TYP_N ||',%' THEN 1 ELSE 0 END
     INTO VOK
       FROM CELL_ADDRESS A
        WHERE A.N = J.VAL1
       AND SYSDATE BETWEEN FD AND TD;
    EXCEPTION
      WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
        PPROCN :=0;
        RETURN 4;
    END;


    --ЕСЛИ ТРАНЗИТНЫЙ ТО ПОКАЗЫВАЕМ ЭТО В ПРОТОКОЛЕ ЗАДАНИЯ И ВСЕ
    IF VOK = 1 THEN

    FOR K IN (
    SELECT A.N AS ST_DOC_N
    FROM ST_DOC_IN_DET DT
           JOIN ST_DOC_IN_DET_ADDR A ON (A.ST_DOC_IN_DET_N = DT.N
                       AND SYSDATE BETWEEN A.FD AND A.TD )

     WHERE DT.PALL_N = VPALLN
  AND SYSDATE BETWEEN DT.FD AND DT.TD



 ) LOOP

-- RAISE_APPLICATION_ERROR(-20000,'11111');

       KK_ST_BAR_JOBS.COMPLETEJOB(
        PROBJN => PROBJN
       ,PJOBN => 0
       ,PJOBTYP  => 11
       ,PJOBDOCN => K.ST_DOC_N
       ,PVAL1  =>   NULL
       ,PDSC  =>   'НА ТРАНЗИТ '|| J.VAL4
       ,PVAL2  =>  J.VAL1
       ,PSTATUS  =>  1
       ,PTD  =>  KK_COMMON.GETTD
       ,PVAL3  =>   NULL
       ,PEMPN  =>   NULL
       ,PRECREATESTATUS  =>  3
       ,PCELLADDRESSN => 0
       );
 --       COMPLETEJOB (PROBJN ,0,11,K.ST_DOC_N,NULL,NULL,J.VAL1,NULL,KK_COMMON.GETTD) ;


    END LOOP;

     VRET :=1;

    ELSE
     KK_COMMON.ERR_LOG('STDOCINPUTONTRANSITCELL',SQLCODE,'CELL='||J.VAL1||' '||SQLERRM);
     PPROCN :=0;
      RETURN 3; -- ЭТО НЕ ТРАНЗИТНАЯ ЯЧЕЙКА
    END IF; --IF VOK = 1 THEN


 END IF; --13

END LOOP;

PPROCN :=0;
RETURN VRET;
END;

FUNCTION CHEQUEADDRESSFORPUTIN(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCELLN INTEGER;
VPALLN INTEGER;
VSIZE_ INTEGER;
VPALL_TYP INTEGER;
VSTOREN INTEGER;
VEMPTY NUMBER;
VCELL_TYP_N INTEGER;
VADDR VARCHAR2(50);
VCNTBLOCK INTEGER;
VCELL_TYP_N_FROM INTEGER;
VCELL_TYP_N_TO INTEGER;
K INTEGER;
VADDRNLIST  ST_BARCODE_VARIABLES.VAR_VALUE%TYPE;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

   VCELLN := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS_N');

   VPALLN := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');

  /*    ПРИ РАЗМЕЩЕНИИ ПАЛЛЕТЫ ЧЕРЕЗ ЧЕРМИНАЛ (ЧЕРЕЗ 3 - ПОСТАВИТЬ НА СВОБОДНУЮ ЯЧЕЙКУ)
      НУЖНА ПРОВЕРКА НА ТИП ЯЧЕЙКИ. НЕЛЬЗЯ РАЗМЕЩАТЬ ПАЛЛЕТ НА ЯЧЕЙКИ С ТИПОМ "ХРАНЕНИЕ И ПОДБОРКА БРАКА"
  */
  VADDRNLIST := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ADDRNLIST');
  FOR K IN (
           SELECT A.CELL_ADDRESS_N
           FROM ST_DOC_IN_DET D
           JOIN ST_DOC_IN_DET_ADDR A  ON (A.ST_DOC_IN_DET_N = D.N AND SYSDATE BETWEEN A.FD AND A.TD
                                      AND VADDRNLIST LIKE '%'||A.N||'%' -- НАХУЯ ЭТО ОБЪЯСНИТЕ!!! ЕВГРАФОВ!

                                       )
           JOIN ST_DOC_IN DOC ON (DOC.N = D.SQ_ST_DOC_IN_N AND SYSDATE BETWEEN DOC.FD AND DOC.TD )
           LEFT OUTER JOIN ST_STOCK ST ON (ST.ST_DOC_N = A.N)
           WHERE D.TYP =1
           AND D.PALL_N = VPALLN
           AND SYSDATE BETWEEN D.FD AND D.TD

           )
  LOOP
     SELECT DECODE(NVL(CELL_TYP_N,0),-3,-3,1) INTO VCELL_TYP_N_FROM
     FROM CELL_ADDRESS WHERE N = K.CELL_ADDRESS_N
      AND SYSDATE BETWEEN FD AND TD;

     SELECT DECODE(NVL(CELL_TYP_N,0),-3,-3,1) INTO VCELL_TYP_N_TO
     FROM CELL_ADDRESS WHERE N = VCELLN
     AND SYSDATE BETWEEN FD AND TD;

/*     IF VCELL_TYP_N_FROM = -3 AND VCELL_TYP_N_TO = 1 THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВОЗМОЖНО РАЗМЕЩАТЬ ТОВАР ИЗ БРАКА В КОНДИЦИЮ!!!</ERR>');
     END IF;

     IF VCELL_TYP_N_FROM = 1 AND VCELL_TYP_N_TO = -3 THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВОЗМОЖНО РАЗМЕЩАТЬ ТОВАР ИЗ КОНДИЦИИ В ЯЧЕЙКИ БРАКА!!!</ERR>');
     END IF;
*/
  END LOOP;

SELECT A.SIZE_,A.PALL_TYP,A.STORE_N,A.CELL_TYP_N,A.ADDR
 INTO VSIZE_ ,VPALL_TYP ,VSTOREN,VCELL_TYP_N,VADDR
 FROM CELL_ADDRESS A
  WHERE A.N =VCELLN
  AND SYSDATE BETWEEN A.FD AND A.TD;

PMSG :=' ПОСТАВЛЕН НА '|| VADDR;

IF VCELL_TYP_N NOT IN (-5,-1) THEN
    VEMPTY := KK_ST_ALLOC.GETLEFTOFADDRESS(VCELLN,VSIZE_,1,VPALL_TYP,VSTOREN, 0, 0, 0, VPALLN,0/*,1*/);

--    KK_COMMON.ERR_LOG('CHEQUEADDRESSFORPUTIN',VCELLN,'VEMPTY='||VEMPTY||'; VSIZE_='||VSIZE_);

 IF (VEMPTY < 0)
    OR
  (NVL(VSIZE_,0) <> 0 AND VEMPTY = 0) THEN  -- PAVEL 23.06.2010
   VEMPTY := ABS(VEMPTY) + VSIZE_;
   PMSG := NULL;
FOR J IN (

    SELECT/*+ ORDERED*/
    'ST P-'||ST.ST_PALL_N ||' '|| N.CODE ||' '||N.NAME  AS NAME , SUM(ST.CNT) AS CNT
    FROM
    /*СЧИТАЕМ СКОЛЬКО ПАЛЛЕТ В ЯЧЕЙКЕ KK_ST_BARCODE.WHATONCELLADDRESS*/
    ST_STOCK ST
     JOIN NOMENKLATURA N ON (N.N = ST.NOMENKLATURA_N AND SYSDATE BETWEEN N.FD AND N.TD)
    WHERE ST.CELL_ADDRESS_N = VCELLN
    AND ST.ST_PALL_N > 0
    AND SYSDATE BETWEEN ST.FD AND ST.TD
    GROUP BY ST.ST_PALL_N, N.CODE , N.NAME
UNION ALL
      SELECT/*+ ORDERED*/
     'IN '||I.NUM_ACT||' P-'||D.PALL_N ||' '|| N.CODE ||' '||N.NAME  AS NAME , SUM(A.CNT) AS CNT

    FROM ST_DOC_IN I
    JOIN ST_DOC_IN_DET D ON (
                                     SYSDATE BETWEEN D.FD AND D.TD
                                 AND D.PALL_N > 0
                                 AND D.SQ_ST_DOC_IN_N = I.N
                                 AND D.TYP = 1
                             )
    JOIN  ST_DOC_IN_DET_ADDR A ON (
                                  A.CELL_ADDRESS_N = VCELLN
                                  AND A.ST_DOC_IN_DET_N = D.N
                                   AND SYSDATE BETWEEN A.FD AND A.TD)
     JOIN NOMENKLATURA N ON (N.N = D.NOMENKLATURA_N AND SYSDATE BETWEEN D.FD AND D.TD)
    WHERE 1=1
         AND I.STATUS NOT IN (4)
         AND SYSDATE BETWEEN I.FD AND I.TD
      GROUP BY I.NUM_ACT, D.PALL_N ,N.CODE , N.NAME

) LOOP
  PMSG := PMSG  || J.NAME || ' ' || J.CNT || V1310;
END LOOP;


  RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА ЗАПОЛНЕНА!! '|| VEMPTY || '; РАЗМЕР:'||VSIZE_||' НАЙДИТЕ ДРУГУЮ ЯЧЕЙКУ!'||PMSG||'</ERR>');
 END IF;

END IF;--IF VCELL_TYP_N NOT IN (-5,-1) THEN


  SELECT/*+ INDEX(BL CELL_ADDRESS_BLOCKED_ADDR_TD)*/
        COUNT(1) INTO VCNTBLOCK
  FROM CELL_ADDRESS_BLOCKED_X BL
  WHERE BL.CELL_ADDRESS_N = VCELLN AND
  SYSDATE BETWEEN BL.FD AND BL.TD;

IF NVL(VCNTBLOCK,0) > 0 THEN
  RAISE_APPLICATION_ERROR(-20000,  '<ERR>ЯЧЕЙКА БЛОКИРОВАНА *' ||  PSTR  ||  '* *' || PKEYCODE||  '* </ERR>' );
END IF;

RETURN 1;
END CHEQUEADDRESSFORPUTIN;

FUNCTION STDOCINPUTONSTORESUBMIT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPALLN INTEGER;
--VINDOCN INTEGER;
VRET INTEGER := 0;
VSTDOCMOVETYP INTEGER ;
VSTDOCMOVEN INTEGER := 0;
--VCONTRAGENTN INTEGER;
--VNOMENKLATURAN INTEGER;
VFD DATE := SYSDATE;
--VEXPIRE_DATE DATE ;
--VCNT INTEGER ;
VCELL_ADDRESS_N INTEGER := -999 ;
VCELL_ADDRESS_NAME VARCHAR2(50);
--VNOM_TYP INTEGER ;
VSTOREN INTEGER ;
VNDET INTEGER;
VPARENT_DOC INTEGER;
VWHATWASNODE INTEGER;
VDOCINDETADDRN INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'); -- ПЕРЕМЕННАЯ КТО ЮЗЕР
VNOTMOVECOUNT INTEGER ; -- СКОЛЬКО ЕЩЕ НЕ РАССТАВИЛИ
VRD ROWID;
VXRET INTEGER := 0;
VPALLS VARCHAR2(4000);
VNEEDDEFINECONTRAGENTAREA INTEGER ;
VADDRNLIST VARCHAR2(2500);
VLEFTOFSIZE NUMBER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

   VPALLN := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');


FOR J IN (SELECT ROWID AS RD,P.* FROM MCIS_NODES_PROC P
           CONNECT BY PRIOR  UP =N  AND VFD BETWEEN FD AND TD
               START WITH N= PPROCN AND VFD BETWEEN FD AND TD
               ORDER BY LEVEL DESC ) LOOP

--  IF J.TYP = 26  THEN   --
--   VPALLN :=  J.VAL2;
--  END IF;

  IF J.TYP = 24   THEN
    VWHATWASNODE := J.TYP;
    VCELL_ADDRESS_N := J.VAL2;
    VPARENT_DOC := J.VAL3;
    VDOCINDETADDRN := J.VAL5;
  END IF; --IF J.TYP = 24  THEN


  IF J.TYP = 25  THEN
   VPALLN := J.VAL1 ;
   VPARENT_DOC := J.VAL3;
   VSTOREN :=  J.VAL4;
   VWHATWASNODE := J.TYP;
   VDOCINDETADDRN := J.VAL5;
   VCELL_ADDRESS_N := J.VAL2;
  END IF; --IF J.TYP = 25  THEN

  IF J.TYP = 13   THEN
       VCELL_ADDRESS_NAME := J.VAL4;



     IF J.VAL2 != VSTOREN THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС НАЗНАЧЕНИЯ ПРИНАДЛЕЖИТ ДРУГОМУ СКЛАДУ!!! </ERR>''J.VAL2='||J.VAL2 ||' VSTOREN='||VSTOREN ||' PPROCN='||PPROCN);
     END IF; --IF J.VAL2 != VSTOREN THEN


    --  RAISE_APPLICATION_ERROR(-20000,VWHATWASNODE ||' '|| VCELL_ADDRESS_N);


  IF VWHATWASNODE = 25 THEN

VADDRNLIST :=    KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ADDRNLIST');
      --RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС !!! </ERR>''VADDRNLIST='||VADDRNLIST );

    FOR K IN (
SELECT
  CASE WHEN ST.N IS NULL THEN 1
        WHEN SYSDATE BETWEEN ST.FD AND ST.TD THEN 1
            ELSE 0 END AS OK,
      A.CELL_ADDRESS_N ,DOC.CONTRAGENT_N,D.NOMENKLATURA_N,D.EXPIRE_DATE,D.MAKE_DATE,A.CNT,A.NOM_TYP,A.STORE_N
      , ST.N,A.N AS ST_DOC_N
      ,ST.ROWID AS RD
      ,A.ROWID AS ADDR_RD
 FROM ST_DOC_IN_DET D
   JOIN ST_DOC_IN_DET_ADDR A  ON (A.ST_DOC_IN_DET_N = D.N AND SYSDATE BETWEEN A.FD AND A.TD
   AND VADDRNLIST LIKE '%'||A.N||'%'
   )
   JOIN ST_DOC_IN DOC ON (DOC.N = D.SQ_ST_DOC_IN_N AND SYSDATE BETWEEN DOC.FD AND DOC.TD )
   LEFT OUTER JOIN ST_STOCK ST ON (ST.ST_DOC_N = A.N)
 WHERE D.TYP =1
 AND D.PALL_N = VPALLN
 AND SYSDATE BETWEEN D.FD AND D.TD
 AND VCELL_ADDRESS_N = A.CELL_ADDRESS_N
 ) LOOP

    IF ((VCELL_ADDRESS_N = -999) OR (VCELL_ADDRESS_N = K.CELL_ADDRESS_N)) AND K.OK = 1 AND NVL(VPALLN,0) > 0 THEN
         VCELL_ADDRESS_N := K.CELL_ADDRESS_N ;

     DECLARE
     VCELLCNT INTEGER;
     VNEEDDEFINECONTRAGENTAREA INTEGER := KK_CONST.GETCONSTN('NEEDDEFINECONTRAGENTAREA',SYSDATE,K.CONTRAGENT_N);
     BEGIN

--  RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС !!! </ERR>''VADDRNLIST='||J.VAL1 );

 SELECT COUNT(1) INTO VCELLCNT
  FROM CELL_ADDRESS AD
      WHERE AD.N= J.VAL1
    AND SYSDATE BETWEEN AD.FD AND AD.TD
    AND (AD.STORE_AREA IN (
     SELECT DISTINCT AR.N
            FROM STORE_AREA AR
                  CONNECT BY PRIOR AR.N = AR.UP
                         AND SYSDATE BETWEEN AR.FD AND AR.TD
  START WITH AR.N IN (SELECT CS.STORE_AREA_N
                     FROM  CONTRAGENT_STORE_AREA CS
                       WHERE CS.CONTRAGENT_N = K.CONTRAGENT_N
                         AND SYSDATE BETWEEN CS.FD AND CS.TD
                          )
            AND SYSDATE BETWEEN AR.FD AND AR.TD
            AND AR.STORE_N = AD.STORE_N
 )  OR VNEEDDEFINECONTRAGENTAREA = 0) ;

    IF VCELLCNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'ЯЧЕЙКА НЕ ПРИНАДЛЕЖИТ ОБЛАСТИ КОНТРАГЕНТА!');
    END IF;


     END; --DECLARE


 IF K.RD IS NOT NULL THEN

 SELECT ROWID INTO VRD
  FROM ST_STOCK
   WHERE
   ROWID = K.RD
    FOR UPDATE NOWAIT;

 IF VSTDOCMOVEN = 0 THEN
    BEGIN
     SELECT KK_CONST.GETCONSTN ('STDOCMOVETYPFORDISTRIBSTDOCIN',VFD,VSTOREN) INTO VSTDOCMOVETYP FROM DUAL;
      SELECT N INTO VSTDOCMOVEN
        FROM ST_DOC_MOVE M
          WHERE
           M.TYP = VSTDOCMOVETYP
            AND M.PARENT_DOC =  VPARENT_DOC
            AND SYSDATE BETWEEN FD AND TD;

     EXCEPTION
     WHEN NO_DATA_FOUND THEN
      VSTDOCMOVEN := KK_ST_DOC.CREATESTDOCMOVEHEADER(0 ,K.CONTRAGENT_N ,'СОЗДАНО С ТЕРМИНАЛА ПРИ РАЗМЕЩЕНИИ ПРИХОДА' ,VFD,3/*DIC 466 ПОДТВЕРЖДЕН СРАЗУ*/,VPARENT_DOC,VSTDOCMOVETYP,VEMPN);

      UPDATE ST_DOC_MOVE
       SET MOVE_DATE = FD,
          STATUS_DATE =FD
       WHERE N = VSTDOCMOVEN
        AND SYSDATE BETWEEN FD AND TD ;

     END;
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_MOVE.N',VSTDOCMOVEN);
    END IF; --IF VSTDOCMOVEN = 0 THEN

  INSERT INTO ST_DOC_MOVE_DET
  (N, ST_DOC_MOVE_N, NOMENKLATURA_N, EXPIRE_DATE,MAKE_DATE,   CNT,   CELL_ADDRESS_N, CELL_ADDRESS_NEW_N, DSC, FD,STOCK_N,NOM_TYP,LEFT,ST_PALL_N)
     VALUES
    (SQ_ST_DOC_DET.NEXTVAL, VSTDOCMOVEN, K.NOMENKLATURA_N, K.EXPIRE_DATE,K.MAKE_DATE,  K.CNT,   K.CELL_ADDRESS_N , J.VAL1, 'СОЗДАНО С ТЕРМИНАЛА ПРИ РАЗМЕЩЕНИИ ПРИХОДА ПАЛЛЕТА '|| VPALLN, VFD,K.N,K.NOM_TYP,0,VPALLN)
   RETURNING
      N
    INTO
  VNDET;


    KK_COMMON.ACTION(VEMPN,'ST_DOC_MOVE_DET',VNDET,1,SYSDATE);
VXRET :=    KK_ST_DOC_NEW.ST_MOVE2( VSTDOCMOVEN ,K.CONTRAGENT_N,VFD,K.STORE_N ,VNDET,1 /*PIGNOREBLOCK */ ) ;

  ELSE -- ЕСЛИ ЕЩЕ НЕ В СТОКЕ

   SELECT ROWID INTO VRD
    FROM ST_DOC_IN_DET_ADDR
     WHERE ROWID = K.ADDR_RD
      FOR UPDATE NOWAIT;


    UPDATE  ST_DOC_IN_DET_ADDR
     SET CELL_ADDRESS_N =  J.VAL1
      WHERE ROWID = VRD
      RETURNING N INTO VDOCINDETADDRN;
      KK_COMMON.ACTION(VEMPN,'ST_DOC_IN_DET_ADDR',VDOCINDETADDRN,3,SYSDATE,'ПОСТАВИЛ НА СВОБОДНУЮ!');

  END IF;   -- ЕСЛИ ЕЩЕ НЕ В СТОКЕ


--BEGIN
-------------------------------ПРОВЕРЯЕМ ЭТОТ АДРЕС
--SELECT KK_ST_ALLOC.GETLEFTOFADDRESS(A.N
--,A.SIZE_
--,/*PCEILCELL => */0
--, /*PCELLADDRPALLTYP =>*/ A.PALL_TYP
--,A.STORE_N
--, /*PNOMENKLATURAN*/ 0
--, /*PSTDOCMOVEN*/ 0,/*PRAISE*/ 0, /*PPALLN*/ VPALLN )
---INTO VLEFTOFSIZE
-- FROM CELL_ADDRESS A
--WHERE A.N = J.VAL1
--AND SYSDATE BETWEEN A.FD AND A.TD--
--AND A.SIZE_ != 0 ;


--IF VLEFTOFSIZE <=0 THEN
--RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА ЗАНЯТА</ERR>');
--END IF;

--EXCEPTION
--  WHEN NO_DATA_FOUND THEN
---          NULL;
--END;

--    KK_ST_BAR_JOBS.COMPLETEJOB  (PROBJN ,0,11,K.ST_DOC_N,NULL,NULL,J.VAL1) ;


  KK_ST_BAR_JOBS.COMPLETEJOB(
        PROBJN => PROBJN
       ,PJOBN => 0
       ,PJOBTYP  => 11
       ,PJOBDOCN => K.ST_DOC_N
       ,PVAL1  =>   NULL
       ,PDSC  =>   NULL
       ,PVAL2  =>  J.VAL1
       ,PSTATUS  =>  3
       ,PTD  =>  SYSDATE
       ,PVAL3  =>   NULL
       ,PEMPN  =>   NULL
       ,PRECREATESTATUS  =>  0
       ,PCELLADDRESSN => J.VAL1
       );

     VRET :=1;
    ELSE
      RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС НАЧАЛЬНЫЙ ДОЛЖЕН ОТЛИЧАТЬСЯ ОТ КОНЕЧНОГО'||V1310||'ЗАПИСЬ В СТОКЕ ДОЛЖНА БЫТЬ АКТИВНА</ERR>');
    END IF;

    END LOOP;

  ELSE  -- WAS 25


 -- RAISE_APPLICATION_ERROR(-20000,J.VAL1 ||' '||VCELL_ADDRESS_N);

     IF J.VAL1 != VCELL_ADDRESS_N  THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС НАЗНАЧЕНИЯ НЕВЕРЕН! АДРЕС НАЗНАЧЕНИЯ _'||J.VAL1 ||'_'  || VCELL_ADDRESS_N||'_'  ||VCELL_ADDRESS_NAME||'</ERR>');
     END IF;

    IF NVL(VPALLN,0) >0 THEN

-- ЗАКРЫВАЕМ ВЫПОЛНЕНИЕ ВСЕХ ЗАДАЧ КОТОРЫЕ БЫЛИ ПОЭТО ПАЛЛЕТЕ, ИХ МБ НЕСКОЛЬКО ТК ПАЛЛЕТЫ СБОРНЫЕ БЫВАЮТ
   FOR XX IN ( SELECT/*+ORDERED*/ D.ROWID AS RD,A.N AS A_N
        FROM
/* KK_ST_BARCODE.STDOCINPUTONSTORESUBMIT ЗАКРЫВАЕМ ВЫПОЛНЕНИЕ ВСЕХ ЗАДАЧ КОТОРЫЕ БЫЛИ ПОЭТО ПАЛЛЕТЕ, ИХ МБ НЕСКОЛЬКО ТК ПАЛЛЕТЫ СБОРНЫЕ БЫВАЮТ */
        ST_DOC_IN_DET D
            , ST_DOC_IN_DET_ADDR A
           WHERE D.PALL_N =VPALLN
              AND D.SQ_ST_DOC_IN_N = VPARENT_DOC
              AND D.TYP =1
              AND SYSDATE BETWEEN D.FD AND D.TD
              AND A.ST_DOC_IN_DET_N = D.N
              AND SYSDATE BETWEEN A.FD AND A.TD
              AND A.CELL_ADDRESS_N = VCELL_ADDRESS_N ) LOOP

          KK_ST_BAR_JOBS.COMPLETEJOB  (PROBJN ,0,11,XX.A_N,NULL,NULL,VCELL_ADDRESS_N) ;
   END LOOP;

      VRET :=1;
      PPROCN :=0;
    ELSE
     RAISE_APPLICATION_ERROR(-20000,'<ERR>ПАЛЛЕТА НЕ ОПРЕДЕЛЕНА ОПЕРАЦИЯ НЕВОЗМОЖНА!</ERR>');
    END IF;




  END IF; -- WAS 25

  EXIT;

  END IF; --IF J.TYP = 13  THEN


UPDATE MCIS_NODES_PROC
 SET TD = SYSDATE
 WHERE ROWID = J.RD ;

END LOOP;
 /*ЗАДАНИЕ ВЫПОЛНЕНО*/

 IF VRET = 1 THEN


  ---ЗАПРОС КОТОРЫЙ ВОЗВРАЩАЕТ КОЛ-ВО НЕ РАСТАВЛЕННЫХ ПАЛЛЕТ В ПЕРЕМЕННУЮ VNOTMOVECOUNT

SELECT COUNT(ST_PALL_N), SUBSTR(STRAGG(ST_PALL_N),1,1500)
INTO VNOTMOVECOUNT,VPALLS
 FROM (
SELECT DISTINCT ST_PALL_N AS  ST_PALL_N
   FROM ST_BAR_JOBS
  WHERE TYP =11
  AND BASE_DOC_N =  VPARENT_DOC
  AND SYSDATE BETWEEN FD AND TD
  AND STATUS IN (1,2)
  );


     PMSG := PMSG ||V1310|| 'ВЫ РАЗМЕСТИЛИ ПАЛЛЕТУ P-'||VPALLN|| ' НА АДРЕС '|| VCELL_ADDRESS_NAME ||' ЕСЛИ ВЫ ОШИБЛИСЬ ПОВТОРИТЕ ПРОЦЕДУРУ С ПАЛЛЕТОЙ';
      --- ЕСЛИ VNOTMOVECOUNT = 0 ТО VRET = 3 ИНАЧЕ VRET = 1
      IF VNOTMOVECOUNT = 0 THEN
        SELECT SUBSTR('<ERR>ВСЕ ПАЛЕТЫ АКТА ' || D.NUM_ACT || ' РАССТАВЛЕНЫ! ' || V1310||
        'КОНТРАГЕНТ ' || C.BRIEF||'</ERR>',1,4000) INTO PMSG
         FROM ST_DOC_IN D
          JOIN CONTRAGENT C ON ( D.CONTRAGENT_N = C.N AND SYSDATE BETWEEN C.FD AND C.TD)
           WHERE D.N = VPARENT_DOC
            AND SYSDATE BETWEEN D.FD AND D.TD ;
            /*PUTONSTORE*/
      ELSE
         SELECT SUBSTR('АКТ ' || D.NUM_ACT || ' НЕ РАССТАВЛЕНО '||VNOTMOVECOUNT || V1310|| VPALLS || V1310||
        'КОНТРАГЕНТ ' || C.BRIEF,1,4000) INTO PMSG
         FROM ST_DOC_IN D,
          CONTRAGENT C
           WHERE D.N = VPARENT_DOC
            AND SYSDATE BETWEEN D.FD AND D.TD
            AND D.CONTRAGENT_N = C.N
            AND SYSDATE BETWEEN C.FD AND C.TD ;
      END IF; --IF VNOTMOVECOUNT = 0 THEN
  END IF; --IF VRET = 1 THEN


 RETURN VRET ;
END;

FUNCTION GETNOMBYBARCODEX(PBARCODE VARCHAR2)RETURN VARCHAR2 IS
VRET VARCHAR2(4000);
VCNT INTEGER := 0 ;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN



FOR J IN (
 SELECT N.CODE ||' ' ||N.NAME AS NAME
   FROM NOM_BARCODE B,
      NOMENKLATURA N
 WHERE B.BAR_CODE = PBARCODE
  AND SYSDATE BETWEEN B.FD AND B.TD
  AND B.NOMENKLATURA_N = N.N
  AND SYSDATE BETWEEN N.FD AND N.TD
) LOOP
 VRET := SUBSTR( VRET || J.NAME ||V1310,1,2500) ;
 VCNT := VCNT +1;
END LOOP;

  IF VCNT = 0 THEN
    VRET := 'КОД НЕ ОПРЕДЕЛЕН';
  END IF;

--RAISE_APPLICATION_ERROR(-20000,LENGTH(VRET));

RETURN  DOUBLESTRING(VRET);

END;

FUNCTION  SHOWNOMUNIT2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 1;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
 PMSG := NULL;
 FOR J IN (   SELECT D.CODE , D.TERM
               FROM  DIC_DATA D
               WHERE  SYSDATE BETWEEN D.FD AND D.TD
                 AND D.UP= 362
                 AND D.CODE NOT IN (7)
                 ORDER BY  D.CODE
     ) LOOP
  PMSG := PMSG || J.CODE ||CHR(9) || J.TERM || V1310;
END LOOP;


 RETURN VRET ;
END SHOWNOMUNIT2 ;



FUNCTION  INPUTNOMUNIT2(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 1;
VNOMUNIT INTEGER ;
BEGIN
    SELECT D.CODE,  D.TERM INTO VNOMUNIT , PMSG
               FROM  DIC_DATA D
               WHERE  SYSDATE BETWEEN D.FD AND D.TD
                 AND D.UP= 362
                 AND D.CODE = TO_NUMBER(TRIM(PKEYCODE)) ;

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP',VNOMUNIT);
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_DSC',PMSG);


 RETURN VRET ;
END INPUTNOMUNIT2 ;


FUNCTION  SHOWNOMUNIT_DEF(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VCNT INTEGER := 0 ;
VUNITOPCNTX VARCHAR2(50):= KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.UNIT_CNT' );
VUNITOPCNT INTEGER;
VCONTRAGENTN INTEGER;
VUNITKGCNT NUMBER;
VUSEWEIGHTNOMUNIT LIST_CONST.VAL%TYPE;
-- В РМ. ПРИХОДНЫЙ АКТ ГАЛОЧКА ПОЗВОЛЯЮЩАЯ ПРИНИМАТЬ В ЧЕМ УГОДНО
VRET INTEGER := 2;
--VMSGX VARCHAR2(500);
VINPUTNOMBARCODELENGTH INTEGER;
VNAME VARCHAR2(400);
VTERM VARCHAR2(255);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
--VMSGX := PMSG;
--PMSG := NULL;

 --RAISE_APPLICATION_ERROR(-20000,PMSG);

 BEGIN

  SELECT NVL(TO_NUMBER(VUNITOPCNTX,'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0) INTO VUNITOPCNT FROM DUAL;

EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
       VUNITOPCNT := 0;
 END;



       FOR J IN (
       SELECT/*+ ORDERED*/ U.UNIT_TYP,POWER(U.UNIT_CNT,DECODE(U.CNT_EXPONENT,0,1,U.CNT_EXPONENT)) AS UNIT_CNT
        ,U.UNIT_TYP ||CHR(9)||DD.TERM||'('||

CASE WHEN NVL(DECODE(U.CNT_EXPONENT,0,1,U.CNT_EXPONENT),1) =  1 THEN U.UNIT_CNT||' '||LOWER(DD_NOM_UNIT.TERM)
     WHEN NVL(DECODE(U.CNT_EXPONENT,0,1,U.CNT_EXPONENT),1) = -1 THEN U.UNIT_CNT||' '||DD.TERM ||' В '||LOWER(DD_NOM_UNIT.TERM)
           END

        ||DECODE(U.UNIT_TYP,N.UNIT,' УЧ. ЕД.',N.UNIT_OP,' ОПЕР. ЕД.',NULL ) ||   ')'  AS MSG
        , COUNT(1) OVER (PARTITION BY 1) AS CNT
        ,LOWER(DD.TERM) AS DD_TERM
        ,DECODE(NVL(U.WEIGHT_NETTO,U.WEIGHT),0,U.WEIGHT,U.WEIGHT_NETTO) AS WEIGHT
        , N.CONTRAGENT_N
               FROM NOM_UNIT U
               JOIN NOMENKLATURA N ON (N.N = VNOMN
                   AND SYSDATE BETWEEN N.FD AND N.TD
                --/*УБРАЛИ ДЛЯ СВЕТЛАНЫ К*/   AND (NVL(N.UNIT_OP,0) = 0 OR N.UNIT_OP = U.UNIT_TYP  )
                   AND (VUNITOPCNT = 0 OR N.UNIT_OP = U.UNIT_TYP )
                   )
               JOIN DIC_DATA DD ON (DD.UP = 362 AND DD.CODE = U.UNIT_TYP AND SYSDATE BETWEEN DD.FD AND DD.TD)
               JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND SYSDATE BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)
               WHERE   U.NOMENKLATURA_N = VNOMN
                   AND SYSDATE BETWEEN U.FD AND U.TD
                   AND (INSTR(KK_CONST.GETCONSTV('STDOCIN.INBOUND.NOMUNITSLIST',SYSDATE,N.CONTRAGENT_N) ,
                   ','|| U.UNIT_TYP ||',' ) >0 OR
                   KK_CONST.GETCONSTV('STDOCIN.INBOUND.NOMUNITSLIST',SYSDATE,N.CONTRAGENT_N) = '0'
                   )
                    ) LOOP

   IF NVL(J.UNIT_CNT,0) =0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЕДИНИЦА ИЗМЕРЕНИЯ ПУСТА!! ПРОВЕРЬТЕ СПРАВОЧНИК НОМЕНКЛАТУР</ERR>');
   END IF;

  IF J.CNT = 1 THEN
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP,VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,48/*ЗАПОМНИЛИ СПИСОК ЕД ИЗМЕР*/,VNOMN,J.UNIT_TYP,J.UNIT_CNT,J.DD_TERM,SYSDATE,KK_COMMON.GETTD,J.MSG,PPROCN,J.WEIGHT)
   RETURNING N INTO PPROCN;
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP',J.UNIT_TYP);
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_CNT',J.UNIT_CNT);

      PMSG := PMSG  ||CHR(13)|| CHR(10)||J.MSG;
  IF VUNITOPCNT = 0 THEN
  DBMS_OUTPUT.PUT_LINE(' ');
    VRET := 1;
  ELSE -- ЕСЛИ СЧИТЫВАЛИ EAN UCC И В НЕМ БЫЛА ИНФОРМАЦИЯ О КОЛИЧЕСТВЕ ОПЕРАЦИОННЫХ ЕДИНИЦ НА ПАЛЛЕТЕ
   VRET := 3;
  END IF;
  END IF; --IF J.CNT = 1 THEN



  IF J.CNT >1 THEN
  INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP , VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,47/*ЗАПОМНИЛИ СПИСОК ЕД ИЗМЕР*/,VNOMN,J.UNIT_TYP,J.UNIT_CNT,J.DD_TERM,SYSDATE,KK_COMMON.GETTD,J.MSG,PPROCN,J.WEIGHT)
   RETURNING N INTO PPROCN;
      PMSG := PMSG  ||CHR(13)|| CHR(10)||J.MSG;
  END IF; --IF J.CNT >1 THEN

  VCNT := 1;

  VCONTRAGENTN := J.CONTRAGENT_N;
  END LOOP;

  VUSEWEIGHTNOMUNIT :=  KK_CONST.GETCONSTV('CONTRAGENT.USEWEIGHT.NOMUNIT',SYSDATE,VCONTRAGENTN);
  VINPUTNOMBARCODELENGTH :=  KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH',SYSDATE,VCONTRAGENTN);
 IF VUSEWEIGHTNOMUNIT != '_' THEN
  BEGIN
SELECT UNIT_CNT   INTO VUNITKGCNT
   FROM NOM_UNIT
    WHERE NOMENKLATURA_N = VNOMN
    AND SYSDATE BETWEEN FD AND TD
    AND INSTR(VUSEWEIGHTNOMUNIT,','||UNIT_TYP||',') > 0 ;
   PMSG := PMSG  ||CHR(13)|| CHR(10)||'ВЕСОВОЙ КВАНТ : ' ||VUNITKGCNT;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
  END;
 END IF;
  --RAISE_APPLICATION_ERROR(-20000, PMSG);

SELECT SUBSTR(N.CODE||' '||N.NAME,1,VINPUTNOMBARCODELENGTH) AS NAME
, NVL(DD.TERM,'НЕТ ТИПА')  AS TERM
INTO VNAME, VTERM
             FROM DUAL
                LEFT OUTER  JOIN NOMENKLATURA N ON (N.N = VNOMN AND SYSDATE BETWEEN N.FD AND N.TD )
                        LEFT OUTER JOIN DIC_DATA DD ON (N.TYP = DD.CODE AND DD.UP = 476
                                                AND SYSDATE BETWEEN DD.FD AND DD.TD);
--RAISE_APPLICATION_ERROR(-20012,VNAME);

IF VCNT = 0 THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>ДЛЯ НОМЕНКЛАТУРЫ '||VNAME||' НЕОПРЕДЕЛЕНЫ ЕДИНИЦЫ ИЗМЕРЕНИЯ! STDOCIN.INBOUND.NOMUNITSLIST</ERR>');
END IF;
 PMSG  := PMSG ||V1310 || VNAME || ' - ' || VTERM ;
--RAISE_APPLICATION_ERROR(-20000,VRET);
 IF VRET = 1 THEN
  BEGIN
   IF KK_CONST.GETCONSTN('SHOWIFSINGLEUNIT',SYSDATE,VCONTRAGENTN) != 0 THEN
    VRET := 2;
   END IF;
  EXCEPTION
   WHEN NO_DATA_FOUND THEN
    NULL;
  END;
 END IF;
 RETURN VRET;

END SHOWNOMUNIT_DEF;

FUNCTION SHOWNOMUNIT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
 VPROC VARCHAR2(255);
 VRET INTEGER;
BEGIN

 VPROC:= NVL(KK_CONST.GETCONSTV('SHOWNOMUNIT.USERPROC',SYSDATE, NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'),0)),'_');
  IF NVL(VPROC, '_') = '_'  THEN
        VRET := SHOWNOMUNIT_DEF(PKEYCODE,PSTR, PMSG,PNEXTNODE,PPROCN,PROBJN);
     ELSE
        EXECUTE IMMEDIATE 'BEGIN :PRESULT := '||VPROC||'(:PKEYCODE,:PSTR ,:PMSG ,:PNEXTNODE,:PPROCN,:PROBJN);  END;'
  USING OUT VRET, IN PKEYCODE, IN PSTR, IN OUT PMSG, IN OUT PNEXTNODE,IN OUT PPROCN,IN OUT PROBJN;
     END IF;

RETURN VRET;

END SHOWNOMUNIT;

FUNCTION INPUTNOMUNIT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VUNIT_TYP INTEGER ;
VUNIT_CNT INTEGER ;
VDIM  VARCHAR2(500);
VDIMEXISTS INTEGER;
VUNIT_N INTEGER;

VCONTRAGENTN INTEGER;
BEGIN

SELECT N.CONTRAGENT_N INTO VCONTRAGENTN
FROM NOMENKLATURA N
WHERE N = VNOMN AND N.TD =KK_COMMON.GETTD;

PMSG := NULL;

IF PSTR IS NOT NULL AND PKEYCODE IS NULL THEN -- СКАНИРОВАЛИ ШТРИХ КОД ОТ КАКОЙТО ЕД ИЗМЕР НОМЕНКЛАТУРЫ НУЖНО ЕЕ ОПРЕДЕЛИТЬ

BEGIN
 SELECT UNIT_TYP INTO  VUNIT_TYP
 FROM NOM_BARCODE B
  WHERE UPPER(TRIM(B.BAR_CODE)) =  UPPER(TRIM(PSTR))
  AND SYSDATE BETWEEN B.FD AND B.TD
  AND B.NOMENKLATURA_N = VNOMN
  AND ROWNUM <= 1
  AND B.UNIT_TYP > 0;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
RAISE_APPLICATION_ERROR(-20000,'<ERR>ЕДИНИЦА ИЗМЕРЕНИЯ ПО ШТРИХКОДУ НЕ ОПОЗНАНА! VNOMN='||VNOMN||' PSTR='||PSTR||'</ERR>');

END;
ELSE
  BEGIN
    VUNIT_TYP := TO_NUMBER(REPLACE(PKEYCODE,'.','ТАКНУЖНО'));
  EXCEPTION
    WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    VUNIT_TYP := NULL;
  END;
END IF; --IF PSTR IS NOT NULL THEN -- СКАНИРОВАЛИ ШТРИХ КОД ОТ КАКОЙТО ЕД ИЗМЕР НОМЕНКЛАТУРЫ НУЖНО ЕЕ ОПРЕДЕЛИТЬ

BEGIN
SELECT NU.UNIT_TYP, NU.UNIT_CNT,DD.TERM ||'('||NU.UNIT_CNT||')',NU.N
 INTO VUNIT_TYP,VUNIT_CNT ,PMSG, VUNIT_N
 FROM   NOM_UNIT NU
   JOIN DIC_DATA DD ON (DD.UP = 362 AND DD.CODE = NU.UNIT_TYP AND DD.TD = KK_COMMON.GETTD)
  WHERE NU.NOMENKLATURA_N  = VNOMN
   AND (NU.UNIT_TYP = VUNIT_TYP                    AND VUNIT_TYP IS NOT NULL
     OR NU.UNIT_TYP ||'.' ||NU.UNIT_CNT = PKEYCODE AND VUNIT_TYP IS     NULL )
    AND NU.TD = KK_COMMON.GETTD ;
EXCEPTION
  WHEN TOO_MANY_ROWS THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕСКОЛЬКО КОНВЕРТАЦИЙ! УТОЧНИТЕ '||VUNIT_TYP||'.КОЛВО </ERR>');
END;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP',VUNIT_TYP);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP.TERM', PMSG);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_CNT',VUNIT_CNT);


/*FOR J IN (SELECT ROWID AS RD,P.VAL1,P.VAL2,P.VAL3 ,P.DSC,P.VAL4,P.VAL5
               FROM MCIS_NODES_PROC P
                WHERE  TYP = 47
           CONNECT BY PRIOR  UP =N  AND SYSDATE BETWEEN FD AND TD
               START WITH N= PPROCN AND SYSDATE BETWEEN FD AND TD
               ORDER BY LEVEL DESC ) LOOP

 IF  J.VAL2 = VUNIT_TYP THEN

   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP , VAL5 )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,48ЗАПОМНИЛИ СПИСОК ЕД ИЗМЕР,J.VAL1,J.VAL2,J.VAL3,J.VAL4,SYSDATE,KK_COMMON.GETTD,J.DSC,PPROCN,J.VAL5)
   RETURNING N INTO PPROCN;
  PMSG := J.DSC;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_TYP',J.VAL2);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOMENKLATURA.UNIT_CNT',J.VAL3);
  EXIT;
 END IF;
 END LOOP;
*/

-- ПРОВЕРКА НА НАЛИЧИЕ ИЗМЕРЕНИЙ ВВЕДЕННОЙ ЕД.КОНВЕРТАЦИИ
 VDIMEXISTS := KK_ST_BARCODE.NOMCHECKDIMENTEXISTS(PNOMN =>VNOMN,PNOMUNIT => VUNIT_TYP,PROBJN => PROBJN,PNOMDIMENT => VDIM
                                                    ,PNOMUNITCNT => VUNIT_CNT, PNOMUNITN => VUNIT_N);
  IF (VDIMEXISTS = 1) AND ( KK_CONST.GETCONSTN('STDOCIN.NEEDINPUTNOMDIMENTIONS',SYSDATE,VCONTRAGENTN ) = 1) THEN
   PMSG := '<ERR>НУЖНО ПРОМЕРИТЬ!</ERR>';

   RETURN -2;
  END IF ;



IF PMSG IS NULL THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>НИЧЕГО НЕ ВЫБРАНО!</ERR>');
END IF;

RETURN 1;

END INPUTNOMUNIT;


FUNCTION  SHOWNOMUNIT2ALL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 1;
VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
  PMSG := NULL;
  FOR J IN (
     SELECT D.CODE , D.TERM||
            DECODE(NU.N,
                   NULL, '',
                   '('||NU.UNIT_CNT|| DD.TERM||')'
                   ) TERM
       FROM DIC_DATA D
       JOIN NOMENKLATURA N ON N.N = VNOMN AND N.TD = KK_COMMON.GETTD AND D.CODE <>N.UNIT
       JOIN DIC_DATA DD ON N.UNIT = DD.CODE AND DD.UP = 362 AND DD.TD = KK_COMMON.GETTD
       LEFT JOIN NOM_UNIT NU ON NU.NOMENKLATURA_N = N.N AND NU.UNIT_TYP = D.CODE AND NU.TD = KK_COMMON.GETTD
       WHERE D.TD = KK_COMMON.GETTD
         AND D.UP= 362
       ORDER BY  D.CODE
     )
  LOOP
    PMSG := PMSG || J.CODE ||CHR(9) || J.TERM || V1310;
  END LOOP;

 RETURN VRET ;
END SHOWNOMUNIT2ALL;

FUNCTION  INPUTNOMUNITCNT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 1;
VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VNOMUNIT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP');
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VSYSDATE DATE;
VN NUMBER;
BEGIN
  VSYSDATE := SYSDATE;
  UPDATE NOM_UNIT
    SET TD = VSYSDATE-1/86400
    WHERE NOMENKLATURA_N = VNOMN AND UNIT_TYP = VNOMUNIT AND TD = KK_COMMON.GETTD;

  INSERT INTO NOM_UNIT
    (N, NOMENKLATURA_N, UNIT_TYP, UNIT_CNT, FD, TD)
    VALUES
    (SQ_NOM_UNIT.NEXTVAL, VNOMN, VNOMUNIT, PKEYCODE, VSYSDATE, KK_COMMON.GETTD)
    RETURNING N INTO VN;
  KK_COMMON.ACTION(VEMPN,'NOM_UNIT',VN,3,SYSDATE, 'ИЗМЕНЕНИЕ С ТЕРМИНАЛА');
  RETURN VRET;
END INPUTNOMUNITCNT;


FUNCTION INVNOMVALIDATE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 0;
VNOM    INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VSTDOCINV INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
BEGIN

   VRET := KK_ST_DOC_INV.NOMISINVENTORED(VSTDOCINV    , VNOM );

RETURN VRET;


END INVNOMVALIDATE;



FUNCTION INVENTORYWHATONPALL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VPALLN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');
VRET INTEGER;
VCELLN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS_N');
VCELLADDR VARCHAR2(50) := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ADDR');
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VINVBYPIDBYACTIVESTOCK INTEGER := KK_CONST.GETCONSTN('STDOCINV.INVBYPID.BYACTIVESTOCK',SYSDATE,VCONTRAGENTN);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN


  PMSG := NULL;

  FOR REC IN (   SELECT 1
               FROM ST_DOC_INV_DET
                  WHERE ST_DOC_INV_N = VN
                   AND ST_PALL_N = VPALLN
                   AND TD = KK_COMMON.GETTD )LOOP
    RAISE_APPLICATION_ERROR(-20000, '<ERR>ПАЛЛЕТА '||VPALLN||' УЖЕ ПРОИНВЕНТАРИЗИРОВАНА</ERR>');
              END LOOP;



IF VINVBYPIDBYACTIVESTOCK = 1 THEN

FOR J IN (

SELECT N.CODE,N.NAME
    ,STRAGG(DECODE(P.PART_NUM,NULL,NULL,P.PART_NUM)) AS PART_NUM
    ,SUM(S.CNT) AS CNT
    ,DD_NOM_UNIT.TERM AS NOM_UNIT_TERM
    ,S.EXPIRE_DATE, S.EXPIRE_DATE - NVL(N.EXPIRE,0 ) AS EXPIRE_FROM
    ,S.NOMENKLATURA_N
    ,STRAGG(A.ADDR) AS ADDR
     FROM V_ST_STOCK_ACTIVE S
            JOIN NOMENKLATURA N ON (  N.N = S.NOMENKLATURA_N  AND N.TD = KK_COMMON.GETTD)
            JOIN CELL_ADDRESS A ON (A.N = S.CELL_ADDRESS_N AND A.TD = KK_COMMON.GETTD)
            JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND DD_NOM_UNIT.TD = KK_COMMON.GETTD)
 LEFT OUTER JOIN ST_PART P ON (   S.ST_PART_N = P.N AND P.TD = KK_COMMON.GETTD)
 WHERE S.CONTRAGENT_N = VCONTRAGENTN
   AND S.ST_PALL_N = VPALLN
   GROUP BY N.CODE,N.NAME
          ,DD_NOM_UNIT.TERM
          ,S.EXPIRE_DATE, S.EXPIRE_DATE - NVL(N.EXPIRE,0 )
          ,S.NOMENKLATURA_N

 ) LOOP

   PMSG := SUBSTR( PMSG || J.CODE ||' '|| J.NAME|| V1310 ||
   'ПАРТИЯ: '   || SUBSTR(J.PART_NUM,1,50)   || V1310||
   'СРОК: '     || TO_CHAR(J.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
   'ИГОТОВЛ: '  || TO_CHAR(J.EXPIRE_FROM,'DD.MM.YYYY') || V1310 ||
          J.CNT ||' '||J.NOM_UNIT_TERM|| V1310 ||
            STOCKNBYNOMUNITS(J.NOMENKLATURA_N,J.CNT)||V1310||
   'АДРЕС: '    ||  J.ADDR , 1,2500);


END LOOP; -- FOR J IN (



FOR J IN ( SELECT S.N
     FROM V_ST_STOCK_ACTIVE S
 WHERE S.CONTRAGENT_N = VCONTRAGENTN
   AND S.ST_PALL_N = VPALLN   ) LOOP

    INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1,VAL2,VAL3, FD , TD ,  UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,67/*ЗАПОМНИЛИ НОМЕР В СТОКЕ*/,J.N,VPALLN,VCELLN,SYSDATE,KK_COMMON.GETTD,PPROCN)
   RETURNING N INTO PPROCN;

END LOOP;

ELSE


FOR KK IN (
SELECT CONTRAGENT_N, TYP,PART_IN_N , MAX(FD) AS FD,SUM(CNT) AS CNT
  FROM
ST_STOCK
 WHERE ST_PALL_N =   VPALLN
 AND UP = 0
  GROUP BY CONTRAGENT_N, TYP,PART_IN_N
 ORDER BY FD DESC
) LOOP

  IF KK.CONTRAGENT_N != VCONTRAGENTN  THEN
    RAISE_APPLICATION_ERROR(-20000, '<ERR>ПАЛЛЕТА '||VPALLN||' ПРИНАДЛЕЖИТ ДРУГОМУ КОНТРАГЕНТУ</ERR>');
  END IF;

  DECLARE
    VCURRENTCNT NUMBER;
  BEGIN
    SELECT SUM(S.CNT) INTO VCURRENTCNT
       FROM ST_STOCK S
     WHERE S.TD = KK_COMMON.GETTD
        AND S.CONTRAGENT_N = KK.CONTRAGENT_N
        AND S.PART_IN_N = KK.PART_IN_N
        AND S.ST_PALL_N = VPALLN;

    IF VCURRENTCNT != KK.CNT THEN
     PMSG := 'ПО ПАЛЛЕТЕ Р-'||VPALLN||' БЫЛИ ОПЕРАЦИИ С МОМЕНТА ПРИЕМКИ, ИСПОЛЬЗУЙТЕ ПОЛНУЮ ИНВЕНТАРИЗАЦИЮ! НАЧАЛЬНОЕ КОЛИЧЕСТВО: '||KK.CNT||' ТЕКУЩЕЕ КОЛИЧЕСТВО: '||VCURRENTCNT||V1310;
     RETURN -2;
    END IF;
  END;

  FOR J IN (

SELECT N.CODE,N.NAME
    ,STRAGG(DECODE(P.PART_NUM,NULL,NULL,P.PART_NUM)) AS PART_NUM
    ,SUM(S.CNT) AS CNT
    ,DD_NOM_UNIT.TERM AS NOM_UNIT_TERM
    ,S.EXPIRE_DATE, S.EXPIRE_DATE - NVL(N.EXPIRE,0 ) AS EXPIRE_FROM
    ,S.NOMENKLATURA_N
     FROM ST_STOCK S
 LEFT OUTER JOIN ST_PART P ON (   S.ST_PART_N = P.N AND S.FD BETWEEN P.FD AND P.TD)
 JOIN NOMENKLATURA N ON (  N.N = S.NOMENKLATURA_N  AND S.FD BETWEEN N.FD AND N.TD)
 JOIN DIC_DATA DD_NOM_UNIT ON (DD_NOM_UNIT.UP = 362 AND DD_NOM_UNIT.CODE = N.UNIT AND S.FD BETWEEN DD_NOM_UNIT.FD AND DD_NOM_UNIT.TD)

 WHERE S.UP = 0
 AND S.FD = KK.FD
 AND S.ST_PALL_N = VPALLN
GROUP BY N.CODE,N.NAME
    ,DD_NOM_UNIT.TERM
    ,S.EXPIRE_DATE, S.EXPIRE_DATE - NVL(N.EXPIRE,0 )
    ,S.NOMENKLATURA_N

 ) LOOP

   PMSG := SUBSTR( PMSG || J.CODE ||' '|| J.NAME|| V1310 ||
   'ПАРТИЯ: '   || SUBSTR(J.PART_NUM,1,50)   || V1310||
   'СРОК: '     || TO_CHAR(J.EXPIRE_DATE,'DD.MM.YYYY') || V1310 ||
   'ИГОТОВЛ: '  || TO_CHAR(J.EXPIRE_FROM,'DD.MM.YYYY') || V1310 ||
          J.CNT ||' '||J.NOM_UNIT_TERM|| V1310 ||
            STOCKNBYNOMUNITS(J.NOMENKLATURA_N,J.CNT)||V1310||
   'АДРЕС: '    ||  VCELLADDR , 1,2500);


END LOOP;

/*
FOR J IN
(

SELECT DISTINCT S.N
  FROM ST_STOCK S
 WHERE S.UP = 0
 AND S.FD = KK.FD
 AND S.ST_PALL_N = VPALLN
)LOOP

    INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1,VAL2,VAL3, FD , TD ,  UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,67,J.N,VPALLN,VCELLN,SYSDATE,KK_COMMON.GETTD,PPROCN)
   RETURNING N INTO PPROCN;


END LOOP;
*/
 EXIT;
END LOOP;  -- KK

  FOR J IN (
    SELECT DISTINCT
            (SELECT MAX(N) KEEP (DENSE_RANK LAST ORDER BY LEVEL)
              FROM ST_STOCK  S
              WHERE  N > 0
              CONNECT BY N = PRIOR UP
              START WITH ROWID = T.ROWID
              ) AS N
      FROM ST_STOCK T
      WHERE T.ST_PALL_N = VPALLN
        AND T.CELL_ADDRESS_N = VCELLN
        AND SYSDATE BETWEEN FD AND TD
        AND T.TYP != 9
 )LOOP
    INSERT INTO MCIS_NODES_PROC
      (N , TYP, VAL1,VAL2,VAL3, FD , TD ,  UP )
      VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL, 67 ,J.N
      ,VPALLN, VCELLN, SYSDATE, KK_COMMON.GETTD, PPROCN)
   RETURNING N INTO PPROCN;
  END LOOP;

END IF; --IF VINVBYPIDBYACTUALSTOCK = 1 THEN

IF PMSG IS NULL THEN
 VRET := -1;
 PMSG := 'ПО ДАННОЙ ПАЛЛЕТЕ В СТОКЕ НИЧЕГО НЕ ОБНАРУЖЕНО VPALLN='||VPALLN||' VCONTRAGENTN='||VCONTRAGENTN ||' PPROCN='||PPROCN || ' PROBJN='||PROBJN;
ELSE
 VRET := 1;
END IF ;

 RETURN VRET;

END INVENTORYWHATONPALL;

FUNCTION INVENTORYPURECELL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VST_DOC_INV_N INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VDETN INTEGER;
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VCELL_ADDRESS_N INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS_N');
VJOBN INTEGER;
BEGIN

--   PROBJN := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS_N',VCELL_ADDRESS_N);
--   PROBJN := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'STORE_N',VSTOREN);
--   PROBJN := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS.CELL_TYP_N',VCELLTYPN);

DECLARE
 VCNT INTEGER;
BEGIN

SELECT COUNT(1) INTO VCNT
 FROM ST_DOC_INV_CELL C
  WHERE C.ST_DOC_INV_N = VST_DOC_INV_N
  AND C.TD = KK_COMMON.GETTD
  AND (C.CELL_ADDRESS_N = VCELL_ADDRESS_N OR C.CELL_ADDRESS_N = 0 );

  IF VCNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕ ПОДЛЕЖИТ ИНВЕНТАРИЗАЦИИ!!! <ERR>');
  END IF;
END;

-- // ЗАКРЫВАЕМ ЗАДАНИЕ ЕСЛИ ОНО БЫЛО
DECLARE
VJOBN INTEGER;
BEGIN

SELECT N INTO VJOBN
  FROM ST_BAR_JOBS
 WHERE TYP = 7
 AND SYSDATE BETWEEN FD AND TD
 AND STATUS IN (1,2)
 AND CELL_ADDRESS_N = VCELL_ADDRESS_N
 AND BASE_DOC_N = VST_DOC_INV_N
 AND ROWNUM <=1 ;

   KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,VJOBN,7,VST_DOC_INV_N,0,NULL,0,3,SYSDATE);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
        NULL;
END;

INSERT INTO ST_DOC_INV_DET
(N,ST_DOC_INV_N,NOMENKLATURA_N,CELL_ADDRESS_N,CNT,STATUS,FD,TD,TERMINAL_N,EMP_N,DSC,ST_PART_N,NOM_TYP,EXPIRE_DATE,PALL_TYPE,ST_PALL_N)
VALUES
(SQ_ST_DOC_INV_DET.NEXTVAL,VST_DOC_INV_N,0,VCELL_ADDRESS_N,0,1,SYSDATE,KK_COMMON.GETTD,0,VEMPN,NULL,0,0,NULL,0,0)
RETURNING N INTO VDETN ;




        DECLARE
        VCONTRN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
        VINVDETPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCINV.DETSUBMIT.USERCHECKPROC',SYSDATE,VCONTRN);
       BEGIN
        IF LENGTH(VINVDETPROC) > 1 THEN
           EXECUTE IMMEDIATE 'BEGIN '||VINVDETPROC||'(:PCONTRN,:PNOMN,:PCNT,:PEXPIREDATE,:PPARTN,:PNOMTYP,:PINVDET); END;'
            USING VCONTRN, 0 , 0 ,  SYSDATE
              ,  0,0 , VDETN ;
          END IF;
       END;

  KK_COMMON.ACTION(VEMPN,'ST_DOC_INV_DET',VDETN,1,SYSDATE);


PMSG := 'ПРОИНВЕНТАРИЗИРОВАЛ КАК ПУСТУЮ! #'||VCELL_ADDRESS_N;


RETURN 1;

END INVENTORYPURECELL;

FUNCTION INVENTORYSUBMITPALL(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 1;
VN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VDETN INTEGER;
VCELLN INTEGER;
VPALLN INTEGER;
VCNT INTEGER;
VRECS INTEGER;
VPALLSUM INTEGER;
BEGIN

 BEGIN
  VCNT :=  TO_NUMBER(PKEYCODE);
  EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ВЫ МОЖЕТЕ ВВЕСТИ КОЛИЧЕСТВО НА ПАЛЛЕТЕ ИЛИ ПОДТВЕРДИТЬ 0'||'</ERR>');
 END;

 IF PKEYCODE = '0' THEN
       VCNT  := 0;
       VRECS := -1;
 ELSIF VCNT > 0 THEN

  WITH P AS (
 SELECT DISTINCT P.ROWID AS RD, P.VAL1,P.VAL2,P.VAL3 , LEVEL  AS LVL
  FROM MCIS_NODES_PROC P

    WHERE TYP = 67
   CONNECT BY PRIOR P.UP = P.N AND P.TD = KK_COMMON.GETTD
   START WITH P.N = PPROCN AND P.TD = KK_COMMON.GETTD
   )
, S AS (
  SELECT
     S.NOMENKLATURA_N, S.CNT, S.ST_PART_N,S.NOM_TYP,S.EXPIRE_DATE,S.PALL_TYPE,S.CONTRAGENT_N ,
        P.VAL1,P.VAL2,P.VAL3,P.RD,S.PART_IN_N, S.NOM_TYP_DET_N
  FROM  P
  JOIN ST_STOCK S ON (S.N = P.VAL1)

)
SELECT COUNT(1), SUM(CNT) INTO VRECS,VPALLSUM
  FROM (
        SELECT S.NOMENKLATURA_N,SUM(S.CNT) AS CNT,S.ST_PART_N,S.NOM_TYP,S.EXPIRE_DATE,S.PALL_TYPE,S.CONTRAGENT_N,S.VAL2,S.VAL3,S.PART_IN_N,STRAGG(S.RD) AS RD, S.NOM_TYP_DET_N
         FROM S
       GROUP BY S.NOMENKLATURA_N,S.ST_PART_N,S.NOM_TYP,S.EXPIRE_DATE,S.PALL_TYPE,S.CONTRAGENT_N,S.VAL2,S.VAL3,S.PART_IN_N, S.NOM_TYP_DET_N
   );
    IF VRECS > 1 AND VPALLSUM != VCNT THEN
       RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕЛЬЗЯ ВВЕСТИ ДЛЯ МИКСОВАННОЙ ПАЛЛЕТЫ ФИКСИРОВАННОЕ КОЛИЧЕСТВО НА ПАЛЛЕТЕ-МОЖНО ПРОИНВЕНТАРИЗТРОВАТЬ ЦЕЛИКОМ; НА ПАЛЛЕТЕ:'||VPALLSUM||'У.Е<ERR>');
    END IF; --IF VRECS > 1 THEN

 ELSE
   RAISE_APPLICATION_ERROR(-20000,'<ERR>ВЫ МОЖЕТЕ ВВЕСТИ КОЛИЧЕСТВО НА ПАЛЛЕТЕ ИЛИ ПОДТВЕРДИТЬ 0'||'</ERR>');
 END IF;


FOR J IN (

WITH P AS (
 SELECT DISTINCT P.ROWID AS RD, P.VAL1,P.VAL2,P.VAL3 , LEVEL  AS LVL
  FROM MCIS_NODES_PROC P

    WHERE TYP = 67
   CONNECT BY PRIOR P.UP = P.N AND P.TD = KK_COMMON.GETTD
   START WITH P.N = PPROCN AND P.TD = KK_COMMON.GETTD
   )
, S AS (
  SELECT
     S.NOMENKLATURA_N, S.CNT, S.ST_PART_N,S.NOM_TYP,S.EXPIRE_DATE,S.MAKE_DATE,S.PALL_TYPE,S.CONTRAGENT_N ,
        P.VAL1,P.VAL2,P.VAL3,P.RD,S.PART_IN_N, S.NOM_TYP_DET_N, S.QUANTUM
  FROM  P
  JOIN ST_STOCK S ON (S.N = P.VAL1)
   ORDER BY P.LVL
)
SELECT S.NOMENKLATURA_N,DECODE(VRECS,-1,SUM(S.CNT),1,VCNT,SUM(S.CNT))  AS CNT,S.ST_PART_N,S.NOM_TYP,S.EXPIRE_DATE,S.MAKE_DATE,S.PALL_TYPE,S.CONTRAGENT_N,S.VAL2,S.VAL3,S.PART_IN_N,STRAGG(S.RD) AS RD, S.NOM_TYP_DET_N, S.QUANTUM
FROM S
GROUP BY S.NOMENKLATURA_N,S.ST_PART_N,S.NOM_TYP,S.EXPIRE_DATE,S.PALL_TYPE,S.CONTRAGENT_N,S.VAL2,S.VAL3,S.PART_IN_N, S.NOM_TYP_DET_N, S.QUANTUM

) LOOP


    BEGIN
INSERT INTO ST_DOC_INV_DET
(N,ST_DOC_INV_N,NOMENKLATURA_N,CELL_ADDRESS_N,CNT,STATUS,FD,TD,TERMINAL_N,EMP_N,ST_PART_N,NOM_TYP,EXPIRE_DATE,MAKE_DATE,PALL_TYPE,ST_PALL_N,PART_IN_N, WEIGHT)
VALUES
(SQ_ST_DOC_INV_DET.NEXTVAL,VN,J.NOMENKLATURA_N,J.VAL3,J.CNT,1,SYSDATE,KK_COMMON.GETTD,0,0,J.ST_PART_N,J.NOM_TYP,J.EXPIRE_DATE,J.MAKE_DATE,J.PALL_TYPE,J.VAL2,J.PART_IN_N, J.QUANTUM*J.CNT)
RETURNING ST_PALL_N,N INTO VPALLN,VDETN;
KK_COMMON.ACTION(VEMPN,'ST_DOC_INV_DET',VDETN,1,SYSDATE);

KK_ST_NOM_TYP.COPYVALUES(PSTDOCTYP =>  14, PSTDOCN => VDETN, PNFROM => J.NOM_TYP_DET_N );



        DECLARE
        VCONTRN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
        VINVDETPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCINV.DETSUBMIT.USERCHECKPROC',SYSDATE,VCONTRN);
       BEGIN
        IF LENGTH(VINVDETPROC) > 1 THEN
           EXECUTE IMMEDIATE 'BEGIN '||VINVDETPROC||'(:PCONTRN,:PNOMN,:PCNT,:PEXPIREDATE,:PPARTN,:PNOMTYP,:PINVDET); END;'
            USING VCONTRN,J.NOMENKLATURA_N , J.CNT ,  J.EXPIRE_DATE
              ,  J.ST_PART_N ,J.NOM_TYP , VDETN ;
          END IF;
       END;


 VCELLN := J.VAL3;


    EXCEPTION
     WHEN UNIQUE_CONSTRAINT_EXCEPT THEN -- CAUTION HANDLES ALL EXCEPTIONS
        RAISE_APPLICATION_ERROR(-20000,'<ERR>ДАННЫЙ ПАЛЛЕТ УЖЕ ИНВЕНТАРИЗИРОВАН!</ERR>') ;
    END;



-- UPDATE MCIS_NODES_PROC SET TD = SYSDATE
--  WHERE ROWID = J.RD ;

END LOOP;

 UPDATE MCIS_NODES_PROC SET TD = SYSDATE
 WHERE N IN
 (
  WITH P AS (
 SELECT DISTINCT P.N, P.VAL1,P.VAL2,P.VAL3 , LEVEL  AS LVL
  FROM MCIS_NODES_PROC P
    WHERE TYP = 67
   CONNECT BY PRIOR P.UP = P.N AND P.TD = KK_COMMON.GETTD
   START WITH P.N = PPROCN AND P.TD = KK_COMMON.GETTD
   )
SELECT
 P.N
  FROM  P JOIN ST_STOCK S ON (S.N = P.VAL1)
 );



-- // ЗАКРЫВАЕМ ЗАДАНИЕ ЕСЛИ ОНО БЫЛО
DECLARE
VJOBN INTEGER;
BEGIN

SELECT N INTO VJOBN
  FROM ST_BAR_JOBS
 WHERE TYP = 7
 AND SYSDATE BETWEEN FD AND TD
 AND STATUS IN (1,2)
 AND CELL_ADDRESS_N = VCELLN
 AND BASE_DOC_N = VN
 AND ROWNUM <=1 ;

   KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN,VJOBN,7,VN,0,NULL,0,3,SYSDATE);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
        NULL;
END;

PMSG := 'ПАЛЛЕТА:'||VPALLN||' ИНВЕНТАРИЗИРОВАНА!';

RETURN VRET;
END INVENTORYSUBMITPALL;


FUNCTION INVENTORYFULLSCHEM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN

 INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,68,0,0,0,NULL,SYSDATE,KK_COMMON.GETTD,NULL,PPROCN)
   RETURNING N INTO PPROCN;


RETURN 1;
END INVENTORYFULLSCHEM;

FUNCTION STDOCINSHOWDIFF(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VPROC LIST_CONST.VAL%TYPE ;
VRET INTEGER:=0;
BEGIN

   VPROC := KK_CONST.GETCONSTV('STDOCINSHOWDIFF.PROCNAME',SYSDATE,KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N'));

 IF NVL(VPROC,'_') = '_' THEN
     VRET:=KK_ST_BARCODE.STDOCINSHOWDIFF_DEFAULT(PKEYCODE, PSTR, PMSG,PNEXTNODE,PPROCN,PROBJN);
 ELSE

    EXECUTE IMMEDIATE 'BEGIN :PRET:='||VPROC||'(:PKEYCODE,:PSTR,:PMSG,:PNEXTNODE,:PPROCN,:PROBJN); END;'
         USING OUT VRET, IN PKEYCODE,IN PSTR,IN OUT PMSG,IN OUT PNEXTNODE,IN OUT PPROCN,IN OUT PROBJN;

 END IF;
RETURN VRET;
END STDOCINSHOWDIFF;


FUNCTION STDOCINSHOWDIFF_DEFAULT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VDOC INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

FOR J IN (

 SELECT NVL(A.NAME,B.NAME)
 ||CASE WHEN NVL(A.CNT_IN  ,0)>0 OR NVL(B.CNT_IN  ,0)>0 THEN ' К:'||NVL(A.CNT_IN  ,0)||'/'||NVL(B.CNT_IN  ,0) ELSE NULL END
 ||CASE WHEN NVL(A.CNT_BRAK,0)>0 OR NVL(A.CNT_BRAK,0)>0 THEN ' Б:'||NVL(A.CNT_BRAK,0)||'/'||NVL(B.CNT_BRAK,0) ELSE NULL END
 || ' '||B.P
 AS MSG
   FROM
(SELECT/*+ INDEX_DESC(D ST_DOC_IN_DET_DOC_N_FD_TD)*/
    N.CODE ||' "'||SUBSTR(N.NAME,1,10)||'"' AS NAME ,D.NOMENKLATURA_N, SUM(CNT_IN/U.UNIT_CNT) AS CNT_IN,SUM(CNT_BRAK/U.UNIT_CNT) AS CNT_BRAK
--    , SYS_XMLAGG(XMLELEMENT(COL, 'P-'||D.PALL_N||':('||TO_CHAR(D.EXPIRE_DATE,'DD.MM.YY')||')('||D.CNT_IN/U.UNIT_CNT||'); ')).EXTRACT('/ROWSET/COL/TEXT()').GETSTRINGVAL() AS P
    FROM ST_DOC_IN_DET D
     JOIN NOMENKLATURA N ON (D.NOMENKLATURA_N = N.N  AND SYSDATE BETWEEN N.FD AND N.TD )
     JOIN NOM_UNIT U ON (D.NOMENKLATURA_N = U.NOMENKLATURA_N AND U.UNIT_TYP = N.UNIT_OP  AND SYSDATE BETWEEN U.FD AND U.TD )
   WHERE D.SQ_ST_DOC_IN_N = VDOC
   AND D.TYP =0
   AND SYSDATE BETWEEN D.FD AND D.TD
   GROUP BY N.CODE ||' "'||SUBSTR(N.NAME,1,10)||'"' ,D.NOMENKLATURA_N ) A
    FULL OUTER JOIN
(SELECT/*+ INDEX_DESC(D ST_DOC_IN_DET_DOC_N_FD_TD)*/
    N.CODE ||' "'||SUBSTR(N.NAME,1,10)||'"' AS NAME ,D.NOMENKLATURA_N, SUM(CNT_IN/U.UNIT_CNT) AS CNT_IN,SUM(CNT_BRAK/U.UNIT_CNT) AS CNT_BRAK
    , SYS_XMLAGG(XMLELEMENT(COL, 'P-'||D.PALL_N||':('||TO_CHAR(D.EXPIRE_DATE,'DD.MM.YY')||')('||D.CNT_IN/U.UNIT_CNT||')('||NVL2(P.PART_NUM, 'П:','')||P.PART_NUM||NVL2(P.PART_NUM, '-','')||TO_CHAR(P.PART_FD,'DD.MM.YY')||'); ')).EXTRACT('/ROWSET/COL/TEXT()').GETSTRINGVAL() AS P
    FROM ST_DOC_IN_DET D
     JOIN NOMENKLATURA N ON (D.NOMENKLATURA_N = N.N  AND SYSDATE BETWEEN N.FD AND N.TD )
     JOIN NOM_UNIT U ON (D.NOMENKLATURA_N = U.NOMENKLATURA_N AND U.UNIT_TYP = N.UNIT_OP  AND SYSDATE BETWEEN U.FD AND U.TD )
     LEFT OUTER JOIN ST_PART P ON (D.ST_PART_N = P.N AND SYSDATE BETWEEN P.FD AND P.TD)
   WHERE D.SQ_ST_DOC_IN_N = VDOC
   AND D.TYP =1
   AND SYSDATE BETWEEN D.FD AND D.TD
   GROUP BY N.CODE ||' "'||SUBSTR(N.NAME,1,10)||'"' ,D.NOMENKLATURA_N  ) B ON (A.NOMENKLATURA_N = B.NOMENKLATURA_N)

WHERE 1=1
/* AND (
 NVL(A.CNT_IN  ,0 ) != NVL(B.CNT_IN,0 ) OR
 NVL(A.CNT_BRAK,0 ) != NVL(B.CNT_BRAK,0 )
     )*/
ORDER BY 1
) LOOP

 PMSG := SUBSTR(PMSG|| V1310||J.MSG,1,2500);

 EXIT WHEN LENGTH(PMSG) = 2500;

END LOOP;




 IF PMSG IS NULL THEN
  PMSG := 'СООТВЕТВУЕТ ДОКУМЕНТУ!';
 ELSE
  PMSG := 'КОД НАИМЕН ДОК./ФАКТ' ||PMSG || V1310;
 END IF; --IF PMSG IS NULL THEN

FOR J IN (SELECT/*+ INDEX_DESC(D ST_DOC_IN_DET_DOC_N_FD_TD)*/
    D.PALL_N ||' "'|| N.CODE||'" ' ||TO_CHAR(D.EXPIRE_DATE,'DD.MM.YYYY') AS MSG
    FROM ST_DOC_IN_DET D
     JOIN NOMENKLATURA N ON (D.NOMENKLATURA_N = N.N AND SYSDATE BETWEEN N.FD AND N.TD)
   WHERE D.SQ_ST_DOC_IN_N = VDOC
   AND D.TYP =1
   AND SYSDATE BETWEEN D.FD AND D.TD
   GROUP BY D.PALL_N ,    N.CODE,D.EXPIRE_DATE
   ORDER BY D.PALL_N) LOOP

 PMSG := SUBSTR(PMSG|| V1310 ||J.MSG,1,2500);

 EXIT WHEN LENGTH(PMSG) = 2500;

END LOOP;

-- RAISE_APPLICATION_ERROR(-20000,'PMSG');
 RETURN 1;
END STDOCINSHOWDIFF_DEFAULT;

FUNCTION STDOCINNEEDPALLWEIGHT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCONTRAGENTN   INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'  );
VNOMENKLATURAN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');

VCONST LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEWEIGHT.NOMUNIT',SYSDATE,VCONTRAGENTN);
VCONST2 LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NOMWEIGHT.NOMGRP.NOREQUESTWEIGHT',SYSDATE,VCONTRAGENTN,1);
VCONST3 LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NOMWEIGHT.TYPWEIGHT',SYSDATE,VCONTRAGENTN);

VRET INTEGER;
VNOREQUEST INTEGER;

VWEIGHT_NETTO NUMBER;
VWEIGHT_BRUTTO NUMBER;
VN INTEGER;

BEGIN


 BEGIN
  SELECT NVL(TO_NUMBER(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.WEIGHT_NETTO'),'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0)
     INTO VWEIGHT_NETTO
       FROM DUAL;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VWEIGHT_NETTO := 0;
 END;

 BEGIN
  SELECT NVL(TO_NUMBER(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.WEIGHT_BRUTTO'),'999999D9999','NLS_NUMERIC_CHARACTERS ='', '''),0)
     INTO VWEIGHT_BRUTTO
       FROM DUAL;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   VWEIGHT_BRUTTO := 0;
 END;


SELECT
CASE
     WHEN (VWEIGHT_NETTO >0 OR VWEIGHT_BRUTTO > 0) AND MIN(DECODE(INSTR(VCONST2,','||N.GROUP_N||','),0,0,NULL,0,1)) =0 THEN 3  -- EAN UCC
     WHEN DECODE(COUNT(1),0,-1,1) = -1 THEN -1 -- НЕ ВЕСОВОЙ
     WHEN DECODE(COUNT(1),0,-1,1) = 1 AND MIN(DECODE(INSTR(VCONST2,','||N.GROUP_N||','),0,0,NULL,0,1)) =0  THEN 1 -- ВЕСОВОЙ , БЕЗ ТРАФАРЕТА
     WHEN DECODE(COUNT(1),0,-1,1) = 1 AND MIN(DECODE(INSTR(VCONST2,','||N.GROUP_N||','),0,0,NULL,0,1)) =1  THEN 2 END -- ВЕСОВОЙ С ТРАФАРЕТОМ
,CASE
  WHEN VWEIGHT_NETTO >0 OR VWEIGHT_BRUTTO > 0 AND MIN(DECODE(VCONST2
                                                            ,'0', 1,
                                                            DECODE(NVL(INSTR(VCONST2,','||N.GROUP_N||','), 0)
                                                            ,0,0
                                                            ,1))) =0 THEN 0  -- EAN UCC
  WHEN   DECODE(COUNT(1),0,-1,1) = 1 AND MIN(DECODE(VCONST2
                                                    ,'0', 1,
                                                    DECODE(NVL(INSTR(VCONST2,','||N.GROUP_N||','), 0)
                                                    ,0,0
                                                    ,1))) =1 THEN 1 ELSE 0 END
 INTO VRET, VNOREQUEST
   FROM NOMENKLATURA N
     JOIN  NOM_UNIT NU ON (NU.NOMENKLATURA_N = VNOMENKLATURAN
                       AND SYSDATE BETWEEN NU.FD AND NU.TD
                       AND VCONST LIKE '%,'||NU.UNIT_TYP||',%')
  WHERE N.N = VNOMENKLATURAN
  AND SYSDATE BETWEEN N.FD AND N.TD  ;



--IF VRET = 1 THEN
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOREQUESTWEIGHT',VNOREQUEST);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.CUR_BOX','');
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'JOB.CUR_BOX_WEIGHT','');
--END IF;

--RAISE_APPLICATION_ERROR(-20000,PROBJN||'_'||VRET||'_'||VWEIGHT_NETTO||'_'||VWEIGHT_BRUTTO);

   IF NVL(VCONST3,0) != 0 AND VRET = 1 THEN
     SELECT CASE
           WHEN VCONST3=1 THEN 0
           WHEN VCONST3=2 THEN 1
       END
     INTO VN FROM DUAL;

   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,231/*0-БРУТТО; 1-НЕТТО*/,VN,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'0-БРУТТО; 1-НЕТТО',PPROCN)
   RETURNING N INTO PPROCN;

   VRET := 4;
   END IF;

   IF VRET = 2 THEN -- ТРАФАРЕТНЫЙ
   INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,231,1/*1-НЕТТО*/,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'0-БРУТТО; 1-НЕТТО',PPROCN)
   RETURNING N INTO PPROCN;

   END IF;

--RAISE_APPLICATION_ERROR(-20000,VRET);


RETURN VRET;

END STDOCINNEEDPALLWEIGHT;


FUNCTION STDOCOUTNEEDPALLWEIGHT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
        VCONTRAGENTN   INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'  );
        VNOMENKLATURAN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
        VCONST LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEWEIGHT.NOMUNIT',SYSDATE,VCONTRAGENTN);
        VCONST2 LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.NOMWEIGHT.NOMGRP.NOREQUESTWEIGHT',SYSDATE,VCONTRAGENTN,2);
        VRET INTEGER;
        VNOREQUEST INTEGER;

        VWEIGHT_NETTO NUMBER;
        VWEIGHT_BRUTTO NUMBER;
        VINPUTBOXWEIGHTTYPE NUMBER  := KK_CONST.GETCONSTV('INPUTBOXWEIGHT.TYPE',SYSDATE);
BEGIN

  SELECT
        CASE
             WHEN DECODE(COUNT(1),0,-1,1) = -1 THEN -1 -- НЕ ВЕСОВОЙ
             WHEN DECODE(COUNT(1),0,-1,1) = 1 AND MIN(DECODE(INSTR(VCONST2,','||N.GROUP_N||','),0,0,NULL,0,1)) =0  THEN 1 -- ВЕСОВОЙ , БЕЗ ТРАФАРЕТА
             WHEN DECODE(COUNT(1),0,-1,1) = 1 AND MIN(DECODE(INSTR(VCONST2,','||N.GROUP_N||','),0,0,NULL,0,1)) =1  THEN 2 END -- ВЕСОВОЙ С ТРАФАРЕТОМ
       ,CASE WHEN DECODE(COUNT(1),0,-1,1) = 1 AND MIN(DECODE(VCONST2
                                                              ,'0', 1,
                                                              DECODE(NVL(INSTR(VCONST2,','||N.GROUP_N||','), 0)
                                                              ,0,0
                                                              ,1))) =1 THEN 1 ELSE 0 END

  INTO VRET, VNOREQUEST
  FROM NOMENKLATURA N
  JOIN  NOM_UNIT NU ON (NU.NOMENKLATURA_N = VNOMENKLATURAN
                       AND SYSDATE BETWEEN NU.FD AND NU.TD
                       AND VCONST LIKE '%,'||NU.UNIT_TYP||',%')
  WHERE N.N = VNOMENKLATURAN
    AND SYSDATE BETWEEN N.FD AND N.TD  ;

--IF VRET = 1 THEN
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'NOREQUESTWEIGHT',VNOREQUEST);
   KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN, 'JOB.CUR_BOX');
   KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN, 'JOB.CUR_BOX_WEIGHT');
--END IF;
-- ЕСЛИ ТОВАР ВЕСОВОЙ БЕЗ ТРАФАРЕТА
  IF VRET = 1 THEN
    IF VINPUTBOXWEIGHTTYPE = 1 THEN
      -- И ТИП ВВОДА ВЕСА "ЧЕРЕЗ ВЕС ОСТАТКА ПАЛЛЕТЫ"
      VRET := 3;
    END IF;
  END IF;
--  RAISE_APPLICATION_ERROR(-20000,'RET='||VRET);
  RETURN VRET;
END STDOCOUTNEEDPALLWEIGHT;

FUNCTION CHECKNEEDINPUTPARTFORGRP(PCONTRAGENTN INTEGER,PDOCN INTEGER,PNOMN INTEGER ) RETURN INTEGER IS
--   1-НУЖНО; -1 НЕ НУЖНО
VRET INTEGER;
VNEEDPART LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEPART.FORNOMGROUP.INBOUND',SYSDATE,PCONTRAGENTN);
VNEEDPARTEXCLUDE LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEPART.FORNOMGROUP.INBOUND.EXCLUDE',SYSDATE,PCONTRAGENTN);

VGRP INTEGER;
BEGIN

IF VNEEDPART != '_'  THEN

SELECT N.GROUP_N INTO VGRP
 FROM  NOMENKLATURA N
  WHERE N.N = PNOMN
 AND SYSDATE BETWEEN N.FD AND N.TD ;


 /*RAISE_APPLICATION_ERROR(-20000,'!!---'||VNEEDPART||'---'||VCONTRAGENTN||'---'||VGRP);*/
  IF (VNEEDPART = '0' OR INSTR(VNEEDPART,','||VGRP||',') > 0) AND INSTR(VNEEDPARTEXCLUDE,','||VGRP||',')=0 THEN
     VRET := 1;
  ELSE
     VRET := -1;
  END IF;

ELSE
VRET :=-1;

END IF; --IF VNEEDPART != '_'  THEN


  RETURN VRET;
END CHECKNEEDINPUTPARTFORGRP;


FUNCTION  CHECKNEEDINPUTPARTINV(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER;
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VCNT INTEGER;
VJOBN INTEGER :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB.N' );
VDOCN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.N');
VNEEDPARTPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEPART.FORNOM.INV.USERPROC',SYSDATE,VCONTRAGENTN);
VNOMN INTEGER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VCYCLEPART INTEGER ;
BEGIN


PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',0);

IF VNEEDPARTPROC = '_' THEN
  VRET :=  KK_ST_BARCODE.CHECKNEEDINPUTPARTFORGRP(PCONTRAGENTN =>VCONTRAGENTN,PDOCN => VDOCN,PNOMN =>VNOMN ) ;
ELSE
  EXECUTE IMMEDIATE 'BEGIN :RET := '|| VNEEDPARTPROC ||'(:PCONTRAGENTN , :PDOCN ,:PNOMN); END;'
  USING OUT VRET, IN VCONTRAGENTN, IN VDOCN, IN VNOMN ;
END IF;


IF VRET = -1 THEN

INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,19/*ЗАПОМНИЛИ ПАРТИЯ*/,0,0,0,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР ПАРТИИ',PPROCN)
   RETURNING N INTO PPROCN;
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_INV.CURRENT.UNIT',-1);

ELSE
 VCYCLEPART  := KK_CONST.GETCONSTN('CONTRAGENT.PARTNUMSCANCYCLE.INV',SYSDATE,VCONTRAGENTN);
 IF VCYCLEPART = 1 THEN
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_INV.CURRENT.UNIT',0);
    VCNT :=  KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_INV.CNT');
    PMSG := ' ТРЕБУЕТСЯ ЦИКЛИЧЕСКИЙ ВОД ПАРТИЙ ДЛЯ '|| VCNT ||' ЕДИНИЦ!';

 ELSE
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'ST_DOC_INV.CURRENT.UNIT',-1);
 END IF;
END IF; -- IF VRET = -1 THEN



RETURN VRET;
END CHECKNEEDINPUTPARTINV;

FUNCTION  CHECKNEEDINPUTPART(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER;
VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
VDOCN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
VNEEDPARTPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('CONTRAGENT.USEPART.FORNOM.INBOUND.USERPROC',SYSDATE,VCONTRAGENTN);
VNOMN INTEGER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VBARBATCH ST_PART.PART_NUM%TYPE := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.BATCH' );
VPART ST_PART.N%TYPE;
BEGIN

PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',0);

IF VNEEDPARTPROC = '_' THEN
  VRET :=  KK_ST_BARCODE.CHECKNEEDINPUTPARTFORGRP(PCONTRAGENTN =>VCONTRAGENTN,PDOCN => VDOCN,PNOMN =>VNOMN ) ;
ELSE
 BEGIN
  EXECUTE IMMEDIATE 'BEGIN :RET := '|| VNEEDPARTPROC ||'(:PCONTRAGENTN , :PDOCN ,:PNOMN, :PROBJN); END;'  USING OUT VRET, IN VCONTRAGENTN, IN VDOCN, IN VNOMN , IN OUT PROBJN;
 EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
   IF INSTR(SQLERRM,'PLS-00306') > 0 THEN
      EXECUTE IMMEDIATE 'BEGIN :RET := '|| VNEEDPARTPROC ||'(:PCONTRAGENTN , :PDOCN ,:PNOMN ); END;'  USING OUT VRET, IN VCONTRAGENTN, IN VDOCN, IN VNOMN ;
   ELSE
    RAISE_APPLICATION_ERROR(-20000,SQLERRM);
   END IF;
 END;
END IF;


  IF VRET = -1 THEN
    INSERT INTO MCIS_NODES_PROC
      (N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )
      VALUES
      (SQ_MCIS_NODES_PROC.NEXTVAL,19/*ЗАПОМНИЛИ ПАРТИЯ*/,0,0,0,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ НОМЕР ПАРТИИ',PPROCN)
    RETURNING N
    INTO PPROCN;
  ELSE
    VBARBATCH := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.BATCH' );
    IF VBARBATCH IS NOT NULL THEN
      BEGIN
        SELECT N
          INTO VPART
          FROM ST_PART
          WHERE LOWER(TRIM(VBARBATCH)) = LOWER(TRIM(PART_NUM))
            AND TD = KK_COMMON.GETTD
            AND CONTRAGENT_N = VCONTRAGENTN
            AND ROWNUM<2;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          INSERT INTO ST_PART
            (N,CONTRAGENT_N,PART_NUM,FD,TD,DSC)
            VALUES
            (SQ_ST_PART.NEXTVAL,NVL(VCONTRAGENTN,0),VBARBATCH,KK_COMMON.GETFD,KK_COMMON.GETTD,'I?EOIAIAAIEA II OAEOO')
            RETURNING N
            INTO VPART;
      END;
      INSERT INTO MCIS_NODES_PROC
        (N , TYP, VAL1, VAL2 , VAL3,VAL4 , FD , TD , DSC, UP )
        VALUES
        (SQ_MCIS_NODES_PROC.NEXTVAL,19/*CAIIIIEEE IA?OE?*/,VPART,/*TRIM(UPPER(PKEYCODE))*/VBARBATCH,PSTR,VBARBATCH,SYSDATE,KK_COMMON.GETTD,'CAIIIIEEE IIIA? IA?OEE',PPROCN)
        RETURNING N
        INTO PPROCN;
      PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.N',VPART);
      PROBJN :=  KK_ST_BARCODE.SESSIONVARSET(PROBJN,'PART.PART_NUM',VBARBATCH);
      VRET := -1;
    END IF;
  END IF;
RETURN VRET;
END CHECKNEEDINPUTPART;

FUNCTION CHECKNEEDINPUTNOM(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VJOBN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOB.N');
  VRET INTEGER;
BEGIN
  SELECT J.ST_STOCK_N INTO VRET
  FROM ST_BAR_JOBS J
  WHERE J.N = VJOBN
  AND J.TD =KK_COMMON.GETTD;


  IF VRET = -2 THEN -- ЗАТЫЧКА ДЛЯ MOVE_REWORK
    RETURN -1;
  END IF;
--  RAISE_APPLICATION_ERROR(-20000, '<ERR></ERR>'||VJOBN);
  SESSIONVARCLOSE(PROBJN, 'CNT');
  SESSIONVARCLOSE(PROBJN, 'NOMENKLATURA_N');
  IF KK_CONST.GETCONSTN('REPLENISHMENT.NEEDINPUTNOM', SYSDATE, VCONTRAGENTN) = 1 THEN
    RETURN 1;
  ELSE
    RETURN -1;
  END IF;
END CHECKNEEDINPUTNOM;

FUNCTION CHECKNEEDINPUTPID(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
BEGIN
  SESSIONVARCLOSE(PROBJN, 'PID');
  IF KK_CONST.GETCONSTN('REPLENISHMENT.NEEDINPUTPID', SYSDATE, VCONTRAGENTN) = 1 THEN
    RETURN 1;
  ELSE
    IF KK_CONST.GETCONSTN('REPLENISHMENT.NEEDINPUTNOM', SYSDATE, VCONTRAGENTN) = 1 THEN
      RETURN -1;
    ELSE
      RAISE_APPLICATION_ERROR(-20000, '<ERR>НЕ ПРАВИЛЬНО НАСТРОЕНЫ КОНСТАНТЫ REPLENISHMENT.NEEDINPUTPID REPLENISHMENT.NEEDINPUTNOM</ERR>');
    END IF;
  END IF;
END CHECKNEEDINPUTPID;

FUNCTION  CHECKNEEDINPUTMOVECNT(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VUNIT INTEGER := KK_CONST.GETCONSTN('MOVEMENT.INPUTCNTUNIT', SYSDATE, VCONTRAGENTN);
BEGIN
  IF VUNIT != 0 THEN
    RETURN 1;
  ELSE
    RETURN -1;
  END IF;
END;

FUNCTION CHECKNEEDINPUTTEAMEMPS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VJOBN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ST_BAR_JOBS.N');
  VJOBTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ST_BAR_JOBS.TYP');
  VJOBNLIST ST_BARCODE_VARIABLES.VAR_VALUE%TYPE := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOBNLIST');
  VTEAMCNT INTEGER;
  VRET INTEGER := -VJOBTYP;
  VTEAMEMPS VARCHAR2(255);
  VJOBBLOCK INTEGER;
  VCNT INTEGER := 0;
BEGIN
--  RAISE_APPLICATION_ERROR(-20000, VJOBN||'/'||VJOBTYP);
  IF VJOBNLIST IS NULL   THEN
    SELECT TEAM_EMPS, JOB_BLOCK, KK_CONST.GETCONSTN('TEAMEMPSCNT', SYSDATE, NVL(O.TYP, M.TYP), N.PICK_JOB_GRP)
      INTO VTEAMEMPS, VJOBBLOCK, VTEAMCNT
      FROM ST_BAR_JOBS J
      LEFT JOIN ST_DOC_OUT O   ON (O.N = J.BASE_DOC_N AND O.TD = KK_COMMON.GETTD)
      LEFT JOIN ST_DOC_MOVE M  ON (M.N = J.BASE_DOC_N AND M.TD = KK_COMMON.GETTD)
      LEFT JOIN NOMENKLATURA N ON (N.N = J.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
      WHERE J.N = VJOBN
        AND J.TD = KK_COMMON.GETTD;
  ELSE
    VRET := -11;
    SELECT MAX(TEAM_EMPS), NULL, MAX(KK_CONST.GETCONSTN('TEAMEMPSCNT', SYSDATE, I.TYP, N.PICK_JOB_GRP))
           ,SUM(NVL2(TEAM_EMPS,1,0))
      INTO VTEAMEMPS, VJOBBLOCK, VTEAMCNT
           ,VCNT
      FROM ST_BAR_JOBS J
      LEFT JOIN ST_DOC_IN I    ON (I.N = J.BASE_DOC_N AND I.TD = KK_COMMON.GETTD)
      LEFT JOIN NOMENKLATURA N ON (N.N = J.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
      WHERE ','||VJOBNLIST||',' LIKE '%,'||J.N||',%'
        AND J.TYP = 11
        AND J.TD = KK_COMMON.GETTD;
  END IF;
  IF VTEAMCNT > 0 THEN
    IF VTEAMEMPS IS NULL THEN
      IF VJOBTYP = 12 THEN
        SELECT COUNT(*)
          INTO VCNT
          FROM ST_BAR_JOBS
          WHERE JOB_BLOCK = VJOBBLOCK
            AND TYP = 12
            AND STATUS = 3;
      END IF;
      IF VCNT = 0 THEN
        VRET := 1;
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'PMSG', PMSG);
        PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'TEAM.EMPS.MAXCNT', VTEAMCNT);
      END IF;
    END IF;
  END IF;
  RETURN VRET;
END CHECKNEEDINPUTTEAMEMPS;

FUNCTION SHOWTEAMEMPS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VEMPN     INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
  VTEAMEMPS VARCHAR2(255) := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'TEAM.EMPS');
BEGIN
  SELECT STRAGG_SEP(T_STR_SEP( NAME||DECODE(N, VEMPN, CHR(13)||CHR(10)||'---------------'), CHR(13)||CHR(10)))
    INTO PMSG
  FROM (
      SELECT P.NAME ||': '||U.NAME AS NAME, U.N
        FROM TABLE(KK_SMS.CREATETABLE(VEMPN||','||VTEAMEMPS)) T
        LEFT JOIN PRM_USERS U   ON (U.N = T.RECIPIENT AND U.TD = KK_COMMON.GETTD)
        LEFT JOIN V_EMPLOYEE E  ON (U.PERSON_N = E.N  AND E.TD = KK_COMMON.GETTD)
        LEFT JOIN V_POSITIONS P ON (P.N = E.POSITION  AND P.TD = KK_COMMON.GETTD)
        ORDER BY DECODE(U.N, VEMPN,1,2), U.NAME
      );
  RETURN 1;
END SHOWTEAMEMPS;

FUNCTION INPUTTEAMEMP(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VEMPN     INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
  VTEAMCNT  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'TEAM.EMPS.MAXCNT');
  VTEAMEMPS VARCHAR2(255) := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'TEAM.EMPS');
  VN INTEGER;
  I INTEGER;
BEGIN
  BEGIN
  SELECT N
    INTO VN
    FROM PRM_USERS
    WHERE N = TO_NUMBER(NVL(PSTR, TRIM(PKEYCODE)))
      AND TD = KK_COMMON.GETTD;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20000, '<ERR>ОШИБКА ОПРЕДЕЛЕНИЯ СОТРУДНИКА</ERR>');
  END;
  IF VN = VEMPN THEN
    RAISE_APPLICATION_ERROR(-20000, '<ERR>СЕБЯ СКАНИРОВАТЬ НЕ НУЖНО. СКАНИРУЙТЕ ТОЛЬКО ПОМОШНИКОВ.</ERR>');
  END IF;
  I := INSTR(','||VTEAMEMPS||',', ','||VN||',');
  IF I = 0 THEN
    VTEAMEMPS := VTEAMEMPS||VN||',';
  ELSE
    VTEAMEMPS := SUBSTR(VTEAMEMPS, 1, I-1)||SUBSTR(VTEAMEMPS, I+LENGTH(VN||','), 255);
  END IF;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'TEAM.EMPS', VTEAMEMPS);
  IF  LENGTH(VTEAMEMPS)- LENGTH(REPLACE(VTEAMEMPS, ',','')) < VTEAMCNT THEN
    RETURN 1;
  ELSE
    RETURN SUBMITTEAMEMPS(PKEYCODE, PSTR, PMSG, PNEXTNODE, PPROCN, PROBJN);
  END IF;
END INPUTTEAMEMP;

FUNCTION CLEARTEAMEMPS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN
  KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN, 'TEAM.EMPS');
  RETURN 1;
END CLEARTEAMEMPS;

FUNCTION SUBMITTEAMEMPS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VJOBN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ST_BAR_JOBS.N');
  VJOBTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ST_BAR_JOBS.TYP');
  VTEAMEMPS VARCHAR2(255) := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'TEAM.EMPS');
  VJOBNLIST ST_BARCODE_VARIABLES.VAR_VALUE%TYPE := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'JOBNLIST');
  VMSG VARCHAR2(32767) := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'PMSG');
BEGIN
  IF VJOBTYP = 12 THEN
    UPDATE ST_BAR_JOBS
      SET TEAM_EMPS = VTEAMEMPS
      WHERE JOB_BLOCK = (
          SELECT JOB_BLOCK
            FROM ST_BAR_JOBS
            WHERE N = VJOBN
              AND TD = KK_COMMON.GETTD)
        AND TYP = 12
        AND STATUS IN (1,2);
  ELSIF VJOBNLIST IS NOT NULL THEN
    VJOBTYP := 11;
    UPDATE ST_BAR_JOBS J
      SET TEAM_EMPS = VTEAMEMPS
      WHERE ','||VJOBNLIST||',' LIKE '%,'||J.N||',%'
        AND J.TYP = 11
        AND J.TD = KK_COMMON.GETTD;
  ELSE
    FOR J IN (
      SELECT ROWID AS RD
        FROM ST_BAR_JOBS
        CONNECT BY PRIOR ST_STOCK_N = UP
        START WITH N = VJOBN
          AND TD = KK_COMMON.GETTD
          AND UP=0
      UNION ALL
      SELECT ROWID AS RD
        FROM ST_BAR_JOBS
        WHERE N = VJOBN
          AND TD = KK_COMMON.GETTD
          AND UP= -1
    )
    LOOP
      UPDATE ST_BAR_JOBS
        SET TEAM_EMPS = VTEAMEMPS
        WHERE ROWID = J.RD;
    END LOOP;
  END IF;
  PMSG := VMSG;
  RETURN -VJOBTYP;
END SUBMITTEAMEMPS;

FUNCTION  INPUTMOVECNTCHECK(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VJOBN         INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ST_BAR_JOBS.N');
  VCONTRAGENTN  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VUNIT         INTEGER := KK_CONST.GETCONSTN('MOVEMENT.INPUTCNTUNIT', SYSDATE, VCONTRAGENTN);
  VCELLADDRESSN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS_N');
  VPALLN        INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');
  VCNT          INTEGER;
  VINPUTCNT     INTEGER;
  VRET          INTEGER;
BEGIN
  VINPUTCNT := TO_NUMBER(PKEYCODE);
  IF VINPUTCNT <0 THEN
    RAISE_APPLICATION_ERROR(-20000, 'ЧИСЛО ДОЛЖНО БЫТЬ ПОЛОЖИТЕЛЬНЫМ');
  END IF;
/*  SELECT SUM(CEIL(ST.CNT/NULLIF(POWER(NU.UNIT_CNT, NVL(NU.CNT_EXPONENT,1)),0) ))
    INTO VCNT
    FROM ST_STOCK ST
    JOIN NOM_UNIT NU ON (ST.NOMENKLATURA_N = NU.NOMENKLATURA_N AND NU.UNIT_TYP = VUNIT AND NU.TD = KK_COMMON.GETTD)
    WHERE CELL_ADDRESS_N = VCELLADDRESSN
      AND ST_PALL_N = VPALLN
      AND ST.TD = KK_COMMON.GETTD;*/
  SELECT SUM(CNT)
    INTO VCNT
    FROM ST_BAR_JOBS
    WHERE STATUS = 2
      CONNECT BY UP = PRIOR ST_STOCK_N
      START WITH N = VJOBN;
  IF VINPUTCNT = VCNT THEN
    VRET := 1;
    PMSG := '';
  ELSIF VINPUTCNT > VCNT THEN
    RAISE_APPLICATION_ERROR(-20000, '<ERR>ВВЕДЁННОЕ КОЛИЧЕСТВО БОЛЬШЕ ЧЕМ КОЛИЧЕСТВО В ЗАДАНИИ: '||VINPUTCNT||' / '||VCNT||'/<ERR>');
  ELSIF VINPUTCNT < VCNT THEN
    VRET := 2;
    PMSG := 'ВВЕДЁННОЕ КОЛИЧЕСТВО МЕНЬШЕ ЧЕМ КОЛИЧЕСТВО В ЗАДАНИИ: '||VINPUTCNT||' / '||VCNT;
  END IF;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'CNT', VINPUTCNT);
  RETURN VRET;
END INPUTMOVECNTCHECK;

FUNCTION CHECKINPUTCELLADDRESS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS

--VCELLN INTEGER;
VSIZE_ INTEGER;
VPALL_TYP INTEGER;
VEMPTY NUMBER;
VCELL_TYP_N INTEGER;
VADDR VARCHAR2(50);
VDOC VARCHAR2(50);


VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N');
VADDRTO INTEGER;
VADDRFROM INTEGER;
VSTOREN INTEGER;
VSTOREN2 INTEGER;
VCONTRAGENTN INTEGER;
VCELL_TYP_N_TO INTEGER;
VCELL_TYP_N_FROM INTEGER;
VDETADDR INTEGER;
VSTOCKN INTEGER;
VSTOREAREAN INTEGER;
VNOMN INTEGER;
VNOMGROUPN INTEGER;
VCONTRAGENTN2 INTEGER;
VBLOCKN INTEGER;
K INTEGER;
VCANIGNOREINPUT INTEGER:= NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUTFROM'), 0);
VCOUNT INTEGER;
VCELL_TYP_N_TO2 INTEGER;
  VPALLN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'PID');
  VPERMITALLOWMIX INTEGER := KK_PERMIT.EXISTSPERMITACCESS(VEMPN, 'ALLOWPUTONSTOREPLACEMIXPALL', SYSDATE);
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
/*  ЗАДАЧА6956
   ПРИ ПЕРЕМЕЩНИЯХ ПО ИНИЦИАТИВЕ СКЛАДА ПРОВЕРЯТЬ ЗАНЯТОСТЬ ЯЧЕЙКИ(ТАМ ЧИСЛИТСЯ ТОВАР ИЛИ В ЭТОТ АДРЕС ПЛАНИРУЕТСЯ РАЗМЕСТИТЬ ПРИХОД).
   ЕСЛИ ОНА ЗАНЯТА ЗАПРАШИВАТЬ ПОДТВЕРЖДЕНИЕ ДАННОГО ПЕРЕМЕЩЕНИЯ.
   ТАК ЖЕ ПРОВЕРЯТЬ НЕ ЯВЛЯЕТСЯ ЛИ ДАННАЯ ЯЧЕЙКА  ХРАНЕНИЕМ И ПОДБОРКОЙ БРАКА,
   ПРИНАДЛЕЖНОСТЬ ЯЧЕЙКИ К ДАННОЙ ОБЛАСТИ КОНТРАГЕНТА
*/
FOR J IN (SELECT LEVEL AS LVL ,P.TYP,P.VAL1,P.VAL2,P.VAL4,P.VAL6
        FROM MCIS_NODES_PROC P
             WHERE TYP IN (13,4)
            CONNECT BY   N =PRIOR UP
 START WITH N = PPROCN
  ORDER BY LEVEL)
LOOP

 IF J.LVL = 1  AND J.TYP = 13 AND VADDRTO IS NULL THEN
   VADDRTO := J.VAL1;
   VSTOREN := J.VAL2 ;
 END IF;

 IF J.TYP = 4 THEN  /*ПЕРЕМЕЩЕНИЯ С 0 ПИДА*/
   VNOMN := J.VAL1;
   VCONTRAGENTN2 :=  J.VAL6 ;
 END IF;

 IF J.LVL <> 1  AND J.TYP = 13 AND VADDRFROM IS NULL THEN
   VADDRFROM := J.VAL1;
   VSTOREN2 := J.VAL2 ;
   EXIT;
 END IF;
END LOOP;


IF ( VSTOREN2 <> VSTOREN) AND (VCANIGNOREINPUT=0 OR VSTOREN2 >0)   THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>МЕЖСКЛАДСКИЕ ПЕРЕМЕЩЕНИЯ ЗАПРЕЩЕНЫ!!!</ERR>');
END IF;

IF VADDRTO = VADDRFROM  THEN
 RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС НАЗНАЧЕНИЯ ДОЛЖЕН ОТЛИЧАТЬСЯ ОТ ИСХОДНОГО!!!</ERR>');
END IF;


BEGIN
  SELECT DECODE(NVL(CELL_TYP_N,0),-3,-3,1) INTO VCELL_TYP_N_FROM
  FROM CELL_ADDRESS WHERE N = VADDRFROM
  AND SYSDATE BETWEEN FD AND TD;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
    IF VCANIGNOREINPUT != 1 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>НАЧАЛЬНАЯ ЯЧЕЙКА НЕ ОБНАРУЖЕНА, ВОЗМОЖНО ОНА УДАЛЕНА С-'||VADDRFROM||'</ERR>PPROCN='||PPROCN||SQLERRM);
    END IF;
END;

BEGIN
  SELECT DECODE(NVL(CELL_TYP_N,0),-3,-3,1),CELL_TYP_N INTO VCELL_TYP_N_TO,VCELL_TYP_N_TO2
  FROM CELL_ADDRESS WHERE N = VADDRTO
  AND SYSDATE BETWEEN FD AND TD;
EXCEPTION
  WHEN OTHERS THEN -- CAUTION HANDLES ALL EXCEPTIONS
 RAISE_APPLICATION_ERROR(-20000,'<ERR>КОНЕЧНАЯ ЯЧЕЙКА НЕ ОБНАРУЖЕНА, ВОЗМОЖНО ОНА УДАЛЕНА С-'||VADDRTO||'</ERR>PPROCN='||PPROCN||SQLERRM);
END;

/*    IF VCELL_TYP_N_TO2 = -1 THEN
     IF KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CHECKNOMCELLADDRESS',SYSDATE) != 3
        THEN
            SELECT COUNT(1) INTO VCOUNT
            FROM NOM_CELL_ADDRESS
            WHERE NOMENKLATURA_N IN
                (SELECT DISTINCT(NOMENKLATURA_N)
                        FROM ST_STOCK
                   WHERE CELL_ADDRESS_N = VADDRFROM AND
                   TD = KK_COMMON.GETTD)
            AND CELL_ADDRESS_N = VADDRTO
            AND TD = KK_COMMON.GETTD;
                 IF VCOUNT != 1 THEN
                      RAISE_APPLICATION_ERROR(-20001,'ЯЧЕЙКА НЕ ПРИПИСАНА К НОМЕНКЛАТУРЕ ИЛИ НЕ НАСТРОЕН ДОСТУП CHECKNOMCELLADDRESS');
                 END IF;
     END IF;
    END IF;*/
-----------------------------------------------------------------------------------------
--БРАК В БРАК КОНДИЦИЮ В КОНДИЦИЮ, ЗАНЯТОСТЬ ЯЧЕЙКИ, ОБЛАСТЬ КОНТРАГЕНТА
-----------------------------------------------------------------------------------------
IF KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CHECKINPUTCELLADDRESS',SYSDATE) != 3 THEN --СУПЕРДОСТУП НА ПЕРЕМЕЩЕНИЯ

-- DVE DKN БРАКУЕТ ПОТОМ ПЕРЕМЕЩАЕТ!
-- DENIS РАСКОМЕНТИЛ ПО ЗАДАЧЕ 30270
IF KK_CONST.GETCONSTV('NEEDINPUTBRAKTONOTBRAKCELL',SYSDATE,0)=1 THEN
 IF VCELL_TYP_N_FROM = -3 AND VCELL_TYP_N_TO = 1 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВОЗМОЖНО ПЕРЕМЕЩАТЬ ТОВАР ИЗ БРАКА В КОНДИЦИЮ!!!</ERR>');
  END IF;

  IF VCELL_TYP_N_FROM = 1 AND VCELL_TYP_N_TO = -3 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВОЗМОЖНО ПЕРЕМЕЩАТЬ ТОВАР ИЗ КОНДИЦИИ В ЯЧЕЙКИ БРАКА!!!</ERR>');
  END IF;

  IF  VCELL_TYP_N_TO = -5 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВОЗМОЖНО ПЕРЕМЕЩАТЬ ТОВАР НА ЯЧЙКИ КОНСОЛИДАЦИИ!!!</ERR>');
  END IF;
END IF; -- KK_CONST.GETCONSTV('NEEDINPUTBRAKTONOTBRAKCELL',SYSDATE,0)=1

  IF  VCELL_TYP_N_TO = -5 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕВОЗМОЖНО ПЕРЕМЕЩАТЬ ТОВАР НА ЯЧЙКИ КОНСОЛИДАЦИИ!!!</ERR>');
  END IF;

FOR K IN (
       SELECT/*+ ORDERED INDEX_DESC(ST ST_STOCK_N_FD_TD)*/
            RANK()OVER ( ORDER BY P.RN DESC)AS P_R,
            RANK()OVER ( PARTITION BY DECODE(ST.N,NULL,0,1) ORDER BY ST.N)AS S_R,
            ST.CONTRAGENT_N ,ST.NOMENKLATURA_N
        FROM
          (SELECT ROW_NUMBER() OVER (PARTITION BY 1 ORDER BY P.VAL1) AS RN ,P.VAL1
              FROM
            (SELECT  VAL1 FROM MCIS_NODES_PROC
              WHERE TYP = 29
                CONNECT BY PRIOR UP = N AND SYSDATE BETWEEN FD AND TD
                    START WITH N = PPROCN AND SYSDATE BETWEEN FD AND TD
                    ORDER BY VAL1 DESC
              ) P
            ) P
            LEFT OUTER JOIN ST_STOCK ST
                    ON (ST.N = P.VAL1  AND ST.TYP IN (1/*IN*/,3,5,10,12/*BRAK*/,13/*UNRESERVED*/)
                    AND SYSDATE BETWEEN ST.FD AND ST.TD
                    AND ST.CNT > 0
                    AND ST.TD = TO_DATE('01-01-3000','DD-MM-YYYY'))
           WHERE ROWNUM <= 1
           ORDER BY P.RN
    )
LOOP
  VCONTRAGENTN := K.CONTRAGENT_N;

  SELECT/*+ INDEX(BL CELL_ADDRESS_BLOCKED_ADDR_TD)*/ COUNT(BL.N) INTO VBLOCKN
  FROM CELL_ADDRESS_BLOCKED_X BL
  WHERE BL.CELL_ADDRESS_N = VADDRTO
  AND DECODE(BL.CONTRAGENT_N,0, VCONTRAGENTN , BL.CONTRAGENT_N)   = VCONTRAGENTN
  AND DECODE(BL.NOMENKLATURA_N ,0, K.NOMENKLATURA_N , BL.NOMENKLATURA_N)  = K.NOMENKLATURA_N
  AND SYSDATE BETWEEN BL.FD AND BL.TD;

  IF VBLOCKN > 0 THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА ЗАБЛОКИРОВАНА!!!</ERR>');
  END IF;

END LOOP;

  IF VCONTRAGENTN IS NULL THEN  /*ВЕТКА ПЕРЕМЕЩЕНИЯ С 0 ПИДА*/
    SELECT/*+ INDEX(BL CELL_ADDRESS_BLOCKED_ADDR_TD)*/ COUNT(BL.N) INTO VBLOCKN
    FROM CELL_ADDRESS_BLOCKED_X BL
    WHERE BL.CELL_ADDRESS_N = VADDRTO
    AND DECODE(BL.CONTRAGENT_N,0, VCONTRAGENTN , BL.CONTRAGENT_N)   = VCONTRAGENTN
    AND DECODE(BL.NOMENKLATURA_N ,0, VNOMN , BL.NOMENKLATURA_N)  = VNOMN
    AND SYSDATE BETWEEN BL.FD AND BL.TD;

    IF VBLOCKN > 0 THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА ЗАБЛОКИРОВАНА!!!</ERR>');
    END IF;
    VCONTRAGENTN := VCONTRAGENTN2;
  END IF;


WITH SA AS   (
 SELECT/*+ INDEX(NS NOM_STORE_AREA_NOM_AREA_TD_FD)*/ SA.N
    FROM STORE_AREA SA
    CONNECT BY PRIOR SA.N = SA.UP AND SYSDATE BETWEEN SA.FD AND SA.TD
    START WITH SYSDATE BETWEEN SA.FD AND SA.TD
      AND SA.N IN (SELECT NS.STORE_AREA_N FROM  CONTRAGENT_STORE_AREA NS
        WHERE NS.CONTRAGENT_N = VCONTRAGENTN AND SYSDATE BETWEEN NS.FD AND NS.TD  )
        AND SA.STORE_N = VSTOREN
          )
  SELECT/*+ ORDERED INDEX(CA CELL_ADDRESS_STORE_AREA)*/ COUNT(CA.N) INTO VSTOREAREAN
  FROM
    CELL_ADDRESS CA
     JOIN SA ON ( CA.STORE_AREA = SA.N)
  WHERE CA.N = VADDRTO
     AND SYSDATE BETWEEN CA.FD AND CA.TD
  ;

  IF VSTOREAREAN = 0  THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА НЕ ПРИНАДЛЕЖИТ ОБЛАСТИ КОНТРАГЕНТА!!!'||VADDRTO||'_'||VCONTRAGENTN||'_'||VSTOREN||'</ERR>');
--   RAISE_APPLICATION_ERROR(-20000,'<ERR>ЯЧЕЙКА НЕ ПРИНАДЛЕЖИТ ОБЛАСТИ КОНТРАГЕНТА!!!</ERR>');
  END IF;


  SELECT /*+ INDEX(A ST_DOC_IN_DET_ADDR_CELL_NOM)*/ COUNT(1) INTO VDETADDR
  FROM ST_DOC_IN_DET_ADDR A
     JOIN ST_DOC_IN_DET D ON (A.ST_DOC_IN_DET_N = D.N
     AND SYSDATE BETWEEN D.FD AND D.TD)
     JOIN ST_DOC_IN I ON (D.SQ_ST_DOC_IN_N = I.N
     AND SYSDATE BETWEEN I.FD AND I.TD
     AND I.FD >= SYSDATE - 30
     AND I.STATUS != 4)
   WHERE 1=1
     AND A.CELL_ADDRESS_N = VADDRTO
     AND SYSDATE BETWEEN A.FD AND A.TD
     AND ROWNUM <= 1;

  IF VDETADDR <> 0 THEN
    PMSG := 'ВНИМАНИЕ! ЕСТЬ РАЗМЕЩЕНИЕ В ДАННУЮ ЯЧЕЙКУ!!!';
  END IF;

  SELECT /*+ INDEX(S ST_STOCK_ALLOC_RULEHINTTOSTOCK)*/ COUNT(1) INTO VSTOCKN
  FROM ST_STOCK S
  WHERE 1 = 1
    AND S.TD = KK_COMMON.GETTD
    AND S.CELL_ADDRESS_N = VADDRTO
    AND ROWNUM <= 1;

  IF VSTOCKN <> 0 THEN
    PMSG := PMSG||V1310||'ВНИМАНИЕ! ЭТА ЯЧЕЙКА НЕ ПУСТА!!!';
  END IF;


END IF;
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

/*РАСКОММЕНТИРОВАЛ ДВЕ 15 07 2014 МИ ПРОБЛЕМЫ С ПОСТАНОВКОЙ КУДА!*/
FOR J IN (SELECT TYP,VAL1,VAL2
             FROM MCIS_NODES_PROC
               WHERE TYP IN (13)
               CONNECT BY PRIOR UP = N
                 START WITH N =  PPROCN
                     ORDER BY LEVEL
) LOOP

   SELECT A.SIZE_,A.PALL_TYP,A.STORE_N,A.CELL_TYP_N,A.ADDR
     INTO VSIZE_ ,VPALL_TYP ,VSTOREN,VCELL_TYP_N,VADDR
     FROM CELL_ADDRESS A
    WHERE A.N =J.VAL1
      AND SYSDATE BETWEEN A.FD AND A.TD;

  IF NVL(VNOMN ,0) = 0 THEN
    SELECT NOMENKLATURA_N
      INTO VNOMN
      FROM ST_STOCK
      WHERE ST_PALL_N = VPALLN
        AND TD = KK_COMMON.GETTD
        AND CELL_ADDRESS_N = VADDRFROM
        AND ROWNUM = 1;
  END IF;
  SELECT GROUP_N
    INTO VNOMGROUPN
    FROM NOMENKLATURA
    WHERE N = VNOMN
      AND TD= KK_COMMON.GETTD;
  KK_REP.ASSIGN('KK_ST_ALLOC.NOM_GROUP_N', VNOMGROUPN);
  KK_REP.ASSIGN('KK_ST_ALLOC.NOMENKLATURA_N', VNOMN);

    VEMPTY := KK_ST_ALLOC.GETLEFTOFADDRESS(J.VAL1, VSIZE_, KK_CONST.GETCONSTN('STDOCMOVE.MOVEONLYTOEMPTYCELL', SYSDATE), VPALL_TYP, VSTOREN);
    IF (VEMPTY - 1/*ПЕРЕМЕЩАЕМАЯ ПАЛЛА*/  < 0) AND ( (KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CHECKINPUTCELLADDRESS',SYSDATE)!=3) OR  (KK_PERMIT.EXISTSPERMITACCESS(VEMPN,'CHECKINPUTCELLADDRESS',SYSDATE)=3 AND KK_CONST.GETCONSTV('STDOCMOVE.CHECKCELLSIZE.TYPEEXCL',SYSDATE, VCONTRAGENTN) NOT LIKE '%,'|| VCELL_TYP_N ||',%') ) THEN
        RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС '||VADDR||' ЗАНЯТ!!!! EMPTY='||ROUND(VEMPTY-1,3)||'</ERR>');
    END IF;
 /*  IF VEMPTY <> VSIZE_ THEN
    BEGIN
      SELECT SI.N, SJ.ST_PALL_N
        INTO VDOC, VPALL
        FROM ST_BAR_JOBS SJ
        LEFT OUTER JOIN ST_DOC_IN   SI ON (SI.N = SJ.BASE_DOC_N)
       WHERE SJ.TYP=11 AND SYSDATE BETWEEN  SJ.FD AND SJ.TD AND SJ.CELL_ADDRESS_N=J.VAL1;
    EXCEPTION WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС '||VADDR||' ЗАНЯТ!!!!'||'</ERR>');
    END;
    RAISE_APPLICATION_ERROR(-20000,'<ERR>АДРЕС '||VADDR||' ЗАНЯТ!!!! ПРИХОД '||VDOC||' НОМЕР ПАЛЛЕТЫ '||VPALL||'.'||'</ERR>');
   END IF;
*/
   EXIT;
  END LOOP;

IF VPERMITALLOWMIX = 0 AND VCELL_TYP_N_TO2 = 1 THEN
  FOR REC IN (
    SELECT COUNT(DISTINCT NOMENKLATURA_N) AS CNT
      FROM V_ST_STOCK_ACTIVE
      WHERE CELL_ADDRESS_N = VADDRFROM
      AND ST_PALL_N = VPALLN
  )
  LOOP
   IF REC.CNT > 1 THEN
    RAISE_APPLICATION_ERROR(-20000, 'НА ПАЛЛЕТЕ БОЛЬШЕ 1 НОМЕНКЛАТУРЫ. РАЗМЕЩЕНИЕ ЗАПРЕЩЕНО. ДОСТУП ALLOWPUTONSTOREPLACEMIXPALL');
   END IF;
  END LOOP;
END IF;

RETURN 1;
END CHECKINPUTCELLADDRESS;

FUNCTION INBOUNDGETUNITBYSCAN(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VRET INTEGER := 0;

VNOMN        INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
VCONTRAGENTN INTEGER :=     KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N'  );

VSCANNEDCNT  INTEGER := NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'INBOUND.UNIT.GETTED' ),0);
VSCANNOMN INTEGER;
VSCANNOMNAME VARCHAR2(255);
VSTR VARCHAR2(4000);
VBARCODE NOMENKLATURA.CODE%TYPE;
VCNT INTEGER;
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN

BEGIN



--/////////////////

 IF (PSTR IS NOT NULL) AND KK_BARCODE_MASK.PARCEBARCODE(PROBJN ,PSTR,VSTR) != 0 THEN

      VBARCODE := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.CODE' );
          VCNT := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'BARCODE.UNIT_CNT' );
                     KK_BARCODE_MASK.CLEARBARCODEVAR(PROBJN,NULL);
 ELSE
     VBARCODE := PSTR;
         VCNT := 1;
 END IF;

--/////////////////


 SELECT/*+ ORDERED*/
    N.N,N.CODE ||' ' ||N.NAME
    INTO VSCANNOMN , VSCANNOMNAME
     FROM NOM_BARCODE B
        JOIN NOMENKLATURA N ON (  B.NOMENKLATURA_N = N.N  AND SYSDATE BETWEEN N.FD AND N.TD )
   WHERE UPPER(TRIM(B.BAR_CODE)) = UPPER(TRIM(VBARCODE))
      AND SYSDATE BETWEEN B.FD AND B.TD
      AND B.CONTRAGENT_N = VCONTRAGENTN ;


 IF VSCANNOMN != VNOMN THEN
    RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА НЕ ТА! "'||PSTR ||'"</ERR>');
 END IF; --- IF VSCANNOMN != VNOMN THEN

              VSCANNEDCNT := VSCANNEDCNT + VCNT;

    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INBOUND.UNIT.GETTED' , VSCANNEDCNT );
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'CNT',VSCANNEDCNT);
    PMSG := 'ПРИНЯЛИ '|| TO_CHAR(VSCANNEDCNT) ||  V1310 ||
                                TO_CHAR(VSCANNOMNAME) ;
   VRET := 1;

 IF NVL(VSCANNEDCNT,0) = 0 THEN
RAISE_APPLICATION_ERROR(-20000,'<ERR>ВВЕДЕННОЕ КОЛ-ВО ДОЛЖНО БЫТЬ БОЛЬШЕ НУЛЯ!');
END IF;

 INSERT INTO MCIS_NODES_PROC(N , TYP, VAL1, VAL2 , VAL3 , FD , TD , DSC, UP )  VALUES
  (SQ_MCIS_NODES_PROC.NEXTVAL,5/*ЗАПОМНИЛИ КОЛИЧЕСТВО*/,VSCANNEDCNT,NULL,NULL,SYSDATE,KK_COMMON.GETTD,'ЗАПОМНИЛИ КОЛИЧЕСТВО',PPROCN)
   RETURNING N INTO PPROCN;


EXCEPTION
  WHEN TOO_MANY_ROWS THEN
   RAISE_APPLICATION_ERROR(-20000,'<ERR>НЕСКОЛЬКО НОМЕНКЛАТУР ПО ОДНОМУ ШТРИХКОДУ! "'||PSTR ||'"</ERR>');
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR(-20000,'<ERR>НОМЕНКЛАТУРА ПО КОДУ НЕ НАЙДЕНА! "'||PSTR ||'"</ERR>');
END;

--RAISE_APPLICATION_ERROR(-20000,PSTR||'_'||VBARCODE||' '||VRET);

--RAISE_APPLICATION_ERROR(-20000,'PSTR='||PSTR);

RETURN VRET;

END INBOUNDGETUNITBYSCAN;

PROCEDURE REPAIRNODESPERMITS IS
BEGIN

FOR J IN (
SELECT A.MCIS_NODES_N , A.PERMIT
  FROM MCIS_NODES_ACCESS A
 WHERE SYSDATE BETWEEN FD AND TD
) LOOP

UPDATE MCIS_NODES
 SET PERMIT = J.PERMIT
  WHERE N = J.MCIS_NODES_N
  AND SYSDATE BETWEEN FD AND TD;

END LOOP;

END;

FUNCTION  STDOCMOVE_BEFOREINPUTCELLFROM (PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER  IS
VCANIGNOREINPUT INTEGER:=0;
BEGIN --11714 ЗАДАЧА, ПРОВЕРЯЕТ ДОСТУП, ЗАДАЕТ, МОЖНО ЛИ ИГНОРИРОВАТЬ ВВОД НАЧАЛЬНОЙ ЯЧЕЙКИ
  BEGIN
    VCANIGNOREINPUT:=KK_PERMIT.EXISTSPERMITACCESS(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'),
                                                  'STDOCMOVE.JOB.SKIPSCANADDRFROM',
                                                   SYSDATE);
   IF VCANIGNOREINPUT=3 THEN VCANIGNOREINPUT:=1; END IF;

  EXCEPTION
    WHEN OTHERS THEN VCANIGNOREINPUT:=0;
  END;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT',VCANIGNOREINPUT);
  RETURN 1;
END STDOCMOVE_BEFOREINPUTCELLFROM;

FUNCTION  STDOCMOVE_BEFOREINPUTCELLTO(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN --11714 ЗАДАЧА, ПРОВЕРЯЕТ ДОСТУП, ЗАДАЕТ, МОЖНО ЛИ ИГНОРИРОВАТЬ ВВОД ЯЧЕЙКИ НАЗНАЧЕНИЯ, ПО УМ.- НЕЛЬЗЯ

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT',0);
   RETURN 1;
END STDOCMOVE_BEFOREINPUTCELLTO;


FUNCTION  STDOCMOVE_INIT_BEFINPUTCELLFR(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER  IS
  VCANIGNOREINPUT INTEGER:=0;
BEGIN --11714 ЗАДАЧА, ПРОВЕРЯЕТ ДОСТУП, ЗАДАЕТ, МОЖНО ЛИ ИГНОРИРОВАТЬ ВВОД НАЧАЛЬНОЙ ЯЧЕЙКИ
  BEGIN
    VCANIGNOREINPUT:=KK_PERMIT.EXISTSPERMITACCESS(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'EMP_N'),
                                                  'STDOCMOVE.INITIAL.SKIPSCANADDRFROM',
                                                   SYSDATE);
   IF VCANIGNOREINPUT=3 THEN VCANIGNOREINPUT:=1; END IF;

  EXCEPTION
    WHEN OTHERS THEN VCANIGNOREINPUT:=0;
  END;

  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT',VCANIGNOREINPUT);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUTFROM',VCANIGNOREINPUT);
  RETURN 1;
END STDOCMOVE_INIT_BEFINPUTCELLFR;


FUNCTION  STDOCMOVE_INIT_BEFINPUTCELLTO(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
BEGIN --11714 ЗАДАЧА, ПРОВЕРЯЕТ ДОСТУП, ЗАДАЕТ, МОЖНО ЛИ ИГНОРИРОВАТЬ ВВОД ЯЧЕЙКИ НАЗНАЧЕНИЯ, ПО УМ.- НЕЛЬЗЯ

   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUT',0);
   PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'INPUTCELLADDRESS.CANIGNOREINPUTTO',0);
   RETURN 1;
END STDOCMOVE_INIT_BEFINPUTCELLTO;


FUNCTION  INPUTADDRESS_COMPAREDEFAULT(PSTRINPUT IN VARCHAR2, PADDR IN VARCHAR2) RETURN INTEGER IS
BEGIN      /*ВОЗВРАЩАЕТ 1, ЕСЛИ СТРОКИ ПРИЗНАНЫ ОДИНАКОВЫМИ*/
  IF NVL(TRIM(PSTRINPUT),'_')='_'
     THEN RETURN 0;
  ELSIF LOWER(PSTRINPUT)=LOWER (PADDR)
     THEN RETURN 1;
     ELSE RETURN 0;
  END IF;
END INPUTADDRESS_COMPAREDEFAULT;

FUNCTION  INPUTADDRESS_COMPARE(PSTRINPUT IN VARCHAR2, PADDR IN VARCHAR2) RETURN INTEGER IS
   VPROC VARCHAR(255):= KK_CONST.GETCONSTV('STBARCODE.INPUTADDR.COMPARE',SYSDATE,0);
   VRET INTEGER:=0;
BEGIN      /*ВОЗВРАЩАЕТ 1, ЕСЛИ СТРОКИ ПРИЗНАНЫ ОДИНАКОВЫМИ*/
  IF NVL(TRIM(VPROC),'_')='_' THEN
    VRET:= KK_ST_BARCODE.INPUTADDRESS_COMPAREDEFAULT(PSTRINPUT,PADDR);
  ELSE
    EXECUTE IMMEDIATE  'BEGIN :RES:='||VPROC||'(:STRA, :STRB); END;'
     USING OUT VRET, IN PSTRINPUT, IN PADDR;
  END IF;


  RETURN VRET;
END INPUTADDRESS_COMPARE;


FUNCTION BEFOREPALLSUBMITMSG(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
    VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
    VMSG VARCHAR2(500);
---!!!! СОЗДАТЬ КОНСТАНТУ !! С ПРАВИЛЬНЫМ ОПИСАНИЕС КОНСТАНТЫ В КОНСТАНТЕ ПРИМЕР ПРОЦЕДУРЫ С ПАРАМЕТРАМИ
    VPROC LIST_CONST.VAL%TYPE := KK_CONST.GETCONSTV('STDOCIN.BEFOREPALLSUBMITMSG.PROC',SYSDATE,VCONTRAGENTN);
    V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
    VNEEDINBOUNDINPUTPROPITEMS LIST_CONST.VAL%TYPE;
    VINPUTPROPITEMSSUBMIT NUMBER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'STDOCIN.PROPITEMS.SUBMIT');
 VPDOCN INTEGER  := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'ST_DOC_IN.N');
BEGIN
 -----------
 /*ПРОВЕРКА ВВОДИЛИ ЛИ ДОП ПАРАМЕТРЫ.
    ЕСЛИ НЕ ВВОДИЛИ И НЕОБХОДИМО ПЕРЕХОДИМ ИЗ ДАННОГО УЗЛА ТАК КАК В 668 ПРИХОДИМ ИЗ 4 УЗЛОВ*/


 SELECT KK_CONST.GETCONSTV('STDOCIN.NEEDINBOUNDINPUTPROPITEMS',SYSDATE,D.CONTRAGENT_N,D.TYP)
      INTO VNEEDINBOUNDINPUTPROPITEMS
    FROM ST_DOC_IN D WHERE D.N = VPDOCN AND D.TD = KK_COMMON.GETTD;
   BEGIN
    IF NVL(VNEEDINBOUNDINPUTPROPITEMS,'_') != '_'
        AND NVL(VINPUTPROPITEMSSUBMIT,0) != 2 /*ДОП.ПАР ВВЕДЕНЫ*/ THEN
    RETURN 3;
    END IF;

   END;
---------------

-- RAISE_APPLICATION_ERROR(-20000,'TEST');
  IF VPROC != '_' THEN
   EXECUTE IMMEDIATE 'BEGIN :PMSG := '|| VPROC ||'(); END;'  USING IN OUT VMSG ;
  PMSG := PMSG || V1310 || VMSG ;
  END IF; --IF VPROC != '' THEN

   RETURN 1;

END BEFOREPALLSUBMITMSG;


FUNCTION  ALLDIMENSIONSEXISTS(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VNOMN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA_N');
  VNOMUNIT INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOMENKLATURA.UNIT_TYP');
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VWEIGHTSKIP VARCHAR2(255) := KK_CONST.GETCONSTV('NOMCHECKDIMENTEXISTS.WEIGHTCANBEMISSED', SYSDATE, VCONTRAGENTN);
  V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
  VRET INTEGER;
BEGIN
  SELECT COUNT(*)
    INTO VRET
    FROM NOM_UNIT NU
    WHERE NOMENKLATURA_N = VNOMN
      AND NU.UNIT_TYP = VNOMUNIT
      AND NU.TD = KK_COMMON.GETTD
      AND (
           NVL(NU.DIMENSION_L, 0) = 0
        OR NVL(NU.DIMENSION_H, 0) = 0
        OR NVL(NU.DIMENSION_W, 0) = 0
        OR NVL(NU.WEIGHT,0) = 0 AND VWEIGHTSKIP != 1
      );
  IF VRET > 0
  THEN
    PMSG := 'НЕ ВСЕ РАЗМЕРЫ ВВЕДЕНЫ'||V1310||PMSG;
    VRET := -1;
  ELSE
    VRET := 1;
  END IF;
/*  IF NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DIMENTION.X'), 0) = 0
    OR NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DIMENTION.Y'), 0) = 0
    OR NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DIMENTION.Z'), 0) = 0
    OR (NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DIMENTION.WEIGHT'), 0) = 0  AND KK_CONST.GETCONSTV('NOMCHECKDIMENTEXISTS.WEIGHTCANBEMISSED', SYSDATE, VCONTRAGENTN) != 1)
  THEN
    PMSG := 'НЕ ВСЕ РАЗМЕРЫ ВВЕДЕНЫ'||V1310||PMSG;
    VRET := -1;
  ELSE
    VRET := 1;
  END IF;
*/  RETURN VRET;
END ALLDIMENSIONSEXISTS;

FUNCTION SHOWNOMTYPRESPONSE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2
                          , PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER
                           )RETURN INTEGER IS
  VMSG VARCHAR2(1500);
  VNOMTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
V1310 CONSTANT VARCHAR2(2) := CHR(13)||CHR(10);
BEGIN
    PMSG := '';
-- ВЫВОДИМ СПИСОК ОТВЕТСТВЕННОГО ЗА БРАК
    FOR J IN(
      SELECT DD.CODE AS CODE,TERM --, ROW_NUMBER() OVER (ORDER BY DD.CODE) AS RN
        FROM DIC_DATA DD
        WHERE DD.UP = 521
          AND SYSDATE BETWEEN FD AND TD
          AND (R_N = VNOMTYP OR NVL(R_N,0) = 0 OR NVL(VNOMTYP, 0) = 0)
          -----------------
--          AND VNOMTYP = 3 -- ТОЛЬКО ДЛЯ БРАКА /* ДЕЛАЕТСЯ ЧЕРЕЗ R_N = 3*/
          -----------------
          AND KK_CONST.GETCONSTN('STBARJOBS.RESPONSE.NEED', SYSDATE) = 1
        ORDER BY DD.CODE
    ) LOOP
        VMSG :=  VMSG || J.CODE ||CHR(9)|| J.TERM || V1310;
    END LOOP;

--   VMSG := KK_ST_BARCODE.GETTERMLIST(496,NULL,VN);

   IF VMSG IS NULL THEN
     PMSG :=  NULL;
     RETURN -1;
   ELSE
     PMSG :=  PMSG ||VMSG;
     RETURN 1;
   END IF;

END SHOWNOMTYPRESPONSE;

FUNCTION INPUTNOMTYPRESPONSE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
VCODE INTEGER;
VNOMTYP INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'NOM_TYP');
BEGIN
  PMSG := '';
  BEGIN
    SELECT CODE,TERM
      INTO VCODE,PMSG
      FROM DIC_DATA DD
      WHERE DD.UP = 521
        AND SYSDATE BETWEEN FD AND TD
        AND (R_N = VNOMTYP OR NVL(R_N,0) = 0 OR NVL(VNOMTYP, 0) = 0)
        AND CODE = TO_NUMBER(PKEYCODE);

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20000,'<ERR>ВЫБЕРИТЕ ИЗ ПЕРЕЧИСЛЕНОГО</ERR>');
  END;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'NOM_TYP_RESPONSE',VCODE);
  IF NVL(KK_ST_BARCODE.SESSIONVARGET(PROBJN,'DEFAULTDATA'),0) = 1 THEN
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN,'DEF_NOM_TYP_RESPONSE',TO_NUMBER(PKEYCODE));
  END IF;
  RETURN 1;
END INPUTNOMTYPRESPONSE;

FUNCTION CHECKFORNEEDINPUTCONDTYPE(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VCONTRAGENTN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CONTRAGENT_N');
  VCOND INTEGER := KK_CONST.GETCONSTN('STDOCIN.DEFAULTCOND', SYSDATE, VCONTRAGENTN);
BEGIN
  IF VCOND = 1 THEN
    PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'NOM_TYP', 1);
    RETURN 2;
  ELSE
    RETURN 1;
  END IF;
END;

FUNCTION PREPARETOJOBDISMANTLED(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VEMPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'EMP_N');
  VEXIST INTEGER := 0;
BEGIN
  KK_ST_BAR_JOBS.FREEJOBS;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'JOB_TYP', 17);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'JOB_ORDER_TYPE', 17);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'INPUTCELLADDRESS.CANIGNOREINPUTFROM', 1);
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'BEGIN_FD', TO_CHAR(SYSDATE, 'DD.MM.YY HH24:MI:SS'));
  KK_ST_BARCODE.SESSIONVARCLOSE(PROBJN, 'ST_PART_N');
  IF PMSG IS NOT NULL THEN
    PMSG := PMSG||CHR(13)||CHR(10);
  END IF;
  FOR REC IN (
    SELECT DISTINCT J.ST_PALL_N, D.DOC, CC.NAME AS CC_NAME
      FROM ST_BAR_JOBS J
      JOIN ST_DOC_OUT D ON (D.N = J.BASE_DOC_N AND D.TD = KK_COMMON.GETTD)
      LEFT JOIN C_CONTRAGENT CC ON (CC.N = D.CCONTRAGENT_N AND CC.TD = KK_COMMON.GETTD)
      WHERE J.TYP = 17
        AND J.TD = KK_COMMON.GETTD
        AND (J.STATUS = 1 OR J.STATUS = 2 AND J.EMP_N = VEMPN)
  )
  LOOP
    VEXIST := 1;
    PMSG := PMSG||'P-'||REC.ST_PALL_N||' "'||REC.DOC||'" '||REC.CC_NAME||CHR(13)||CHR(10);
  END LOOP;
  IF VEXIST = 0 THEN
    PMSG := 'ЗАДАНИЙ НА РАЗБОР НЕТ';
  END IF;
  RETURN 1;
END PREPARETOJOBDISMANTLED;

FUNCTION CHECKNOMINDISMANTLED_SHOWADDR(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VNOMN   INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'NOMENKLATURA_N');
  VPALLN  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'PID');
  VSTOREN INTEGER;
  VCNT    INTEGER := 0;
  VSUM    INTEGER;
BEGIN
  FOR REC IN (
    SELECT DOS.STORE_N, COUNT(*) AS CNT, SUM(P.CNT) AS SUM_
     FROM ST_DOC_OUT_PICK P
      JOIN ST_DOC_OUT O ON (O.N = P.ST_DOC_OUT_N AND O.TD = KK_COMMON.GETTD)
      JOIN ST_DOC_OUT_STORE DOS ON (DOS.N = O.TYP AND DOS.TD = KK_COMMON.GETTD)
      WHERE P.ST_PALL_N = VPALLN
        AND P.NOMENKLATURA_N = VNOMN
        AND P.TD = KK_COMMON.GETTD
      GROUP BY DOS.STORE_N
  )
  LOOP
    VSTOREN := REC.STORE_N;
    VCNT := REC.CNT;
    VSUM := REC.SUM_;
    EXIT;
  END LOOP;
  IF VCNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20000, '<ERR>ДАННОЙ НОМЕНКЛАТУРЫ НЕ НАЙДЕНО В РАЗБИРАЕМОЙ ПАЛЛЕТЕ</ERR>');
  END IF;
  WITH
  ST AS (
    SELECT /*+ INLINE*/ *
      FROM ST_STOCK ST
      WHERE TYP IN (1/*IN*/,3,5,10,12/*BRAK*/,13/*UNRESERVED*/)
        AND CNT > 0
        AND ST.TD = KK_COMMON.GETTD
        AND ST.NOMENKLATURA_N = VNOMN
        AND ST.STORE_N = VSTOREN
  )
  ,NCA AS (
    SELECT C.ADDR, C.N, SUM(ST.CNT) AS CNT, SUM(ROUND(GREATEST(KK_ST_ALLOC.GETLEFTOFADDRESS(C.N,C.SIZE_,0, NB.PALL_TYPE, C.STORE_N)*NVL(NB.BLCK, 1), 0), 1)) AS FREE
      FROM NOM_CELL_ADDRESS NCA
      JOIN CELL_ADDRESS C ON (C.N = NCA.CELL_ADDRESS_N AND C.TD = KK_COMMON.GETTD)
      LEFT JOIN ST ON (ST.CELL_ADDRESS_N = C.N)
      LEFT JOIN NOM_BLCK NB ON (NB.NOMENKLATURA_N = VNOMN AND NB.PALL_TYPE = ST.PALL_TYPE AND NB.TD = KK_COMMON.GETTD)
      WHERE NCA.NOMENKLATURA_N = VNOMN
        AND NCA.TD = KK_COMMON.GETTD
        AND C.STORE_N = VSTOREN
      GROUP BY C.ADDR, C.N
      ORDER BY 1
  )
  , PODB AS (
    SELECT C.ADDR, C.N, SUM(ST.CNT) AS CNT, SUM(ROUND(GREATEST(KK_ST_ALLOC.GETLEFTOFADDRESS(C.N,C.SIZE_,0, NB.PALL_TYPE, C.STORE_N)*NVL(NB.BLCK, 1), 0),1)) AS FREE
      FROM ST
      JOIN CELL_ADDRESS C ON (C.N = ST.CELL_ADDRESS_N AND C.TD = KK_COMMON.GETTD)
      LEFT JOIN NOM_BLCK NB ON (NB.NOMENKLATURA_N = VNOMN AND NB.PALL_TYPE = ST.PALL_TYPE AND NB.TD = KK_COMMON.GETTD)
      WHERE C.CELL_TYP_N IN (-1, -11)
        AND C.N NOT IN (SELECT N FROM NCA)
      GROUP BY C.ADDR, C.N
      ORDER BY 1
  )
  , TXT AS (
    SELECT STRAGG_SEP(T_STR_SEP('(П)'|| ADDR||': '||NVL(TO_CHAR(CNT), '0')||'; CВОБОДНО='||FREE, CHR(13)||CHR(10))) AS TXT
      FROM NCA
    UNION ALL
    SELECT REPLACE( STRAGG( ADDR||': '||TO_CHAR(CNT)||'; CВОБОДНО='||FREE), ',', CHR(13)||CHR(10)) AS TXT
      FROM PODB
  )
  SELECT STRAGG_SEP(T_STR_SEP(TXT, CHR(13)||CHR(10)))
    INTO PMSG
    FROM TXT  ;
  FOR REC IN (
    SELECT *
      FROM NOMENKLATURA
      WHERE N = VNOMN
        AND TD = KK_COMMON.GETTD
  )
  LOOP
    PMSG := REC.CODE||' '||REC.NAME||' = '||VSUM||CHR(13)||CHR(10)||PMSG;
  END LOOP;
  RETURN 1;
END CHECKNOMINDISMANTLED_SHOWADDR;

FUNCTION CHECKCNTINDISMANTLED_SHOWJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VCNT   INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'CNT');
  VNOMN  INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'NOMENKLATURA_N');
  VPALLN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'PID');
  VCELLN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'CELL_ADDRESS_N');
  VADDR CELL_ADDRESS.ADDR%TYPE := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ADDR');
  VPICKCNT INTEGER;
  VUNIT VARCHAR2(255);
BEGIN
  SELECT N.CODE||' - '|| SUBSTR(N.NAME, 1, KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH', SYSDATE, N.CONTRAGENT_N)), SUM(P.CNT), DD.TERM
    INTO PMSG, VPICKCNT, VUNIT
    FROM ST_DOC_OUT_PICK P
    JOIN NOMENKLATURA N ON (N.N = P.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
    LEFT JOIN DIC_DATA DD ON (DD.UP = 362 AND DD.CODE= N.UNIT AND DD.TD = KK_COMMON.GETTD)
    WHERE P.ST_PALL_N = VPALLN
      AND P.NOMENKLATURA_N = VNOMN
      AND P.TD = KK_COMMON.GETTD
    GROUP BY N.CODE, N.NAME, N.CONTRAGENT_N, DD.TERM;
  IF VPICKCNT < VCNT THEN
    RAISE_APPLICATION_ERROR(-20000, '<ERR>ТАКОГО КОЛИЧЕСТВА НЕТ. КОЛ-ВО='||VPICKCNT||' </ERR>');
  END IF;
  PMSG := 'С ПАЛЛЕТЫ P-'||VPALLN||CHR(13)||CHR(10)||PMSG||CHR(13)||CHR(10)||'НА АДРЕС:'||VADDR||CHR(13)||CHR(10)||'КОЛ-ВО: '||VCNT||' '||VUNIT;
  RETURN 1;
END CHECKCNTINDISMANTLED_SHOWJOB;

FUNCTION SUBMITDISMANTLEDJOB(PKEYCODE IN VARCHAR2, PSTR IN VARCHAR2, PMSG IN  OUT VARCHAR2,PNEXTNODE IN OUT INTEGER,PPROCN IN OUT INTEGER,PROBJN IN OUT INTEGER)RETURN INTEGER IS
  VCNT      INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'CNT');
  VNOMN     INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'NOMENKLATURA_N');
  VEMPN     INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'EMP_N');
  VJOBN     INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'ST_BAR_JOBS.N');
  VPALLN    INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'PID');
  VCELLN    INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'CELL_ADDRESS_N');
  VCELLTYPN INTEGER := KK_ST_BARCODE.SESSIONVARGET(PROBJN,'CELL_ADDRESS.CELL_TYP_N');
  VBEGIN    DATE    := TO_DATE(KK_ST_BARCODE.SESSIONVARGET(PROBJN, 'BEGIN_FD'), 'DD.MM.YY HH24:MI:SS');
  VSTOCKN   INTEGER;
  VPICKCNT  INTEGER;
  VDOCOUTN  INTEGER;
  VDOCMOVEN INTEGER;
  VNDET     INTEGER;
  VSTOCKROW ST_STOCK%ROWTYPE;
  VC        INTEGER := 0;
BEGIN
  WHILE TRUE
  LOOP
    VC := VC+1;
    IF VC > 1000 THEN
      RAISE_APPLICATION_ERROR(-20000, '<ERR>ПРОИЗОШЛО ЗАЦИКЛИВАНИЕ. ОБРАТИТЕСЬ К АДМИНИСТРАТОРУ.</ERR>');
    END IF;
    FOR REC IN (
      SELECT P.ROWID AS RD, P.CNT, P.STOCK_N, P.NOMENKLATURA_N, O.CONTRAGENT_N
           , P.ST_DOC_OUT_N, M.N AS DOCMOVEN, DOS.STORE_N
           , S.EXPIRE_DATE, S.MAKE_DATE, S.CELL_ADDRESS_N, S.NOM_TYP
        FROM ST_DOC_OUT_PICK P
        JOIN ST_DOC_OUT O ON (O.N = P.ST_DOC_OUT_N AND O.TD = KK_COMMON.GETTD)
        JOIN ST_DOC_OUT_STORE DOS ON (DOS.N = O.TYP AND DOS.TD = KK_COMMON.GETTD)
        LEFT JOIN ST_DOC_MOVE M ON (M.STATUS = 3 AND M.PARENT_DOC = P.ST_DOC_OUT_N AND M.TD = KK_COMMON.GETTD)
        LEFT JOIN ST_STOCK S ON (S.N = P.STOCK_N)
        WHERE P.ST_PALL_N = VPALLN
          AND P.NOMENKLATURA_N = VNOMN
          AND P.TD = KK_COMMON.GETTD
          AND P.CNT > 0
        ORDER BY P.CNT
    )
    LOOP
      IF VDOCOUTN IS NULL THEN
        VDOCOUTN := REC.ST_DOC_OUT_N;
      END IF;
      VPICKCNT := LEAST(REC.CNT, VCNT);
      IF VDOCMOVEN IS NULL THEN
        IF REC.DOCMOVEN IS NULL THEN
          VDOCMOVEN :=
            KK_ST_DOC.CREATESTDOCMOVEHEADER(PN           => 0,
                                            PCONTRAGENTN => REC.CONTRAGENT_N,
                                            PDSC         => 'РАСТАНОВКА ПОДОБРАННОГО',
                                            PFD          => SYSDATE,
                                            PSTATUS      => 3,
                                            PDOCN        => REC.ST_DOC_OUT_N,
                                            PTYPDOC      => KK_CONST.GETCONSTN('STDOCMOVETYPFORINITIATIVMOVE', SYSDATE, REC.STORE_N),
                                            PWHO         => VEMPN);
        ELSE
          VDOCMOVEN := REC.DOCMOVEN;
        END IF;
      END IF;
      IF VPICKCNT = REC.CNT THEN
        UPDATE ST_DOC_OUT_PICK P
          SET P.TD = SYSDATE, P.CNT = 0
          WHERE P.ROWID = REC.RD;
      ELSE
        UPDATE ST_DOC_OUT_PICK P
          SET P.CNT = P.CNT-VPICKCNT
          WHERE P.ROWID = REC.RD;
      END IF;
      SELECT *
        INTO VSTOCKROW
        FROM ST_STOCK
        WHERE N = REC.STOCK_N
          AND TYP = 6
          AND TD = KK_COMMON.GETTD;
      IF REC.CNT > VPICKCNT THEN
        UPDATE ST_STOCK
          SET CNT = CNT-VPICKCNT
          WHERE N = REC.STOCK_N;
        VSTOCKROW.N := SQ_ST_STOCK.NEXTVAL;
        VSTOCKROW.CNT := VPICKCNT;
        INSERT INTO ST_STOCK
          VALUES VSTOCKROW
          RETURNING N
          INTO VSTOCKN;
      ELSE
        VSTOCKN := REC.STOCK_N;
        SELECT *
          INTO VSTOCKROW
          FROM ST_STOCK
          WHERE N = VSTOCKN;
      END IF;
      INSERT INTO ST_DOC_MOVE_DET
        (N, ST_DOC_MOVE_N, NOMENKLATURA_N, EXPIRE_DATE,MAKE_DATE,   CNT
        , CELL_ADDRESS_N, CELL_ADDRESS_NEW_N, DSC, FD,STOCK_N
        ,NOM_TYP,LEFT,ST_PALL_N)
        VALUES
        (SQ_ST_DOC_DET.NEXTVAL, VDOCMOVEN, REC.NOMENKLATURA_N, REC.EXPIRE_DATE, REC.MAKE_DATE, VPICKCNT
        , REC.CELL_ADDRESS_N , VCELLN, 'РАЗБОР СОБРАННОГО', SYSDATE, REC.STOCK_N
        ,REC.NOM_TYP, 0, 0)
        RETURNING N
        INTO VNDET;
      KK_COMMON.ACTION(VEMPN,'ST_DOC_MOVE_DET',VNDET,1,SYSDATE);

      UPDATE ST_STOCK
        SET TYP = 17, ST_DOC_N = VNDET, TD = SYSDATE-1/86400
        WHERE N = VSTOCKN;
      VSTOCKROW.UP := VSTOCKROW.N;
      VSTOCKROW.N := SQ_ST_STOCK.NEXTVAL;
      VSTOCKROW.FD := SYSDATE;
      VSTOCKROW.ST_PALL_N := 0;
      VSTOCKROW.CELL_ADDRESS_N := VCELLN;
      VSTOCKROW.ST_DOC_N := VNDET;
      VSTOCKROW.TYP := 17;
      IF VCELLTYPN = -3 THEN
        VSTOCKROW.NOM_TYP := 3;
      END IF;
      INSERT INTO ST_STOCK
        VALUES VSTOCKROW;
      INSERT INTO ST_BAR_JOBS
        (N,      FD,                TD,    TYP, PRIORITY,  STATUS, TERMINAL_N,EMP_N
        ,ST_DOC_TYP,ST_DOC_N, DSC, VAL1, RN, OP_FD, VAL2
        ,CONTRAGENT_N,NOMENKLATURA_N,VAL3,BASE_DOC_N,ST_STOCK_N,ST_PALL_N,JOB_BLOCK,CNT
        ,UP,CELL_ADDRESS_N, BEGIN_FD)
        VALUES
        (SQ_ST_BAR_JOBS.NEXTVAL, VBEGIN,SYSDATE, 17, NULL, 3, 0, VEMPN
        , 3, VNDET, 'KK_ST_BARCODE.SUBMITDISMANTLEDJOB', VPICKCNT, 0, VBEGIN, REC.CELL_ADDRESS_N
        , REC.CONTRAGENT_N, VNOMN, 1/*VVAL3*/, VDOCMOVEN, VSTOCKN, 0, NULL, VPICKCNT
        , 0, VCELLN, VBEGIN)
        RETURNING N
        INTO VJOBN;
      KK_COMMON.ACTION(VEMPN, 'ST_BAR_JOBS', VJOBN, 1, SYSDATE, 'KK_ST_BARCODE.SUBMITDISMANTLEDJOB');
      VCNT := VCNT - VPICKCNT;
      EXIT;
    END LOOP;
    EXIT WHEN VCNT = 0;
  END LOOP;
  IF VCNT > 0 THEN
    RAISE_APPLICATION_ERROR(-20000, 'НЕ СМОГЛИ СПИСАТЬ ВСЮ ПОДБОРКУ. ОБРАТИТЕСЬ К АДМИНИСТРАТОРУ.');
  END IF;
  SELECT STRAGG_SEP(T_STR_SEP( N.CODE||' - '|| SUBSTR(N.NAME, 1, KK_CONST.GETCONSTN('INPUTNOMBARCODE.OUTPUTNOMLENGTH', SYSDATE, N.CONTRAGENT_N))||': '||SUM(P.CNT)||DD.TERM, CHR(13)||CHR(10)))
    INTO PMSG
    FROM ST_DOC_OUT_PICK P
    LEFT JOIN NOMENKLATURA N ON (N.N = P.NOMENKLATURA_N AND N.TD = KK_COMMON.GETTD)
    LEFT JOIN DIC_DATA DD ON (DD.UP = 362 AND DD.CODE = N.UNIT AND DD.TD = KK_COMMON.GETTD)
    WHERE P.ST_PALL_N = VPALLN
      AND P.TD = KK_COMMON.GETTD
    GROUP BY N.CODE, N.NAME, N.CONTRAGENT_N, DD.TERM;
  PROBJN := KK_ST_BARCODE.SESSIONVARSET(PROBJN, 'BEGIN_FD', TO_CHAR(SYSDATE, 'DD.MM.YY HH24:MI:SS'));
  IF PMSG IS NULL THEN
    PMSG := 'ВСЯ ПАЛЛЕТА РАЗОБРАНА';
    KK_ST_BAR_JOBS.COMPLETEJOB(PROBJN, VJOBN, 17);
    SELECT COUNT(*)
      INTO VCNT
      FROM ST_DOC_OUT_DET D
      JOIN ST_STOCK S ON (S.ST_DOC_N = D.N AND S.TYP = 6)
      WHERE D.SQ_ST_DOC_OUT_N = VDOCOUTN
        AND D.TD = KK_COMMON.GETTD;
    IF VCNT = 0 THEN
      KK_ST_STATUS_CHANGE.CHANGEDOCSTATUS(PGRAPH => 1,
                                          PANODE => 17,
                                          PBNODE => 1,
                                          PROBJN => VDOCOUTN,
                                          PWHO   =>VEMPN);
    END IF;
    RETURN 1;
  ELSE
    PMSG := 'ОСТАЛОСЬ РАЗЛОЖИТЬ:'||CHR(13)||CHR(10)||PMSG;
    RETURN 2;
  END IF;
END SUBMITDISMANTLEDJOB;

END KK_ST_BARCODE;

